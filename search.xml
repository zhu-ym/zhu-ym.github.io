<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>利用Hexo搭建GitHub</title>
    <url>/2020/12/24/%E5%88%A9%E7%94%A8Hexo%E6%90%AD%E5%BB%BAGitHub/</url>
    <content><![CDATA[<p>本文基于Windows环境配置。</p>
<a id="more"></a>

<h2 id="搭建前提"><a href="#搭建前提" class="headerlink" title="搭建前提"></a>搭建前提</h2><ul>
<li>安装好Node.js、npm</li>
<li>保证主机上有Git并同自己的GitHub账号通过SSH建立联系</li>
<li>简单了解GitHub和Git</li>
</ul>
<h2 id="关于GitHub的部署"><a href="#关于GitHub的部署" class="headerlink" title="关于GitHub的部署"></a>关于GitHub的部署</h2><ul>
<li><p>在GitHub上新建一个仓库，其命名保证为以下要求</p>
<p><img src="/images/image-20201224100650328.png" alt="image-20201224100650328"></p>
<p><code>username</code>要求为自己GitHub上面的账户名</p>
</li>
</ul>
<ul>
<li><p>进入自己新建的仓库，在setting中向下拖，找到GitHub Pages，选择主分支保存</p>
<p><img src="/images/image-20201224101348108.png" alt="image-20201224101348108"></p>
<p>成功时，一般上方会显示<code>Your site is published at https://username.github.io/</code></p>
</li>
</ul>
<p>  到此GitHub的配置完成，已经可以通过<a href="https://username.github.io访问你的github/">https://username.github.io访问你的GitHub</a> Pages界面，需要利用一些工具优化你的博客部署，这里我们采用Hexo进行优化。</p>
<h2 id="关于Hexo的部署"><a href="#关于Hexo的部署" class="headerlink" title="关于Hexo的部署"></a>关于Hexo的部署</h2><ul>
<li><p>利用<code>npm install -g hexo-cli</code>指令<strong>安装Hexo</strong>，可在Git、cmd上进行，推荐使用Git</p>
</li>
<li><p>安装后在电脑选择一个文件夹作为今后放置自己文章的地方，打开Git命令行<code>hexo init </code>命令用于<strong>初始化本地文件夹为网站的根目录</strong></p>
<p>这里简单了解下这些目录作用：</p>
<p>Source文件夹用来存放文章、图片草稿</p>
<p>scaffolds文件夹可以针对文章进行一些全局部署</p>
<p>themes文件夹存放主题</p>
<p>_config.yml文件对博客进行全局配置</p>
</li>
<li><p><strong>博客主题</strong></p>
<p>此步可以略过，博客即是默认主题</p>
<ul>
<li><p>首先可以在<a href="https://hexo.io/themes/">这个地址</a>选择自己喜欢的主题，并进入GitHub发现该主题项目</p>
</li>
<li><p>前面说到themes文件夹存放主题，所以在该文件夹中打开Git将该项目复制下来</p>
<p><img src="/images/image-20201224105030661.png" alt="image-20201224105030661"></p>
</li>
<li><p>最后在前面说到的_config.yml文件对博客主题进行修改，找到theme选项，修改主题名为下载主题的文件夹名，注意空格</p>
<p><img src="/images/image-20201224105351858.png" alt="image-20201224105351858"></p>
</li>
</ul>
</li>
<li><p><strong>本地测试</strong></p>
<ul>
<li>在根目录下，利用<code>hexo g</code>生成静态文件</li>
<li>再利用<code>hexo s</code>可以启动本地服务器，即可在<a href="http://localhost:4000/">http://localhost:4000</a> 上查看自己的博客情况</li>
</ul>
<p>这里的两部操作对应就是保存修改生成静态文件、在本地查看修改看是否满意，一般用来测试用。</p>
</li>
<li><p><strong>上传博客</strong></p>
<ul>
<li><p>上传博客需要利用<code>hexo-deployer-git</code>,所以第一次操作时需要利用<code>npm install hexo-deployer-git --save</code>指令进行安装</p>
<p>生成.deploy_git文件夹</p>
</li>
<li><p>安装后修改前面说到的_config.yml文件，建立与GitHub Pages的联系，这一步也是第一次操作需要修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:zhu-ym&#x2F;zhu-ym.github.io.git</span><br><span class="line">branch: main</span><br></pre></td></tr></table></figure>
<p>这里注意空格，以及 repository后面地址就是对应上面GItHub部署的SSH key（克隆时用的SSH地址），分支那里之前见人写master,但是考虑到GitHub2020年的修改，我改为了main，没有影响，可以成功。</p>
</li>
<li><p>最后即是将文件部署到GitHub上，执行<code>hexo g -d</code>即可</p>
<p>一般Git末尾出现如下图类似情况即成功</p>
<p><img src="/images/image-20201224111652154.png" alt="image-20201224111652154"></p>
<p>这步实质是生成静态文件，并将.deploy_git文件夹的内容上传到main（master）分支上去</p>
</li>
</ul>
<p>最后，以后写文章，主要就是执行<code>hexo g -d</code>上传</p>
</li>
</ul>
]]></content>
      <categories>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>Hexo</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>进程与线程</title>
    <url>/2020/12/27/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>本文主要描述操作系统层面的进程和线程区别，再介绍进程的通信、同步，最后讲解一些常见的调度算法</p>
<a id="more"></a>

<p>[TOC]</p>
<h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程是执行的程序，程序是静态的，进程是动态的。进程是资源调度的基本单位，便于资源的管理和维护，多个进程共享物理内存、磁盘、打印机等资源。</p>
<p>操作系统的进程模型：一个进程是一个正在执行程序的实例，概念上每个进程都有自己的虚拟CPU，实际是真正的CPU在不同进程间快速切换（多道程序设计），体现出一段时间多个进程在运行，而每个时间点仅有一个程序是活跃的。</p>
<p>进程的实现靠操作系统维护的一张进程表，每个进程占用一个进程表项（也称进程控制块），表项包含了进程状态的重要信息，如程序计数器、堆栈指针、内存分配状况、文件状态，以及进程切换时必须保存的信息。当一个运行的进程收到中断时，硬件将程序计数器、程序状态字等信息压入堆栈，并跳转到内存底部固定区域的中断服务程序入口地址；之后大概用汇编语言保存寄存器值（通常保存在进程表项中），设置新的堆栈，这部分是通用的；然后一般用C语言处理特定中断剩类型下工作，使某些进程就绪；最后用调度程序选择新的进程运行。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>进程模型是基于资源分组处理与执行的，传统操作系统中进程有一个地址空间和一个控制线程，将资源和执行结合，后来将这个两个概念分离，有了线程概念，线程是进程的执行，是独立调度的基本单位，一个进程可以执行多个线程，多个线程之间共享同一个地址空间和其他资源。</p>
<p>线程的实现有两种方式：</p>
<ul>
<li><p>在用户空间实现：类似于操作系统维护进程表，在用户空间中维护一张线程表，而内核对其一无所知</p>
<ul>
<li>优点：<ul>
<li>不用陷入内核，切换快，调用效率高</li>
<li>适用性高，可以在不支持线程的操作系统是实现</li>
<li>可以自己设计线程调度算法</li>
<li>扩展性高</li>
</ul>
</li>
<li>缺点：<ul>
<li>由于内核对其不可见，很难实现一个线程进行系统调用阻塞时，不影响其他线程执行，可以采用包装器查看调用是否安全，再决定是否调用，但会损失性能，或者需要一些新的非阻塞的系统调用</li>
<li>在一个单独的进程内部，没有时钟中断，所以不能用轮转调度的方式调度线程。如果一个线程开始运行，那么在该进程中的其他线程就不能运行，除非第一个线程自动放弃<em>CPU</em>。</li>
</ul>
</li>
</ul>
</li>
<li><p>在内核实现：在内核中维护线程表，创建和撤销线程都是系统调用，所有能阻塞线程的调用都以系统调用的形式实现，开销大，但当阻塞时，可由内核选择运行一个进程中另一个线程或另一个线程中的线程</p>
<p>缺点:系统调用导致开销大</p>
</li>
</ul>
<p>Java主流的线程是采用于操作系统原生线程模型来实现，大多是内核线程模型。</p>
<p>引入线程，线程必定有比进程优越的地方，这是优点，也是区别，主要在于以下几点：</p>
<ul>
<li>并行实体共享同一片地址可用空间和所有可用数据的能力，Java线程共享进程的堆和方法区，也有自己独立的栈、程序计数器。</li>
<li>线程切换时只需保存和设置少量寄存器内容，开销很小，创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。所以进程也叫轻量级进程。</li>
<li>多线程时，特别是存在大量计算和I/O处理，可以加快应用程序执行速度，类似于进程多道程序设计模型</li>
<li>多CPU系统中，多线程有益，真正的并行的实现存在可能</li>
<li>线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。</li>
</ul>
<h1 id="2-状态转换"><a href="#2-状态转换" class="headerlink" title="2.状态转换"></a>2.状态转换</h1><p><strong>进程间状态转换</strong></p>
<p><img src="/images/image-20201227181835618.png" alt="image-20201227181835618"></p>
<p>阻塞态和就绪态的区别主要在于阻塞态缺少资源，就绪态缺少时间片</p>
<p><strong>线程间状态转换</strong></p>
<p><img src="/images/image-20201227182116299.png" alt="image-20201227182116299"></p>
<h1 id="3-进程间通信（IPC）"><a href="#3-进程间通信（IPC）" class="headerlink" title="3.进程间通信（IPC）"></a>3.进程间通信（IPC）</h1><p>进程间通信其实有三个问题，一是一个进程把信息传递给另一个，即真正的通信问题；而是保证进程的关键活动不会交叉，即互斥问题；三是保证进程正确的执行顺序问题，即同步。</p>
<p>首先介绍两个概念</p>
<p><strong>竞争条件：</strong>多个进程访问共享资源，最终结果对进程运行顺序敏感</p>
<p><strong>临界区：</strong>对共享资源访问的代码片段</p>
<h2 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h2><p>保证一个进程在使用共享资源而其他进程不能进行相同的操作，即互斥。</p>
<p>互斥的实现主要有：</p>
<ul>
<li>单处理器屏蔽中断。对用户进程不可取，并且多核时也受影响</li>
<li>锁变量：用一共享变量作为锁变量锁住临界区，进入时需测试。无法解决同时进入问题</li>
<li>严格轮换法：在锁变量的基础上加入，连续测试，即自旋的思想。浪费CPU时间，仅在等待时间短时使用，并且会受到非临界区阻塞的问题，无法保证同步</li>
<li>当一个进程进入临界区时，先检查是否允许进入，若不允许，该进程原地等待：比如Peterson解法，或者是基于硬件支持的TSL指令（测试并加锁，通过锁住总线实现）实现</li>
</ul>
<h2 id="进程间同步"><a href="#进程间同步" class="headerlink" title="进程间同步"></a>进程间同步</h2><p><strong>同步是更为复杂的互斥</strong>，上诉互斥的最后一个解法可以实现同步，但是具有忙等待的特点，浪费CPU时间，甚至可能出现优先级反转问题</p>
<p>进程间同步的实现，主要是在于进入临界区被阻塞时，不是忙等待，而是挂起，等待唤醒，主要有：</p>
<ul>
<li><p><strong>信号量</strong>：信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。</p>
<ul>
<li><strong>down</strong> : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；</li>
<li><strong>up</strong> ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。</li>
</ul>
<p>down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断，如果使用多个CPU，则每个信号量应该由一个锁变量保护，通过使用TSL或XCHG指令保证同一时刻只有一个CPU对信号量进行操作</p>
<p>当信号量初值设置为1，如果每个进程进入临界区前都执行一个down操作，退出时执行一个up操作，就可以实现互斥，这称为<strong>二元信号量</strong>。</p>
</li>
</ul>
<ul>
<li><strong>互斥量:**如果信号量的取值只表示两个状态，0（解锁） 或者其他值（加锁），那么就成为了 **互斥量（Mutex）</strong> ，其在获取锁失败时，会放弃CPU，等待下次测试。</li>
</ul>
<ul>
<li><p><strong>管程：</strong>一个管程是一个由过程、变量以及数据结构等组成的一个集合。</p>
<p>一个时刻只能有一个进程使用管程，通过二元信号量或者互斥量实现。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。所以管程引入了 <strong>条件变量</strong> 以及相关的操作：<strong>wait()</strong> 和 <strong>signal()</strong> 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。Java的synchronized、ReentrantLock就支持管程。</p>
<p>管理可以使互斥量、信号量设计控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。</p>
</li>
</ul>
<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><p>进程同步与进程通信很容易混淆，它们的区别在于：</p>
<ul>
<li>进程同步：控制多个进程按一定顺序执行；</li>
<li>进程通信：进程间传输信息。</li>
</ul>
<p>进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。</p>
<p>进程间通信主要有以下几种方式：</p>
<ul>
<li><strong>管道（pipe）</strong>：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</li>
<li><strong>命名管道（FIFO）</strong>：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信，其命名对应于一个磁盘索引节点，有了这个文件名，任何进程有相应的权限都可以对它进行访问。。</li>
<li><strong>消息队列（MessageQueue）</strong>：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li>
<li><strong>共享存储（SharedMemory）</strong>：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。</li>
<li><strong>信号量（Semaphore）</strong>：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li>
<li><strong>套接字（Socket）</strong>：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。</li>
<li><strong>信号 ( sinal )</strong> ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</li>
</ul>
<h1 id="4-进程调度"><a href="#4-进程调度" class="headerlink" title="4.进程调度"></a>4.进程调度</h1><p>当多个进程或线程竞争CPU时，就要用到调度程序，执行调度算法，选择下一个运行的程序。</p>
<p>首先，关于调度时机，一般出现在新建进程、一个进程退出、一个进程阻塞或者是I/O中断发生时，要进行调度选择。</p>
<p>其次关于调度目标，一般需要讲究公平，给相似的进程相似的CPU份额；也要保住平衡，保持系统的所有部分都忙碌；同时还要保证规则策略强制执行。具体到一些应用场景，还要具体的要求，比如批处理环境要求CPU利用率、周转时间、吞吐量，交互式系统要求最小响应时间快速响应请求，以及均衡性满足用户的期望。</p>
<p>最后，就得讨论具体的调度算法，我们针对不同应用场景有不同的调度方式。</p>
<h2 id="批处理系统调度"><a href="#批处理系统调度" class="headerlink" title="批处理系统调度"></a>批处理系统调度</h2><p><strong>先来先服务：</strong>first-come first-served,维护一就绪进程的单一队列，先到先服务</p>
<p><strong>最短作业优先：</strong>shortest job first，如果进程运行时间可以预知，就选择估计运行时间最短的顺序进行调度。但长作业可能出现饥饿问题</p>
<p>上诉两种算法都是<strong>非抢占式调度</strong>，选择一个算法进行到阻塞或者释放CPU</p>
<p><strong>最短剩余时间优先：</strong>最短作业优先的抢占式版本，<strong>抢占式调度</strong>需要有时间中断，会有运行时段最大值，时段结束也会被挂起。该版本每次都选择剩余运行时间最短的进程运行。</p>
<h2 id="交互式系统调度"><a href="#交互式系统调度" class="headerlink" title="交互式系统调度"></a>交互式系统调度</h2><p><strong>轮转调度：</strong>维护一个可运行进程列表，每个进程被分配一个时间片，时间片用完后移到队尾。进程切换需要花费一定时间，所以时间片太小，CPU效率低，算法效率低；时间片太长响应时间就会变长</p>
<p><strong>优先级调度：</strong>对于I/0密集型，优先级高，可以先分配CPU，以便启动下一个I/O请求，如此可以区分不同进程优先级分为不同类，不同类之间进程采用优先级调度，同类内部轮转调度。一般运行完时间片后可以降低当前线程优先级</p>
<p><strong>多级反馈队列：</strong>按照优先级调度，一般优先级低的是CPU密集型进程，给他们设置较长的时间片比频繁短时间片更高效。多级队列对不同优先级给不同时间片，则高优先级少，低优先级时间片多。一个进程用完时间片后，分配到下一类。</p>
<p><strong>彩票调度：</strong>向进程提供各种系统资源（如CPU时间）的彩票，一旦需要做出一项调度决策时，随机抽出一张彩票，拥有这张彩票的进程获得调度。可以实现大致按正确比例划分CPU的使用</p>
<h2 id="线程的调度"><a href="#线程的调度" class="headerlink" title="线程的调度"></a>线程的调度</h2><p>线程的调度和线程的实现有很大关系</p>
<p>对于用户级线程，内核不知，进程可以在内核分配时间片内用自己的调度算法选择线程调度，一般是轮转调度或者优先级调度，就是缺乏时钟中断运行过长的线程，可以通过线程间通信解决。</p>
<p>对于内核级线程，内核选择一特定的线程运行一定时间片，此时注意考虑同进程线程切换比不同进程切换代价小即可</p>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>现代操作系统</category>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>进程</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>内存管理</title>
    <url>/2020/12/29/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>​        本文简单介绍操作系统内存管理的发展，最后再重点讲解如今使用得最多的虚拟内存技术及其实现。</p>
<a id="more"></a>

<p>[TOC]</p>
<h1 id="内存管理发展"><a href="#内存管理发展" class="headerlink" title="内存管理发展"></a>内存管理发展</h1><p>存储器不可能无限大、快速、永久又价格低廉，综合考虑后，人们提出<strong>分层存储器体系：</strong></p>
<ul>
<li>快速、昂贵、容易失性的高速缓存（cache）</li>
<li>速度价格适中、也易失性的内存</li>
<li>低速廉价、非易失性的磁盘存储</li>
</ul>
<p>而操作系统则通过存储管理器管理分层存储器体系</p>
<p>这里主要讲解分层存储器体系中<strong>内层管理</strong></p>
<h2 id="无存储器抽象"><a href="#无存储器抽象" class="headerlink" title="无存储器抽象"></a>无存储器抽象</h2><p>最早的存储器没有抽象，即意味着每一个程序直接访问物理内存</p>
<p>再此情况下，很难在内存中同时运行两个程序，我们的进程模型很难在这样的内存上实现，除非使用交换技术或者依靠硬件。</p>
<p>总之，进程直接访问内存可能带来以下问题：</p>
<ul>
<li>破坏操作系统</li>
<li>难以实现程序并发</li>
</ul>
<h2 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h2><p><strong>地址空间</strong>是对存储器的抽象，其为进程创造了一抽象的内存。地址空间是一个进程可<strong>以用于寻址内存</strong>的一套地址集合，每个进程都有自己独立的地址空间。</p>
<p>地址空间的关键在于给每个进程自己独立的地址空间，并使其物理内存和其他物理内存地址不一致。</p>
<p>显然，这个问题最简单可以通过简单映射解决，如<strong>动态重定位：</strong>简单将每个进程的的地址空间映射到物理内存不同部分。该方法结合基址寄存器和界限寄存器可以很好的工作：基址寄存器记录进程起始物理地址，界限寄存器记录进程长度，每次进程访问内存，CPU硬件将地址发到内存总线前，自动把基址值加到进程发出的地址上，在检查其是否超过界限寄存器的界限值，如果超过，产生错误并中止访问。</p>
<p>上诉方案有一个问题，内存不够大，不断为进程分配地址，如果内存空间满了怎么办？内存很难保存所有进程。</p>
<p>内存超载有两个解决方案，较简单的<strong>交换技术</strong>和更常用的<strong>虚拟内存</strong></p>
<p><strong>交换技术</strong>大致思想是把一个进程调入内存，运行一段时间后再把它存回磁盘</p>
<p>交换技术其内存是<strong>快式管理</strong>，一个进程分配一块地址，那当新分配一个进程的地址时，就和Java虚拟机中的内存分配有一些共同之处：都可以用空闲链表来选择不同算法进行动态内存分配（首次适配、下次适配、最佳适配、最差适配、快速适配），所以自然也都存在空间碎片问题</p>
<p>除了使用记录已分配内存段和空闲内存段的链表进行内存分配和管理，还可以通过划分内存为一定大小的分配单元，再用位图进行管理。下图是现代操作系统上位图和链表的大致结构</p>
<p><img src="/images/image-20201229104028181.png" alt="image-20201229104028181"></p>
<p>位图的缺点是查找指定的大小0块比较费时，链表主要是会产生空间碎片，需要进行合并操作</p>
<p><strong>虚拟内存</strong>技术对地址空间再进行细化、采用了不同于块式管理的方案，很适合在多道程序设计系统中使用。下面详细介绍。</p>
<h1 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h1><p>虚拟内存对地址空间再进行细化，分成多个块，每一块称为一<strong>页</strong>或者<strong>页面</strong>，每页有连续的地址范围，映射到物理内存（物理内存不要求连续）。最重要的是，进程的运行不需要所有页都在内存中，当程序引用到不在物理内存中的页时，会将缺失的部分装入物理内存并重新执行失败的指令。</p>
<h2 id="分页技术"><a href="#分页技术" class="headerlink" title="分页技术"></a>分页技术</h2><p>大多虚拟内存采用分页的技术</p>
<p>进程产生的地址称为<strong>虚拟地址</strong>，它们构成<strong>虚拟地址空间</strong>，虚拟地址空间按固定大小划分成<strong>页面</strong>，页面对应物理内存中的单元称为<strong>页框</strong></p>
<p>最简单的虚拟地址一般由：<strong>虚拟页号</strong>+<strong>偏移量</strong>组成</p>
<p>在内存中一般有一个<strong>页表</strong>，其内部有很多页表项，典型页表项结果如下：</p>
<p><img src="/images/image-20201229113257172.png" alt="image-20201229113257172"></p>
<p>现在可以具体描述采用分页技术的内存访问流程了</p>
<p>在没有虚拟内存的计算机上，系统直接把虚拟地址送到内存总线，而这里将其送到<strong>内存管理单元（MMU）</strong>。之后MMU再访问内存中的<strong>页表</strong>，根据虚拟地址的虚拟页号，找到页表中的页表项，得到页框号，最后将页框号替代虚拟地址中的虚拟页号，得到内存物理地址，再访问内存。注意以上操作要访问<strong>两次内存</strong>。</p>
<p>如果内存中不存在该页面就会产生<strong>缺页中断</strong>，CPU陷入操作系统，操作系统找到很少使用的页框写入磁盘（看是否修改），随后把需要的页框读入，修改映射关系，然后重新启动引起中断的指令。</p>
<p>了解分页技术的基本机制后我们要对其优化</p>
<ul>
<li>第一访问内存物理地址需要访问两次内存，我们要加快虚拟地址到物理地址的映射</li>
<li>第二如果虚拟地址空间很大，我们需要很大的页表</li>
</ul>
<p><strong>块表</strong></p>
<p>针对第一个问题，如果选择将内存中页表副本载入寄存器，如果页表大，代价就大，并且不同进程上下文切换装载整个页表也会降低性能。</p>
<p>基于以下假设：”大多数程序对少量页面进行多次访问“，我们通常在MMU中设置一小型硬件设备<strong>转换检测缓冲区</strong>（TLB），也叫<strong>快表</strong>，通过保存少量类似于页表项的表项，这些表项一般是常用的。</p>
<p>当将虚拟地址放入MUU进行转化时，先判断TLB中是否存在该虚拟页面，存在不需要访问页表直接转化访问对应物理地址。若不存在，则进行正常的页表查询，并从TLB中淘汰一个表项，复杂到内存的页表项中。</p>
<p>当然TLB也可以用软件进行管理，将TLB表项由操作系统显式装载，当TLB访问失效时，不再由MMU到页表查询，而生成TLB失效将问题给操作系统解决。</p>
<p>有了快表，有时只要访问一次高速缓冲存储器，一次内存，这样可加速查找并提高指令执行速度。</p>
<p><strong>多级页表</strong></p>
<p>多级页表用来解决巨大的虚拟地址空间问题。</p>
<p>现代计算机使用至少32位的虚拟地址，页面大小固定，表项就会多，页表就会很大。当进程的虚拟空间大，但是实际使用内存不是那么多时，使用多级页表可以节约内存。</p>
<p>以二级页表为例，将页表划分为顶级页面和二级页表，顶级页面包含二级页表的地址和，二级页表就同之前介绍的页表类似，将进程产生的虚拟地址解释为：PT1+PT2+偏移量。</p>
<p>此时MMU先根据PT1的索引找到二级页表的地址，再和上述过程一样通过PT2和二级页面定位具体地址。这导致二级页表可以不用连续存储了，很容易分配空间，其次，当进程使用很大的虚拟地址空间，但实际并没有用完这片虚拟地址空间时，只会产生需要的页表，空闲区直接在顶级页表中标记为不在，当访问时强制产生缺页中断，交于操作系统处理，比如杀死进程。</p>
<p>由于计算机组成原理里面无处不在的局部性原理：我们可以知道，第一，某些二级页表可以不存在；第二，二级页表可以不在主存，这样就可以节约内存</p>
<p>最后总结多级页表特点</p>
<ul>
<li>二级页表分配可以离散，偏于分配</li>
<li>节约内存</li>
<li>比一级页表多了一次访问</li>
</ul>
<h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><p>前面说到发生缺页中断时，操作系统必须在内存选择一个页框换出，在方便调入需要的页框。</p>
<p>如果选择频繁使用的页框换出内存，又短时间内被调入，显然会增加开销，这时针对页面的选择有不同的调度算法</p>
<p><strong>1.最优页面置换算法（OPT）</strong></p>
<p>每次选择之后最晚被使用的页面换出，可以保证获得最低的缺页率，但很难实现，因为系统不知道各个页面下次什么时候被访问，只是作为一个衡量其他算法的指标</p>
<p><strong>2.最近未使用算法（NRU）</strong></p>
<p>利用前面说到的页表项<strong>访问位</strong>R和<strong>修改位</strong>M的数据</p>
<p>R位利用时钟中断定期清零</p>
<p>最后分成四种情况，按1）未访问、未修改；2）未访问、已修改；3）已访问、未修改；4）已访问、已修改 依次分级，越在前越容易被置换</p>
<p><strong>3.FIFO页面置换算法</strong></p>
<p>选择换出的页面是最先进入的页面。该算法会将那些经常被访问的页面换出，导致缺页率升高</p>
<p>用一队列维护</p>
<p><strong>4.第二次机会页面置换算法</strong></p>
<p>对FIFO的优化，对于FIFO将要换出的算法、如果R位位1，置0放队尾，为0就换出</p>
<p><strong>5.时钟页面置换算法</strong></p>
<p>对第二次机会算法的优化，采用循环链表，不用移动链表，而是直接移动指向页面的指针</p>
<p><strong>6.最近最少为未使用页面置换算法（LRU）</strong></p>
<p>为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。</p>
<p>因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。</p>
<p>此外可以通过硬件实现，要求有一64位计数器C，每条指令后C+1，在表项中保存该计数器值的域，选择最小换出</p>
<p>LRU非常接近OPT</p>
<p><strong>7.最不常用算法（NFU）</strong></p>
<p>用一个软件计数器与页面管联，每次时钟中断时将页面R位加到其计数器上，发生缺页中断时，置换计数器值最小的算法</p>
<p>希望用NFU接近LRU，但是明显页面在几个时钟前和最近一个时钟被访问都是相同的权重，无法区别</p>
<p><strong>8.老化算法</strong></p>
<p>对NFU优化，每次加R时先将计数器右移一位，在将R放在左端，即加大最近被访问页面的权重。</p>
<p>非常接近LRU算法，只是无法区别同一个时钟内页面的先后</p>
<p><strong>9.工作集页面置换算法</strong></p>
<p>我们称一个进程当前正在使用的页面集合称为它的<strong>工作集</strong>，当整个工作集被装入内存，缺页中断少，反正多，不少分页系统会跟踪进程的工作集，确保程序运行以前，预先装入工作集，减少中断。</p>
<p>该算法当发生缺页中断时，淘汰一个不在工作集中的页面。</p>
<p>难点是确定工作集：工作集可以是最近k次内存访问用过的页面集合，也可以是最近一段时间t使用的集合,用后者工作集便于计算。我们采用后者，后者便于实现</p>
<p>此时表项中有上次近似使用时间和访问位至少两个信息，当发生缺页中断，遍历表项，如果R位为1，将当前时间写入上次近似使用时间，如果R为0，生成时间小于t则认为该页面不再工作集中，用新的页面置换他，并更新剩余表项</p>
<p>如果出现特殊情况，生存时间均小于t，生存时间最长的页面淘汰</p>
<p>该算法要扫描整个页表</p>
<p><strong>10.工作集时钟页面置换算法</strong></p>
<p>结合了时钟算法和工作集，在工作集算法上添加了M位</p>
<p>每次缺页中断时，首先检查指针指向的页面。如果R位被置为1，该页面在当前时钟滴答中就被使用过，那么该页面就不适合被淘汰。然后把该页面的R位置为0，指针指向下一个页面，并重复该算法</p>
<p>在若R=0时，如果页面的生存时间大于t：如果该页面是干净的，直接置换。如果此页面被修改过，为了避免由于调度写磁盘操作引起的进程切换（但是可以当积累一定多页面写入后执行写操作），指针继续向前走，算法继续对下一个页面进行操作，希望找到旧的且干净的页面可以立即使用。</p>
<p>如果指针经过一圈返回它的起始点并且没有写操作，说明都在工作集，随便置换一个干净页面，不存在就当前页面；如果有写操作，继续之前算法。</p>
<p>总结：<strong>LRU</strong>很优秀，但是需要特殊硬件实现才能保证性能，这时可以采用<strong>老化算法</strong>用软件模拟LRU；基于工作集的算法，<strong>工作集时钟算法</strong>更优、更高效，实际运用中，可能老化算法和工作集时钟算法最重要、更优秀。</p>
<h2 id="分段技术"><a href="#分段技术" class="headerlink" title="分段技术"></a>分段技术</h2><p>从前面，我们了解每个进程都有自己的一个独立地址空间和控制线程，这片地址空间在虚拟内存中分成一个虚拟地址空间，一般这个虚拟地址空间用分页技术管理，只要通过虚拟地址的一个索引（多级页表可能多次）+偏移的手段就可以寻到物理地址。</p>
<p>如果程序都在这个独立的地址空间上工作，考虑到程序会生成一些可以动态扩张的块，这些块是动态扩张时，就可能出现分配给某个块的地址被装满、尽管其他块还有大量的空间。这可能让程序员管理这些块的扩张或者收缩很麻烦，所以提出了段的概念。</p>
<p>**段:**对进程的独立空间划分为多个段，更细化的认为每个段构成一段独立的地址空间，其可以独立的增长和缩小而不会影响其他的段。段不是定长的，也可以被铺满，但通常有比较大的上界。段是一个逻辑实体，并且应该为程序员所知，一个段可能包括一个过程、一个数组、一个堆栈但一般不包含多种不同类型的内容，程序员可以设置某个段为只读或者只执行等待对其进行保护。</p>
<p>在分页技术下，进程的整个地址空间就是一个线性地址空间，提出分段后，整个地址空间可能存在多个线性地址空间，所以程序员必须通过段号等手段找到其线性地址空间的位置，再通过段内地址找到实际的物理地址，认为其是二维的。</p>
<p>这里比较一下分页分段</p>
<ul>
<li>对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段。</li>
<li>地址空间的维度：分页是一维地址空间，分段是二维的。</li>
<li>大小是否可以改变：页的大小不可变，段的大小可以动态改变。</li>
<li>目的不同：分页主要用于实现虚拟内存，从而获得更大的地址空间而不必购买物理存储器；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护</li>
</ul>
<p><strong>段页式管理机制</strong>：段页式管理机制结合了段式管理和页式管理的优点。程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页，其段与段之间以及段的内部的都是离散的。</p>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>现代操作系统</category>
      </categories>
      <tags>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>文件系统</title>
    <url>/2020/12/31/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>本文简单介绍一下文件系统的作用，用户眼中的文件系统，最后再介绍一些关键部分的实现</p>
<a id="more"></a>

<p><strong>文件</strong>是进程创建的信息逻辑单元，是对磁盘的抽象，可以理解为每一个文件就是一个地址空间，而操作系统处理文件的部分就称为<strong>文件系统。</strong></p>
<p>[TOC]</p>
<h1 id="文件系统表现形式"><a href="#文件系统表现形式" class="headerlink" title="文件系统表现形式"></a>文件系统表现形式</h1><p>文件系统表现形式是用户所关心的，在用户眼中主要是文件和目录。</p>
<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p>用户需要对文件进行命名、修改等操作。</p>
<p>一般<strong>文件命名</strong>采用<code>文件名+.扩展名</code>的格式。扩展名可以是一种约定，表明文件的一些信息；windows的进程可以在操作系统中注册扩展名，于是双击文件的时候，拥有该扩展名的进程就会启动并运行该文件。</p>
<p>文件可以有多种<strong>构造（组成）方式</strong>，最常见的是无结构的<strong>字节序列</strong>，其灵活性高，可以添加任何内容，用在多种操作系统；还有一种是一颗<strong>记录树</strong>，每个记录长度不一，但固定位置上有一<strong>键</strong>字段，这颗树按键排序，构成文件，这样的文件易于查找键，用于处理数据的大型计算机。</p>
<p>文件有不同类型，常见的是<strong>普通文件</strong>和<strong>目录</strong>。前者是包含用户信息的文件，可在分为<strong>ASCII文件</strong>和<strong>二进制文件</strong>。后者是管理文件系统结构的系统文件。</p>
<p>当访问文件内容时，可以<strong>顺序访问</strong>，从头按顺序读取文件全部字节或记录；也可以<strong>随机访问文件</strong>，以任意次序读取。一般后者为很多应用程序需要，可以通过给出开始读文件的位置或者设置当前位置实现从某处开始读取文件</p>
<p>最后介绍一下<strong>文件属性</strong>，其是指文件相关的信息，比如保护、口令、创建者、所有者、创建日期、标志位、文件大小、修改时间等，这也称为<strong>元数据</strong></p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>目录用来记录文件的位置，前面文件类型中也提到目录，很多系统中目录本身也是文件。</p>
<p>从宏观层次上来说，目录系统有一个目录包含所有文件的<strong>根目录、一级目录系统</strong>，但只用于简单的特殊应，。也有<strong>层次结构</strong>即一颗目录树的形式，现在，几乎所有操作系统都是这样组织的。</p>
<p>当使用目录树组织文件系统时，需要有路径名的概念。路径名分为<strong>绝对路径名</strong>和<strong>相对路径名</strong>，前者常用于本地文件管理，后者更方便，而且是以工作目录为基准的。在我们上次GitHub项目要显示图片、或者是Hexo搭建博客解决图片显示问题时，就很可能用到相对路径。</p>
<p>对于路径需要使用到<strong>分隔符</strong>分割不同子目录，在windows中是“\”,在Linux中是”/“,如果路径名的第一个字符是分隔符，其为绝对路径。最后有两个特殊目录项<code>.</code>和<code>..</code>,前者表示当前目录，后者表示父目录。我在设置Hexo和Typora图片保存路径时，就用到了<code>typora-root-url: ../</code>这样一条途径，表明图片应该在上一级目录里面查找。</p>
<h1 id="文件系统实现"><a href="#文件系统实现" class="headerlink" title="文件系统实现"></a>文件系统实现</h1><p>文件系统存放在磁盘上，如果磁盘分区，那每个分区都有一个独立的文件系统。分区后0号扇区称为<strong>主引导记录（MBR）</strong>，用来引导计算机，之后就是分区表，记录每个分区的起止位置。一般计算机被引导时，从BIOs读入执行MBR，确定一个活动分区，读入其第一个块<strong>引导块</strong>装载该分区中的操作系统。</p>
<p>文件系统实现的关键在于文件和目录的实现，即文件和目录是怎么存储的。</p>
<h2 id="文件实现"><a href="#文件实现" class="headerlink" title="文件实现"></a>文件实现</h2><p>文件存储实现的关键是记录各个文件用到哪些磁盘块，下面是一些常用方法：</p>
<ul>
<li><p><strong>连续分配：</strong>每个文件作为一连串的数据块存储在磁盘上。其具有实现简单和读性能良好的特点，每个文件，目录项记录第一块磁盘地址和长度即可。对于缺点，不用说联想到先前的内存最早的分块管理，当删除一些文件后其肯定有<strong>空洞</strong>(零碎的空闲块)，如果维护一个空洞链表，那么分配文件位置时，必须知道文件最终大小。综上，其主要应用于提前知道文件大小的文件系统中，比如CD-ROM、DVD、蓝光光盘。</p>
</li>
<li><p><strong>链表分配：</strong>构造磁盘块链表，每一个块第一个字节作为指向下一块的指针，块的其他部分存放数据。这时可以充分利用碎片，目录项中只要存放第一块的磁盘地址即可。但是链表分配自然有链表的缺点，便于顺序访问但不便于随机访问，获取文件的块k复杂，此外一般，每个块的头部指针占据一定字节，数据部分就不是2的整数次幂，但许多程序每次读2的整数次幂大小的数据，所以会从两个磁盘块拼接信息，增加了复制的额外开销</p>
</li>
<li><p><strong>利用内存中表进行内存分配：</strong>将前面链表分配的指针字，放在内存中一个<strong>文件分配表</strong>中（FAT），示意图如下</p>
<p><img src="/images/image-20201231111415581.png" alt="image-20201231111415581"></p>
<p>当有连续块时，就可存放在连续块中，当连续块不够，就指向其余空闲的块中，这时目录项就只需要记录一个起始块号的整数。这样操作用于内存中操作快，一定提高了随机访问的速度，整个块都可以存放数据。缺点就是当块很小或者磁盘很大的时候，这个文件分配表很大，不再实用。</p>
</li>
<li><p><strong>i节点：</strong>就维护一个i节点的数据结构，其保存文件属性和文件所有块的磁盘地址，但是仅在打开文件时，才将其保存在内存中。这时只要估计每个文件有多少块，最多会打开多少文件，预留一固定大小空间即可。如果超过了i节点所能容纳的块数，可以考虑i节点最后一个地址执行一个包含额外磁盘块地址的地址。</p>
</li>
</ul>
<h2 id="目录实现"><a href="#目录实现" class="headerlink" title="目录实现"></a>目录实现</h2><p>打开文件时，操作系统利用用户给出的路径名找到相应的<strong>目录项</strong>，目录项中提供了查找文件磁盘块中所需要的信息。</p>
<p>有的目录项还存储文件属性，但对采用i节点的系统，文件属性可以放在i节点中，目录项就只有文件名和i节点号。</p>
<p><strong>文件名变长问题</strong></p>
<p>由于文件名是变长的，如果固定一个最大值来固定文件名大小会浪费很大空间，毕竟不是每个文件会命长名。</p>
<p>另外一个想法是目录项大小不定，前面是长度固定的文件长度、文件属性等信息，后面接长度不定的文件名。但是显然当文件移走后，就会产生间隙，即和连续磁盘文件一样的问题，可能需要紧凑操作。此外目录项可能会分布在多个页面上，可能读取文件名时发生缺页中断。</p>
<p>此外，可以同上诉想法一样，使目录项有固定的长度，文件名放在目录后面的堆中，通过一个指针，指向该文件名，可以减少目录项中间隙问题，但还是有缺页中断。</p>
<p><strong>文件查询</strong></p>
<p>线性搜索目录速度比较慢，需要加速</p>
<ul>
<li><strong>高速缓存：</strong>将查找结果放入高速缓存中，之后查找时，查看文件名是否在高速缓存中，以此定位，对目标集中的相对较小范围的文件集合有效</li>
<li><strong>散列表：</strong>散列表+拉链法的结构，管理复杂，预计文件目录过多时考虑</li>
</ul>
<h1 id="文件系统管理"><a href="#文件系统管理" class="headerlink" title="文件系统管理"></a>文件系统管理</h1><h2 id="磁盘空间管理"><a href="#磁盘空间管理" class="headerlink" title="磁盘空间管理"></a>磁盘空间管理</h2><p>如前所述，磁盘管理文件存储有连续字节存储文件后分块存储两种策略，由于磁盘中移动操作比内存慢，所以一般是采用分块存储。</p>
<p>分块存储会带来以下问题：</p>
<ul>
<li><p><strong>块大小：</strong>随着块的增大、空间利用率会下降而性能会上升，再结合文件大多是小文件，一般取1-4KB为块；但随着磁盘的增大，或许块增大接受浪费空间也可以。</p>
</li>
<li><p><strong>空闲块管理：</strong>为了实现文件存储分配，就需要对空闲块进行管理，类似于内存的分块管理，可以采用磁盘块链表和位图管理空闲磁盘空间。</p>
<ul>
<li>位图：一位表示一块是否空闲，占用空间小，大小固定</li>
<li>磁盘块链表：链表中每个块记录尽可能多的空闲磁盘号，空间较大。如果改用链表记录连续空闲磁盘块时要看磁盘是否产生严重碎片才能发挥效果</li>
</ul>
<p>现在再来考虑其存储问题，一般就将其存储在空闲块上，一般就在内存中保持一个指针块（链表）或者就一个块（位图，由于位图固定大小，可以分页可以将其放在虚拟内存中，需要时调用）。</p>
<p>对于链表的指针块，当文件创建时所需要块从指针块取，文件删除时，添入指针块，当这个块满时，可以写入磁盘，但是有时会增加不必要的磁盘I/O（写入磁盘后空闲块少，再新建文件可能又要读入磁盘指针块）；针对上诉问题，可以拆分满了的指针块，比如保持半满。</p>
</li>
</ul>
<h2 id="文件系统备份和一致性"><a href="#文件系统备份和一致性" class="headerlink" title="文件系统备份和一致性"></a>文件系统备份和一致性</h2><p><strong>文件系统备份</strong></p>
<p>为了应对突发情况，需要对文件系统进行备份，一般有：</p>
<ul>
<li><strong>物理转储：</strong>从磁盘第0块开始，全部磁盘块按序输出到磁带上</li>
<li><strong>逻辑转储：</strong>从一个或几个指定的目录开始，递归地转储其自给定自基准日期修改后的文件和目录。</li>
</ul>
<p>前者简单快速，无法跳过指定目录，也无法增量转储，所以大多使用逻辑转储</p>
<p><strong>文件系统一致性</strong></p>
<p>如果文件系统读取磁盘块修改后，在全部写回磁盘前系统崩溃，则文件系统可能处于不一致状态。</p>
<p>这时候要保持文件系统一致性需要对<strong>块</strong>和<strong>文件（目录系统）</strong>进行一致性检测</p>
<p>前者检测块使用次数和在空闲链表或者位图的出现次数</p>
<p>对文件的一致性检测和链接有关</p>
<p>这部分的内容和<strong>数据库恢复技术</strong>有着联系，可以对照学习</p>
<h2 id="文件系统性能"><a href="#文件系统性能" class="headerlink" title="文件系统性能"></a>文件系统性能</h2><p>访问磁盘的速度比内存慢许多，文件系统对此进行优化改善性能</p>
<ul>
<li><p><strong>高速缓存：</strong>高速缓存值逻辑上属于磁盘，实际保存在内存中的一系列块，当执行读操作时，先在高速缓存中检索，如果存在就指向读操作无需访问磁盘，如果不在，读到高速缓存再复制到其他地方。高速缓存之于磁盘正如硬件之于内存（比如块表的思想）。</p>
<p>为了方便检索，常用方法会将设备和磁盘地址进行散列操作</p>
<p>注意到其有更新高速缓存的操作，这就和页面调度算法类似，有类似的算法，选择不常用的块调出。由于对高速缓存的引用不频繁，可以考虑用链表实现LRU算法</p>
<p>高速缓存还需注意一致性问题，可以将修改定时写入磁盘，或者只要是高速缓存中修改的立即写入磁盘，即<strong>通写高速缓存</strong></p>
</li>
<li><p><strong>块提前读：</strong>当顺序读取文件时，可以提前将需要块读入高速缓存提高命中率。在不确定文件访问方式时，可以通过设置顺序访问方式位，一旦进行了查找，该位置0即可</p>
</li>
<li><p><strong>减少磁盘臂运动：</strong>将可能顺序访问的块放在一起，最好是一个柱面上，减少磁盘臂的移动次数。前面在FAT实现文件分配时，当有连续块时，就可存放在连续块中，当连续块不够，就指向其余空闲的块中就体现了这点。当然用位图很容易实现，空闲表稍微困难。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>现代操作系统</category>
      </categories>
      <tags>
        <tag>文件管理</tag>
      </tags>
  </entry>
  <entry>
    <title>4.二维数组中的查找</title>
    <url>/2020/12/28/%E5%89%91%E6%8C%874-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<p><strong>剑指 Offer 04. 二维数组中的查找</strong></p>
<p><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">力扣链接</a></p>
<a id="more"></a>



<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p><strong>示例:</strong></p>
<p>现有矩阵 matrix 如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>给定 target = 5，返回 true。</p>
<p>给定 target = 20，返回 false。</p>
<p><strong>限制：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 &lt;&#x3D; n &lt;&#x3D; 1000</span><br><span class="line"></span><br><span class="line">0 &lt;&#x3D; m &lt;&#x3D; 1000</span><br></pre></td></tr></table></figure>


<h1 id="思路一：二分"><a href="#思路一：二分" class="headerlink" title="思路一：二分"></a>思路一：二分</h1><p>由于该矩阵每行每列都是有序的，可以考虑利用二分查找，假设矩阵<code>n &gt; m</code>,则选择按列查找，查找m次。</p>
<p>然后对查找m次这个过程，也可以优化，当每一列最后一个元素小于target和第一个元素大于target时，显然不用查找，但是时间复杂度还是<code>mlog(n)</code>，空间复杂度<code>O(1)</code></p>
<p>最终套用二分模板的查找某数模板，得出以下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.length;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">1</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> m = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span>(m &lt; <span class="number">1</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>; <span class="comment">// 检索排除没有必要的二分查找</span></span><br><span class="line">        <span class="keyword">if</span>(n &lt; m)&#123;</span><br><span class="line">            <span class="keyword">while</span>(begin &lt; n &amp;&amp; matrix[begin][m - <span class="number">1</span>] &lt; target)</span><br><span class="line">                begin++;</span><br><span class="line">            <span class="keyword">while</span>(begin &lt; n &amp;&amp; matrix[begin][<span class="number">0</span>] &lt;= target)&#123;</span><br><span class="line">                <span class="keyword">if</span>(findTarget(matrix,begin,<span class="number">1</span>,target))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                begin++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="keyword">while</span>(begin &lt; m &amp;&amp; matrix[n-<span class="number">1</span>][begin] &lt; target)</span><br><span class="line">                begin++;</span><br><span class="line">            <span class="keyword">while</span>(begin &lt; m &amp;&amp; matrix[<span class="number">0</span>][begin] &lt;= target)&#123;</span><br><span class="line">                <span class="keyword">if</span>(findTarget(matrix,begin,<span class="number">0</span>,target))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                begin++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findTarget</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> begin, <span class="keyword">int</span> flag, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 根据flag选择二分查找方式</span></span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high,mid;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">0</span>) <span class="comment">// 按照列二分查找</span></span><br><span class="line">        &#123;</span><br><span class="line">            high = matrix.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">                mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(matrix[mid][begin] == target)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(matrix[mid][begin] &gt; target)</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>&#123; <span class="comment">// 按照行进行二分查找</span></span><br><span class="line">            high = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">              <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">                mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(matrix[begin][mid] == target)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(matrix[begin][mid] &gt; target)</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在力扣上运行结果如下：</p>
<p><img src="/images/image-20201228103903999.png" alt="image-20201228103903999"></p>
<p>不过该代码没有实现代码复用，每个if else块的代码有很多重复工作，如果有好友也是用这个思路，实现了代码复用，更加简洁的话，还望赐教。</p>
<h1 id="思路二：二叉搜索"><a href="#思路二：二叉搜索" class="headerlink" title="思路二：二叉搜索"></a>思路二：二叉搜索</h1><p>仔细看这个排好序的二维数组，从右上角看，左边的全小于它，下面的数全大于它，有点类似于二叉搜索树，我们于是从这点出发</p>
<ul>
<li><p>如果其大于target，下面一列肯定没有target，不妨左移一位继续这样的操作</p>
</li>
<li><p>如果其小于target，左边一行肯定没有target，不妨下移一位继续这样的操作</p>
</li>
<li><p>等于target，自然有了结果</p>
</li>
</ul>
<p>此时只要记录位置，如果位置变化会超过边界，显然没有这样的值存在</p>
<p>明显每一次位置要么向下，要么向左变化，又有边界限制，时间复杂度为<code>（m+n）</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.length;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">1</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> m = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span>(m &lt; <span class="number">1</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> y = m -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>((<span class="number">0</span> &lt;= x &amp;&amp; x &lt; n) &amp;&amp; (<span class="number">0</span> &lt;= y &amp;&amp; y &lt; m))&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[x][y] == target)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(matrix[x][y] &gt; target)</span><br><span class="line">            y--;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            x++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<p><img src="/images/image-20201228111901061.png" alt="image-20201228111901061"></p>
<p>实际上观察上诉代码主体部分，也是一个类似于二分查找的过程，所以可以将其看做二叉搜索，也可以看成二分查找的优化</p>
<p>上诉两份代码耗时差不多，是因为如果m，n有一者过小，时间就是<code>log(n)</code>与<code>O(n)</code>,两者均衡时时间复杂度就是<code>nlog(n)</code>和·<code>O(n)</code>,这应该是数据集的问题，在m、n较大时，应该是后者较优秀</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对于这种矩阵的排序题目，一般思绪要放在二维上面，思路一只从一行一列上思考过于拘谨，思路二从二维角度思考有较优结果，当然还有一点，思考点不一定就是（0,0）这个点，应该从多个点思考问题。</p>
]]></content>
      <categories>
        <category>剑指Offer</category>
        <category>算法</category>
        <category>二分</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指5.替换空格</title>
    <url>/2021/01/01/%E5%89%91%E6%8C%875-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</url>
    <content><![CDATA[<p><strong>剑指 Offer 05. 替换空格</strong></p>
<p><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">力扣链接</a></p>
<a id="more"></a>

<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。</p>
<p><strong>示例 ：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;We are happy.&quot;</span><br><span class="line">输出：&quot;We%20are%20happy.&quot;</span><br></pre></td></tr></table></figure>
<p><strong>限制：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 &lt;&#x3D; s 的长度 &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure>
<h1 id="思路一：StringBuilder"><a href="#思路一：StringBuilder" class="headerlink" title="思路一：StringBuilder"></a>思路一：StringBuilder</h1><p>简单的遍历字符串s，遇到非空格直接拼接该字符，遇到空格拼接”%20”</p>
<p>然后利用Java的可变字符串StringBuilder类进行拼接处理,这里了解StringBuilder的实现是维护一个char数组，默认的长度为16，之后每次扩容为原来的2倍+2，并且涉及到字符复制的开销，这里直接将StringBuilder设置为原来的2倍，基本够用，基本就不会出现扩容问题。</p>
<p>但是明显这个方法会浪费一定的空间，个人不太清楚这种可变长字符串的空间复杂度怎么算，当做O(n)</p>
<p>综上时间复杂度O（n）,空间复杂度O（n）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();<span class="comment">// 可以直接遍历s，个人习惯</span></span><br><span class="line">        StringBuilder ans = <span class="keyword">new</span> StringBuilder(s.length()*<span class="number">2</span>);<span class="comment">//减少扩容次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c: chars)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            ans.append(<span class="string">&quot;%20&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            ans.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>空间优化</strong>：</p>
<p>可以用时间换空间，先遍历一遍s，统计空格数，那需要的数组大小即为<code>s.length()+count*2</code>,之后可以自己用该数组大小、或者指定StringBuilder的初始大小，避免空间浪费</p>
<p>上述两种方法都可以在力扣上运行时间0ms，超越100%</p>
<h1 id="思路二：replaceAll"><a href="#思路二：replaceAll" class="headerlink" title="思路二：replaceAll"></a>思路二：replaceAll</h1><p>直接利用String类的replaceAll操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.replaceAll(<span class="string">&quot; &quot;</span>,<span class="string">&quot;%20&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>结果比思路一慢</p>
<p>我们探究Java的replaceAll方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceAll</span><span class="params">(String regex, String replacement)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> Pattern.compile(regex).matcher(<span class="keyword">this</span>).replaceAll(replacement);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>其用到了正则表达式，这里就不再深究，可以看我关于正则表达式的文章</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>思路一的思想比较容易，主要是的明白方法的空间问题和底层实现</p>
<p>思路二用到了库方法，本质是正则表达式，值得注意：其第一个参数需要注意<strong>转义问题</strong>。</p>
<p>最后，个人不知道在哪里看的过，字符串处理问题一般比较难的情况需要开括三种思路：</p>
<ul>
<li><p>正则表达式</p>
</li>
<li><p>有限状态机</p>
</li>
<li><p>KMP算法</p>
<p>个人博客将会在算法的字符串专题对这些算法进行介绍，这篇文章算抛砖引玉了</p>
</li>
</ul>
]]></content>
      <categories>
        <category>剑指Offer</category>
        <category>算法</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>字符串处理</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指6.从尾到头打印链表</title>
    <url>/2021/01/01/%E5%89%91%E6%8C%876-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p><strong>剑指 Offer 06. 从尾到头打印链表</strong></p>
<p><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">力扣链接</a></p>
<a id="more"></a>

<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>
<p><strong>示例 ：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1,3,2]</span><br><span class="line">输出：[2,3,1]</span><br></pre></td></tr></table></figure>
<p><strong>限制：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 &lt;&#x3D; 链表长度 &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure>
<h1 id="思路一：递归"><a href="#思路一：递归" class="headerlink" title="思路一：递归"></a>思路一：递归</h1><p>题目要求是要用数组输出，这道题的难点就在于开始不知道数组的大小即链表的大小，可能第一遍历需要用来统计数组大小信息，第二遍出结果</p>
<p>我们可以利用递归的优点，深入时统计数组长度，然后初始化数组，弹出时将节点值写入数组</p>
<p>时间复杂度O（n），空间复杂度O（n）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] ans;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        recursion(head);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recursion</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            ans = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n++;</span><br><span class="line">        recursion(head.next);</span><br><span class="line">        ans[i++] = head.val;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然递归可以用栈来模拟，但是感觉没有必要，用栈模拟不如思路二节约空间，而且递归它优雅呀</p>
<h1 id="思路二：正常遍历"><a href="#思路二：正常遍历" class="headerlink" title="思路二：正常遍历"></a>思路二：正常遍历</h1><p>正常遍历即如前所述，第一遍统计长度，第二遍填入数组</p>
<p>时间复杂度O（n），空间复杂度O（n）,但实际需要空间比递归少</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">      <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">      ListNode temp = head;</span><br><span class="line">      <span class="keyword">while</span>(temp != <span class="keyword">null</span>)&#123;</span><br><span class="line">          temp = temp.next;</span><br><span class="line">          count++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[count--];</span><br><span class="line">      <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">          ans[count--] = head.val;</span><br><span class="line">          head = head.next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>递归简洁，而且看起来像是只遍历了一遍，但是需要额外的栈空间</p>
<p>正常遍历也是正常思路，比较容易写出</p>
<p>在这道题本身需要使用数组的情况下，使用<strong>尾插法</strong>或者<strong>辅助栈</strong>的方法没有优越性</p>
]]></content>
      <categories>
        <category>剑指Offer</category>
        <category>算法</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>链表处理</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2021/01/02/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>本文介绍正则表达式的语法，并讨论其在Java中的使用。</p>
<a id="more"></a>

<h1 id="正则语法"><a href="#正则语法" class="headerlink" title="正则语法"></a>正则语法</h1><p>正则表达式可以用来搜索、编辑或处理字符串、文本。</p>
<p>简要的说，你可以通过正则表达式定义一个字符串模式，并在另一段字符串中匹配它、替换它。</p>
<p>那问题的难点就转化成了如何用正则语法表达你想要的字符串模式，很多时候，模式不一定是一个固定的字符串，你希望他某一位是任意数字、字母，又或者你希望某几位之前可以有很多别的符号，不一定确定长度，这些可以通过了解正则表达式的语法简单实现。</p>
<h2 id="单个匹配"><a href="#单个匹配" class="headerlink" title="单个匹配"></a><strong>单个匹配</strong></h2><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">实现</th>
<th align="center">详解</th>
</tr>
</thead>
<tbody><tr>
<td align="center">数字</td>
<td align="center"><code>\d</code></td>
<td align="center"><code>\d\d</code>表示00-99的任意数字</td>
</tr>
<tr>
<td align="center">非数字</td>
<td align="center"><code>\D</code></td>
<td align="center">字面意思</td>
</tr>
<tr>
<td align="center">任意字符</td>
<td align="center"><code>.</code></td>
<td align="center">匹配任意字符、除了回车换行</td>
</tr>
<tr>
<td align="center">单词字符</td>
<td align="center"><code>\w</code></td>
<td align="center">单词字符值数字、大小字母、以及下划线</td>
</tr>
<tr>
<td align="center">非单词字符</td>
<td align="center"><code>\w</code></td>
<td align="center">与上相对</td>
</tr>
<tr>
<td align="center">大写字母</td>
<td align="center"><code>[A-Z]</code></td>
<td align="center">注意<code>[^A-Z]</code>与其逻辑相反</td>
</tr>
<tr>
<td align="center">小写字母</td>
<td align="center"><code>[a-z]</code></td>
<td align="center">可见<code>[]</code>中的东西就是匹配范围，加<code>^</code>是反逻辑</td>
</tr>
<tr>
<td align="center">空白字符</td>
<td align="center"><code>\s</code></td>
<td align="center">匹配所有的空白字符，包括空格、制表符、回车符、换页符、换行符等</td>
</tr>
<tr>
<td align="center">非空白字符</td>
<td align="center"><code>\S</code></td>
<td align="center">与上相反</td>
</tr>
</tbody></table>
<p>实际上，对于我们日常刷题，最主要的可能就是**<code>[]</code>的使用**，<code>[]</code>的使用很灵活,里面可以直接枚举、或者用范围表示，甚至可以用<code>[a-cs-z]</code>结合范围和枚举，表示 a<del>c、s</del>z 范围内的任意字符，<code>^</code>用在里面是求否，<code>&amp;&amp;</code>是求交</p>
<h2 id="边界匹配"><a href="#边界匹配" class="headerlink" title="边界匹配"></a><strong>边界匹配</strong></h2><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">实现</th>
<th align="center">详解</th>
</tr>
</thead>
<tbody><tr>
<td align="center">行开头</td>
<td align="center"><code>^</code></td>
<td align="center">限定从开头开始匹配</td>
</tr>
<tr>
<td align="center">行结尾</td>
<td align="center"><code>$</code></td>
<td align="center">限定结尾是行的末尾</td>
</tr>
<tr>
<td align="center">单词边界</td>
<td align="center"><code>\b</code></td>
<td align="center">匹配字与空格为边界</td>
</tr>
</tbody></table>
<h2 id="次数匹配"><a href="#次数匹配" class="headerlink" title="次数匹配"></a><strong>次数匹配</strong></h2><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">实现</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0次或一次</td>
<td align="center"><code>?</code></td>
</tr>
<tr>
<td align="center">一次或多次</td>
<td align="center"><code>+</code></td>
</tr>
<tr>
<td align="center">0次或多次</td>
<td align="center"><code>*</code></td>
</tr>
<tr>
<td align="center">大于等于n次</td>
<td align="center"><code>&#123;n,&#125;</code></td>
</tr>
<tr>
<td align="center">n-m次</td>
<td align="center"><code>&#123;n,m&#125;</code></td>
</tr>
<tr>
<td align="center">正好n次</td>
<td align="center"><code>&#123;n&#125;</code></td>
</tr>
</tbody></table>
<p>对于上诉次数匹配默认是贪婪匹配，匹配最长的字符串。如果在后面再加一个<code>?</code>，则是最小匹配模式，匹配最短，但实际要匹配最短，自己控制好次数即可。</p>
<h2 id="其他事项"><a href="#其他事项" class="headerlink" title="其他事项"></a>其他事项</h2><p><strong>捕获组：</strong></p>
<p>可以利用()将匹配到到的内容单独分组</p>
<p>可以通过调用 matcher 对象的 groupCount 方法来查看表达式有多少个分组。groupCount 方法返回一个 int 值，表示matcher对象当前有多个捕获组。并可以通过group(int i)方法查看具体分组，其中group（0）是整个表达式，不计在上诉统计中。</p>
<p>比如这样一个正则表达式<code> &quot;(\\D*)(\\d+)(.*)&quot;</code>能匹配成功就会捕获三个组。</p>
<p><strong>转义：</strong></p>
<p>由于[]，()，{}，^,$,?,+,*,.，\等字符有特殊含义，如果自己想要使用这些字符，需要用\进行转义。</p>
<p>即<code>\\</code>表示<code>\</code>,<code>\(\)</code>表示()</p>
<p><strong>特别注意</strong>：</p>
<p>对于Java的正则表达式，有一定需要注意，Java 源代码的字符串中的反斜线被解释为 Unicode 转义或其他字符转义。因此必须在字符串字面值中使用两个反斜线，表示正则表达式受到保护，即在Java中在 Java 中，<strong>\\</strong> 表示：我要插入一个正则表达式的反斜线，所以其后的字符具有特殊的意义。</p>
<p>所有对于上诉语法，可以简单的理解在 Java 的正则表达式中，两个 <strong>\\</strong> 代表其他语言中的一个 <strong>\</strong>，这也就是为什么表示一位数字的正则表达式是 <strong>\\d</strong>，而表示一个普通的反斜杠是 <strong>\\\\</strong>。(我在typora写这篇文章时所表现的斜杠就类似Java的转义)</p>
<p>上诉语法只是简要描述了做题需要的知识，如果需要深入还得多查看文档</p>
<h1 id="Java支持"><a href="#Java支持" class="headerlink" title="Java支持"></a>Java支持</h1><h2 id="Regex包"><a href="#Regex包" class="headerlink" title="Regex包"></a>Regex包</h2><p>Java的regex包中增加了三个类来支持正则表达式</p>
<p>其中<strong>Pattern</strong>类是用来表达和陈述所要搜索模式的对象，<strong>Matcher</strong>类是真正影响搜索的对象。另加一个新的例外类，PatternSyntaxException，当遇到不合法的搜索模式时，会抛出例外。</p>
<ul>
<li><p>Pattern 类：</p>
<p>pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。</p>
</li>
<li><p>Matcher 类：</p>
<p>Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。</p>
</li>
</ul>
<p><strong>Pattrrn类</strong></p>
<p>综上Pattern类主要使用两个方法，生成Matcher类供：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">利用Pattern.compile(regex)生成Pattern类实例，regex是一个正则表达式</span><br><span class="line">再利用Pattern实例的matcher(context)方法可以生成Matcher类实例，context是字符串</span><br></pre></td></tr></table></figure>
<p>其他方法:</p>
<table>
<thead>
<tr>
<th align="center">操作</th>
<th align="center">函数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">分割字符串，返回String[]</td>
<td align="center"><code>split(String str)</code>,按照生成Pattern的模式分割str</td>
</tr>
<tr>
<td align="center">看匹配是否成功</td>
<td align="center"><code>matcher(String regex,CharSequence input)</code>(静态方法)</td>
</tr>
</tbody></table>
<p><strong>Matcher类</strong></p>
<p>当需要对匹配的字符串进行具体操作时，就需要用到Matcher类，其方法如下：</p>
<table>
<thead>
<tr>
<th align="center">操作</th>
<th align="center">函数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">整个字符串是否匹配成功</td>
<td align="center"><code>matches()</code></td>
</tr>
<tr>
<td align="center">对开头的字符串进行匹配判断</td>
<td align="center"><code>lookingAt</code>()`</td>
</tr>
<tr>
<td align="center">尝试查找下一个匹配</td>
<td align="center"><code>fnd()</code></td>
</tr>
<tr>
<td align="center">从具体位置开始匹配</td>
<td align="center"><code>find(int i)</code></td>
</tr>
<tr>
<td align="center">上次匹配的起始索引</td>
<td align="center"><code>start()</code></td>
</tr>
<tr>
<td align="center">上次匹配的结束索引(不包含)</td>
<td align="center"><code>end()</code></td>
</tr>
<tr>
<td align="center">替代所有，返回字符串</td>
<td align="center"><code>replaceAll(String str)</code></td>
</tr>
<tr>
<td align="center">替代第一个，返回字符串</td>
<td align="center"><code>replaceFirst(String str)</code></td>
</tr>
</tbody></table>
<p>大概有<strong>匹配、替换、查看索引</strong>几种工作方式</p>
<h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><p>JavaString类中有几个方法需要正则表达式作为参数，实际利用了Pattern类和Matcher类</p>
<p><strong>split方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] split(String regex, <span class="keyword">int</span> limit) &#123;</span><br><span class="line">       ...</span><br><span class="line">       / ...的内容是对regex长度很小时进行的优化，长度短直接搜索快</span><br><span class="line">       <span class="keyword">return</span> Pattern.compile(regex).split(<span class="keyword">this</span>, limit);</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="keyword">public</span> String[] split(String regex) &#123;</span><br><span class="line">       <span class="keyword">return</span> split(regex, <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>该方法起到分离字符串的作用，比如在Java核心卷中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String context = <span class="string">&quot;2cat  - dog&quot;</span>;</span><br><span class="line">		String[] words = context.split(<span class="string">&quot;\\PL+&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span>(String s: words)</span><br><span class="line">			System.out.println(s);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/image-20210102180803742.png" alt="image-20210102180803742"></p>
<p><code>context.split(&quot;\\PL+&quot;);</code>就可以<strong>提取单词</strong>，如果首字母不是单词，一般返回的第一个串是没有用的空串，\\PL表示非字母，+表示一个或多个就可以起到分割提取单词的作用。但是注意，一般第一个串很可能是空串</p>
<p><strong>matches方法</strong></p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(String regex)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> Pattern.matches(regex, <span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p><strong>replace相关方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceAll</span><span class="params">(String regex, String replacement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Pattern.compile(regex).matcher(<span class="keyword">this</span>).replaceAll(replacement);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>使用这些方法注意用到特殊字符时的转义问题</p>
<h2 id="一些实例"><a href="#一些实例" class="headerlink" title="一些实例"></a>一些实例</h2><p><strong>匹配具体单词</strong></p>
<p>需要用到单词的边界匹配</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String context = <span class="string">&quot;cat catch cat&quot;</span>;</span><br><span class="line">		Pattern p = Pattern.compile(<span class="string">&quot;\\bcat\\b&quot;</span>);<span class="comment">// 即&quot;\\bword\\b&quot;</span></span><br><span class="line">		Matcher m = p.matcher(context);</span><br><span class="line">		<span class="keyword">while</span>(m.find()) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;start:&quot;</span> + m.start());</span><br><span class="line">			System.out.println(<span class="string">&quot;end:&quot;</span> + m.end());</span><br><span class="line">		&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/image-20210102183104718.png" alt="image-20210102183104718"></p>
<p><strong>后续更新</strong></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>字符串处理</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指7.重建二叉树</title>
    <url>/2021/01/02/%E5%89%91%E6%8C%877-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p>剑指 Offer 07. 重建二叉树</p>
<p><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/">力扣链接</a></p>
<a id="more"></a>

<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
<p> <strong>实例</strong></p>
<p>例如，给出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前序遍历 preorder &#x3D; [3,9,20,15,7]</span><br><span class="line">中序遍历 inorder &#x3D; [9,3,15,20,7]</span><br></pre></td></tr></table></figure>
<p>返回如下的二叉树：</p>
<pre><code>    3
   / \
  9  20
    /  \
   15   7</code></pre>
<p><strong>限制</strong></p>
<p><code>0 &lt;= 节点个数 &lt;= 5000</code></p>
<h1 id="思路一：递归"><a href="#思路一：递归" class="headerlink" title="思路一：递归"></a>思路一：递归</h1><p>正常的二叉树遍历问题，已知前序遍历是根左右，中序遍历是左根右，则显然：前序遍历数组的第一个元素，在中序遍历中作为根，将中序数组划分左右子树两部分</p>
<ul>
<li><p>第一步：建立根节点，在中序数组中找到<code>inorder[len] = preorder[0]</code>划分左右数组，并且根据len，也可以在前序数组中划分左右数组</p>
</li>
<li><p>第二步：在左子树执行相同操作</p>
</li>
<li><p>第三步：在右子树执行相同操作。</p>
<p>上诉操作很容易想到用递归，则递归实现如下，由于每次需要在中序数组中遍历找到对应元素，时间复杂度是O(n²)，考虑到栈空间，空间复杂度O(n),当然实际上我的数组复制操作也会带来额外的空间和时间浪费</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(inorder[len] != preorder[<span class="number">0</span>])</span><br><span class="line">        len++;</span><br><span class="line">        <span class="keyword">int</span> end =inorder.length;</span><br><span class="line">        root.left = buildTree(Arrays.copyOfRange(preorder,<span class="number">1</span>,len+<span class="number">1</span>),Arrays.copyOfRange(inorder,<span class="number">0</span>,len));</span><br><span class="line">        root.right = buildTree(Arrays.copyOfRange(preorder,len +<span class="number">1</span>,end),Arrays.copyOfRange(inorder,len+<span class="number">1</span>,end));</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很遗憾，速度比较低，在力扣上是20%水平</p>
</li>
</ul>
<h1 id="思路二：递归-散列优化"><a href="#思路二：递归-散列优化" class="headerlink" title="思路二：递归+散列优化"></a>思路二：递归+散列优化</h1><p>上诉过程有两个地方可以优化，一是查找过程可以用散列表加速查找，二是不必执行数组复制操作，时间复杂度可以降到O(n)</p>
<p>这个过程繁琐的是划分左右边界，最好自己示意一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = inorder.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            map.put(inorder[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> build(preorder,inorder,<span class="number">0</span>,n-<span class="number">1</span>,<span class="number">0</span>,n-<span class="number">1</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">build</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder,<span class="keyword">int</span> pbegin,<span class="keyword">int</span> pend,<span class="keyword">int</span> ibegin,<span class="keyword">int</span> iend)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pbegin &gt; pend)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[pbegin]);</span><br><span class="line">        <span class="keyword">int</span> len = map.get(preorder[pbegin]) - ibegin;</span><br><span class="line">        root.left = build(preorder,inorder,pbegin + <span class="number">1</span>,pbegin + len,ibegin,ibegin + len - <span class="number">1</span>);</span><br><span class="line">        root.right = build(preorder,inorder,pbegin + len + <span class="number">1</span>,pend,ibegin + len + <span class="number">1</span>,iend);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/images/image-20210102194618254.png" alt="image-20210102194618254"></p>
<h1 id="思路三：迭代法"><a href="#思路三：迭代法" class="headerlink" title="思路三：迭代法"></a>思路三：迭代法</h1><p>先前我们思考的是preorder的第一个元素将inorder划分成了左根右形式，那么inorder的第一个元素在preorder中代表什么？</p>
<ul>
<li><p>inorder的第一个元素应该是二叉树最左边元素，那当preorder一直走到其等于inorder[0]时，代表二叉树最左点到达了尽头。</p>
</li>
<li><p>那如何判断最左点右子树情况，最左点到达尽头后，如果其没有右结点，inorder下一个元素就是其父节点的值；反之，inorder下一个值即为右结点，又重复上诉操作</p>
</li>
</ul>
<p>这个过程和自己手写迭代形式的二叉树遍历过程很像，一般用一个栈来维护父节点。时空复杂度都是O(n)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (preorder.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> in = <span class="number">0</span>;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    <span class="keyword">while</span>(pre &lt; preorder.length)&#123;</span><br><span class="line">         <span class="comment">// 构建最左节点，并把其父节点压入栈</span></span><br><span class="line">        <span class="keyword">while</span>(pre &lt; preorder.length &amp;&amp; preorder[pre] != inorder[in])&#123;   </span><br><span class="line">            stack.push(cur);</span><br><span class="line">           <span class="keyword">if</span>(++pre &lt; preorder.length)&#123;</span><br><span class="line">               cur.left = <span class="keyword">new</span> TreeNode(preorder[pre]);</span><br><span class="line">               cur = cur.left;</span><br><span class="line">           &#125;&#125;</span><br><span class="line">             in++;</span><br><span class="line">           <span class="comment">// 判断该左节点是否有右孩子</span></span><br><span class="line">           <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; stack.peek().val == inorder[in])&#123;</span><br><span class="line">               cur = stack.pop();</span><br><span class="line">               in++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(++pre &lt; preorder.length)</span><br><span class="line">           cur.right = <span class="keyword">new</span> TreeNode(preorder[pre]);</span><br><span class="line">           cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该思路时间速度和方法二差不多</p>
<p><img src="/images/image-20210103104230425.png" alt="image-20210103104230425"></p>
<h1 id="思路四：迭代法递归化"><a href="#思路四：迭代法递归化" class="headerlink" title="思路四：迭代法递归化"></a>思路四：迭代法递归化</h1><p>实际上第四种方法是对思路三的递归形式，我们没有必要有一个辅助栈来维护父节点，只有保证递归顺序是先左后右，再将父亲节点的值作为参数传入即可，该思路比思路三写起来更为简洁，对递归的理解也更为深入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> in = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] preorder;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] inorder;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.preorder = preorder;</span><br><span class="line">        <span class="keyword">this</span>.inorder = inorder;</span><br><span class="line">        <span class="keyword">return</span> build(Integer.MIN_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">build</span><span class="params">(<span class="keyword">int</span> stop)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pre &gt;= preorder.length)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (inorder[in] == stop) &#123;</span><br><span class="line">            in++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(preorder[pre++]);</span><br><span class="line">        node.left = build(node.val);</span><br><span class="line">        node.right = build(stop);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/image-20210103104837655.png" alt="image-20210103104837655"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>做这道题的时候，开阔思路之后，理解更为深入，之前的话主要是掌握前两种思路，在提交思路二的方法后，发现有人用思路四的方法超越了100%，在思考其代码的时候，也想出了思路三</p>
<p>思路二和思路三思考方法是相反的，一个<strong>考虑inorder[0]代表什么，一个考虑preorder[0]代表什么</strong>，一个适合递归，一个就方便迭代了，并且这种用辅助栈迭代的过程不就是我们写这些遍历非递归方法的思路历程吗？只能说二叉树遍历的考点主要就是掌握这些基础：递归+非递归遍历思想</p>
<p>思路四是在掌握了思路三的基础了，去辅助栈递归化。</p>
]]></content>
      <categories>
        <category>剑指Offer</category>
        <category>算法</category>
        <category>二叉树遍历</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>二叉树遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>简单了解磁盘</title>
    <url>/2021/01/03/%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3%E7%A3%81%E7%9B%98%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>简单介绍一些磁盘的结构、并了解一些磁盘调度算法</p>
<a id="more"></a>

<h1 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h1><p>磁盘结构示意图如下：</p>
<p><img src="/images/image-20210103111225607.png" alt="image-20210103111225607"></p>
<p>磁盘有一个或多个<strong>盘片</strong>，用于存储数据。盘片多采用铝合金材料；中间有一个<strong>主轴</strong>，所有的盘片都绕着这个主轴转动。一个组合臂上面有多个<strong>磁头臂</strong>，每个磁头臂上面都有一个<strong>磁头</strong>，负责读写数据。</p>
<p>当磁头臂移动（<strong>寻道</strong>）处于不同位置时，会纵向上会组织成一个<strong>柱面</strong>，同时盘边上的同心圆环就称为<strong>磁道</strong>，一个磁道又可以划分成多个<strong>扇区</strong>。有的磁头总是在盘片上面，关机时，磁头停在盘片上面，抖动容易划伤盘面造成数据损失，为了避免这样的情况，所以磁头都是停留在没有数据启停区，而有的磁头，启停区就在盘片外面。</p>
<p>磁盘被<strong>磁盘控制器</strong>所控制（可控制一个或多个），它是一个小处理器，可以完成一些特定的工作。比如将磁头定位到一个特定的半径位置；从磁头所在的柱面选择一个扇区；读取数据等。</p>
<p><img src="/images/image-20210103113239890.png" alt="image-20210103113239890"></p>
<h1 id="磁盘访问加速"><a href="#磁盘访问加速" class="headerlink" title="磁盘访问加速"></a>磁盘访问加速</h1><p>磁盘访问和内存访问差距很大，需要对其进行加速、优化</p>
<h2 id="并行I-O-RAID"><a href="#并行I-O-RAID" class="headerlink" title="并行I/O (RAID)"></a>并行I/O (RAID)</h2><p>RAID （ Redundant Array of Independent Disks ）即独立磁盘冗余阵列，通常简称为磁盘阵列。简单地说， RAID 是由多个独立的高性能磁盘驱动器组成的磁盘子系统，从而提供比单个磁盘更高的存储性能和数据冗余的技术。单个磁盘的 I/O 性能受到接口、带宽等计算机技术的限制，性能往往很有 限，容易成为系统性能的瓶颈。通过数据条带化， RAID 将数据 I/O 分散到各个成员磁盘上，从而获得比单个磁盘成倍增长的聚合 I/O 性能。</p>
<h2 id="磁盘臂调度算法"><a href="#磁盘臂调度算法" class="headerlink" title="磁盘臂调度算法"></a>磁盘臂调度算法</h2><p>读取一个磁盘块的时间由三个元素决定</p>
<ul>
<li><strong>寻道时间：</strong>磁盘臂移动到合适柱面所需时间</li>
<li><strong>旋转延迟：</strong>扇区转到磁头下所需时间</li>
<li><strong>实际数据传输时间</strong></li>
</ul>
<p>一般来说，寻道时间占主导地位，优化寻道时间可以改善访问性能</p>
<p>主要有以下算法优化磁盘臂调度</p>
<ul>
<li><strong>先到先服务（FCFS）</strong>：按照磁盘请求的顺序进行调度。优点是公平和简单，但很难优化寻道时间</li>
<li><strong>最短寻道优先（SSF）：</strong>下一次处理与磁头距离最小的柱面。优点是平均寻道时间短，但磁盘负担重时，很容易让磁盘臂停留在磁盘的中部区域，两端极端区域请求饥饿</li>
<li><strong>电梯算法：</strong>类似电梯总是一个方向运行，直到该方向没有请求为止，然后改变运行方向。兼顾效率和公平</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>前面在文件系统说到的三种方法，<strong>高速缓存、块提取读、按柱面组织数据（减少磁盘臂运动）</strong></p>
<p>这里特别强调一个<strong>磁盘控制器的高速缓存</strong>，与前面使用内存、操作系统的高速缓存进行区分，两者完全独立：</p>
<p>由于寻道和旋转影响性能，一次只读取一两个扇区效率非常低下，于是当请求扇区时，磁盘控制器总是读取多个扇区并进行高速缓存，这里的高速缓存区是在磁盘上，最简单可以分为读写两个区段</p>
<p>其和操作系统的高速缓存有明显区别：一是<strong>高速缓存位置</strong>，二是<strong>高速缓存的块是否被请求</strong>：操作系统的任何高速缓存由显式读出的块组成，认为其很近的将来会被需要，而磁盘的高速缓存只是恰巧经过</p>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>现代操作系统</category>
      </categories>
      <tags>
        <tag>磁盘管理</tag>
      </tags>
  </entry>
  <entry>
    <title>死锁</title>
    <url>/2021/01/03/%E6%AD%BB%E9%94%81/</url>
    <content><![CDATA[<p>在操作系统中，请求独占性的I/O设备会死锁；在Java并发中，对同步的块进行访问也可能发生死锁；学习数据库时，清除数据库中也有死锁操作。本文了解如何出现死锁，学习防止如何避免死锁</p>
<a id="more"></a>

<h1 id="死锁条件"><a href="#死锁条件" class="headerlink" title="死锁条件"></a>死锁条件</h1><p><strong>资源：</strong>需要排他使用的对象</p>
<p><strong>可抢占资源：</strong>可以从拥有它的进程抢用而无副作用</p>
<p><strong>不可抢占资源：</strong>如计算不失败，无法将其从占用它的进程处抢占过来</p>
<p>而死锁和不可抢占资源有关，以下讨论资源基本指不可抢占资源</p>
<p><strong>资源死锁必要条件：</strong></p>
<ul>
<li>互斥条件：资源要么可用，要么已分配给进程</li>
<li>占用和等待条件：已经得到某个资源的进程可以请求新的资源</li>
<li>不可抢占条件：即资源是不可抢占资源，除非占用它的进程释放</li>
<li>环路等待条件：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源</li>
</ul>
<h1 id="死锁处理"><a href="#死锁处理" class="headerlink" title="死锁处理"></a>死锁处理</h1><p>死锁处理主要有以下几种方法</p>
<h2 id="鸵鸟算法"><a href="#鸵鸟算法" class="headerlink" title="鸵鸟算法"></a>鸵鸟算法</h2><p>把头埋在沙子里，假装根本没发生问题。</p>
<p>在死锁预防代价高、当发生死锁时不会对用户造成多大影响、或发生死锁的概率很低可以忽略它</p>
<h2 id="死锁检测和恢复"><a href="#死锁检测和恢复" class="headerlink" title="死锁检测和恢复"></a>死锁检测和恢复</h2><p><strong>死锁检测</strong></p>
<ul>
<li><p><strong>每种类型一个资源：</strong>类似与数据库事务死锁的事务等待图，操作系统维护一<strong>资源分配图</strong>，如下图：</p>
<p><img src="/images/image-20210103160725790.png" alt="image-20210103160725790"></p>
<p>方框表示资源，圆圈表示进程。资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源，当出现环路就认为出现了死锁。</p>
<p>那检测死锁也是检测改图是否有环，利用深度优先搜索算法（还有其他算法）可以实现检测。</p>
</li>
<li><p><strong>每种类型多个资源：</strong>通过基于<strong>矩阵</strong>的运算解决，维护以下向量和矩阵</p>
<p><img src="/images/image-20210103183557925.png" alt="image-20210103183557925"></p>
<ul>
<li>E 向量：资源总量</li>
<li>A 向量：资源剩余量</li>
</ul>
</li>
<li><p>C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量</p>
<ul>
<li>R 矩阵：每个进程请求的资源数量，每一行表示一个进程请求的资源数量</li>
</ul>
<p>寻找没有被标记的进程只要<code>R矩阵第i行&lt;=A</code>,则认为其可以<strong>申请到资源</strong>，标记它，并将C矩阵第i行加到A上，即也认为其可<strong>释放资源</strong>，循环执行上诉操作直到找不到满足条件的可标记进程，之后未标记进程都是死锁进程</p>
</li>
</ul>
<p><strong>死锁恢复：</strong></p>
<p>当检测到死锁后，需要恢复使系统重新工作，以下是一些死锁恢复手段：</p>
<ul>
<li><strong>抢占恢复：</strong>临时将某个资源从当前所有者转移给另一个进程，许多情况需要人工干预。比较困难，很大程度在于资源是否容易回收</li>
<li><strong>回滚恢复：</strong>回滚到上一个检查点，丢弃检查点之后的工作</li>
<li><strong>杀死进程：</strong>选择杀死环中或者环外持有环中所需资源的进程杀掉，可能会产生副作用。</li>
</ul>
<h2 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h2><p>如果事先预知最大资源请求信息，可以通过算法调度资源避免死锁</p>
<p><strong>安全状态</strong></p>
<p><img src="/images/image-20210103183812176.png" alt="image-20210103183812176"></p>
<p>上图a是初始状态，从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时<strong>安全的</strong>。</p>
<p>而如下图就就是<strong>不安全的</strong>，最后AC两个进程都无法获得想要的资源</p>
<p><img src="/images/image-20210103183835470.png" alt="image-20210103183835470"></p>
<p><strong>单个资源的银行家算法</strong></p>
<p>对一个请求进行检查，检查这一请求是否能到达安全状态，若可以，则满足该请求，反之延迟该请求。而<strong>检测安全状态</strong>的过程就和死锁检测的过程很像，看资源能否满足某个进程并释放，最后是否能全部释放。</p>
<p><strong>多个资源的银行家算法</strong></p>
<p>维护多个资源死锁检测类似的数组和向量，检测安全状态时基本类似</p>
<p><img src="/images/image-20210103184636849.png" alt="image-20210103184636849"></p>
<p>检查一个状态是否安全的算法如下：</p>
<ul>
<li>查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。</li>
<li>假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。</li>
<li>重复以上两步，直到所有进程都标记为终止，则状态时安全的。</li>
</ul>
<h2 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h2><p>很多时候，无法做到死锁避免，因为很多信息并不知道，这是只能预防死锁，这是实际操作系统避免死锁的操作，银行家算法实际很少使用，因为很少进程一开始就知道所需资源最大值、并且进程数量也会变化、资源也可能突然不可用</p>
<p>实际预防死锁采用破坏操作系统的方式</p>
<p>1.<strong>破坏互斥条件：</strong></p>
<p>一切使用假脱机技术，允许若干个进程同时产生输出。</p>
<p>2.<strong>破坏占用并等待条件：</strong></p>
<p>禁止进程等待资源，规定所有进程在开始执行前请求所需要的全部资源。但是如此可以资源利用率低，并且此时可以使用银行家算法进行死锁避免</p>
<p>3.<strong>破坏不可抢占条件：</strong></p>
<p>抢占资源，将资源虚拟化</p>
<p>4.<strong>破坏环路等待条件：</strong></p>
<p>对资源按序编号，进程提出的请求必须按资源顺序给出</p>
<p>这部分的内容和数据库死锁部分的内容很有联系，可以互为对照</p>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>现代操作系统</category>
      </categories>
      <tags>
        <tag>死锁</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指10 斐波拉契</title>
    <url>/2021/01/04/%E5%89%91%E6%8C%8710-%E6%96%90%E6%B3%A2%E6%8B%89%E5%A5%91/</url>
    <content><![CDATA[<p><strong>剑指 Offer 10- I. 斐波那契数列</strong></p>
<p><strong>剑指 Offer 10- II. 青蛙跳台阶问题</strong></p>
<p><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">力扣链接</a></p>
<p><a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/">力扣链接</a></p>
<a id="more"></a>

<h1 id="第一题题目描述"><a href="#第一题题目描述" class="headerlink" title="第一题题目描述"></a>第一题题目描述</h1><p>写一个函数，输入 <code>n</code> ，求斐波那契（Fibonacci）数列的第 <code>n</code> 项。斐波那契数列的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">F(0) &#x3D; 0,   F(1) &#x3D; 1</span><br><span class="line">F(N) &#x3D; F(N - 1) + F(N - 2), 其中 N &gt; 1.</span><br></pre></td></tr></table></figure>
<p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 2</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 5</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>


<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= n &lt;= 100</code></li>
</ul>
<h1 id="思路一：动态规划"><a href="#思路一：动态规划" class="headerlink" title="思路一：动态规划"></a>思路一：动态规划</h1><p>都列出了表达式，典型的动态规划问题，列出的表达式就是<strong>状态转移方程</strong>，解决了最大难点。</p>
<p>此外由于第n个值只是与前两个值有关，不必建立一维数组，直接利用三个数进行<strong>空间优化</strong>，这是动态规划问题能写出来后该考虑的问题。</p>
<p>基于此结构，明显从前往后遍历，写出代码如下,时间复杂度O（n），空间复杂度O(1)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        sum = (a + b)% <span class="number">1000000007</span>;</span><br><span class="line">        a = b;</span><br><span class="line">        b = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="思路二：记忆化搜索"><a href="#思路二：记忆化搜索" class="headerlink" title="思路二：记忆化搜索"></a>思路二：记忆化搜索</h1><p>这道题直接递归可能会炸（我没有试过），因为每次递归都会有很大部分数据重复计算，如果将计算出来的结果用数组保持，就可以减少不必要的计算，这就是记忆化搜索。时空复杂度O（n）</p>
<p>记忆化搜索是时间换空间，动态规划也是时间换空间，实际上，我认为记忆化搜索就是动态规划<strong>不用考虑遍历方式</strong>的形式，这也是在其空间复杂度没有思路一高、时间可能存在多余开销、有递归栈风险我还要讲解他的原因。</p>
<p>使用记忆化搜索不用思考遍历顺序，简化思考，特别在遍历方式复杂的动态规划问题中（特别是<strong>区间动归问题</strong>）可以节约时间，并且形成一种动态规划模板。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">        dp = <span class="keyword">new</span> <span class="keyword">int</span> [n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> recursion(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">recursion</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">        <span class="keyword">if</span>(dp[n-<span class="number">1</span>] !=<span class="number">0</span>)</span><br><span class="line">        dp[n] = (dp[n-<span class="number">1</span>] + dp[n-<span class="number">2</span>]) % <span class="number">1000000007</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        dp[n] = (recursion(n-<span class="number">1</span>) + dp[n-<span class="number">2</span>]) %<span class="number">1000000007</span>;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>这是一道简单的动态规划题，但是好的说明了动态规划和记忆化搜索的联系，具有指导意义</p>
<p>对应另外一道类似题的差距，只是在于dp[0] = 1而已</p>
]]></content>
      <categories>
        <category>剑指Offer</category>
        <category>算法</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>记忆化搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP</title>
    <url>/2021/01/05/HTTP/</url>
    <content><![CDATA[<p>简单介绍HTTP协议在Web中的应用，简单了解其工作机制、HTTP报文信息、以及其版本迭代</p>
<a id="more"></a>

<h1 id="1-Web页面的呈现"><a href="#1-Web页面的呈现" class="headerlink" title="1.Web页面的呈现"></a>1.Web页面的呈现</h1><p>Web主要通过在三项构建技术构建：通过<strong>URL</strong>进行资源定位，利用<strong>HTTP</strong>进行文本传输，最后使用<strong>HTML</strong>经浏览器解析、渲染后呈现出Web页面。</p>
<p>具体到客户端与Web服务器的交互上，整个过程如下图所示：</p>
<p><img src="/images/image-20210105211339300.png" alt="image-20210105211339300"></p>
<ul>
<li>首先是利用<strong>DNS服务</strong>得到URL到服务器IP地址的映射</li>
<li>利用得到的IP，之后<strong>TCP</strong>三次握手建立客户端到服务器的连接，保证可靠传输。在这段过程中，网络层在利用<strong>IP协议</strong>传输、期间可能用到<strong>ARP协议</strong>又得到该站到下一站中转设备MAC地址的映射。</li>
<li>建立好连接之后，客户端会发生HTTP请求报文，报文中包含一些信息</li>
<li>服务器收到请求报文后，返回HTTP响应报文</li>
<li>由于HTTP/1.1是默认连接是持久连接，可能还会多次重复前两步步骤，直到最后提出断开连接，才会断开TCP连接</li>
</ul>
<p><strong>DNS补充</strong></p>
<p>DNS是分布式集群的层次结构的计算机和网络服务命名系统</p>
<p>一般主要可以分为根域名服务器、顶级域名服务器、权限域名服务器、本地域名服务器</p>
<p>当真的需要对域名的IP地址进行查询的时候，一般有以下方案</p>
<p><strong>客户端缓存</strong>：查询客户端浏览器、本机系统是否缓存过该IP</p>
<p><strong>直接解析：</strong>本地域名服务器有缓存</p>
<p>当本地服务器不能从本地缓存回复客户端时，又有两种方式查询</p>
<p><strong>递归查询：</strong>本地DNS服务器自己负责向其他DNS服务器进行查询，一般是先向该域名的根域服务器查询，再由根域名服务器一级级向下查询。最后得到的查询结果返回给局部DNS服务器，再由本地DNS服务器返回给客户端。</p>
<p><strong>迭代查询：</strong>当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地服务器进行后续的查询。</p>
<h1 id="2-HTTP概述"><a href="#2-HTTP概述" class="headerlink" title="2.HTTP概述"></a>2.HTTP概述</h1><p>HTTP协议用于客户端和服务端之间，通过请求和响应报文的交换达成通信。HTTP不保存状态、1.1版本默认使用长连接节省通信量，但是为了实现期望的保持状态功能，引入了Cookie技术管理状态。</p>
<p><strong>HTTP的优缺点：</strong></p>
<ul>
<li>优点<ul>
<li>简单灵活易于拓展</li>
<li>应用广泛</li>
</ul>
</li>
<li>缺点<ul>
<li>通信明文可能被窃听</li>
<li>通信身份可能造伪装</li>
<li>无法证明报文完整性，可能已经被篡改</li>
</ul>
</li>
</ul>
<p>学习HTTP,重点和难点就是在于其请求报文和响应报文的学习，下面是具体内容</p>
<h1 id="3-HTTP请求报文"><a href="#3-HTTP请求报文" class="headerlink" title="3.HTTP请求报文"></a>3.HTTP请求报文</h1><p>HTTP请求报文格式如下</p>
<p><img src="/images/image-20210313101500745.png" alt="image-20210313101500745"></p>
<p>了解其格式之后，主要还得了解常用请求方法和一些请求头部字段的含义</p>
<h2 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h2><p>请求报文通过请求报文告知服务器自己的意图</p>
<p><strong>GET</strong></p>
<p><code>获取资源</code></p>
<p>GET方法用来访问已被URI识别的资源，指定的资源经服务器端解析后返回响应内容</p>
<p>GET方法是请求报文使用得最多的方法下面是一个常见的get访问URL</p>
<p><code>http://mp.weixin.qq.com/s?src=11&amp;timestamp=1615599911&amp;...</code></p>
<p>其？后面是一些传递的参数</p>
<p><strong>POST</strong></p>
<p><code>传输实体的主体</code></p>
<p>POST方法也可以获取响应，但更重要的目的是为了传输一些主体参数,虽然一般GET也能传输参数，但一般不用GET传输</p>
<p><strong>HEAD</strong></p>
<p><code>获取报文首部</code></p>
<p>和 GET 方法类似，但是不返回报文实体主体部分。</p>
<p>主要用于确认 URL 的有效性以及资源更新的日期时间等。</p>
<p><strong>PUT、DELETE</strong></p>
<p><code>上传、删除文件</code></p>
<p>由于HTTP/1.1的这两个方法不带验证机制，存在安全性问题，所以一般都不使用</p>
<p><strong>OPTIONS</strong></p>
<p><code>查询服务器支持方法</code></p>
<p>查询指定的 URL 服务器能够支持的方法。</p>
<p><strong>CONNECT</strong></p>
<p><code>要求用隧道协议连接代理</code></p>
<p>该方法要求在代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。一般主要使用SSL和TLS协议将通信内容加密后经网络隧道传输</p>
<h2 id="首部字段"><a href="#首部字段" class="headerlink" title="首部字段"></a>首部字段</h2><p>总的来说一个完整的HTTP请求报文包括，请求行、首部字段、其他和报文主题</p>
<p>首部字段又由请求首部字段、通用首部字段和实体首部字段</p>
<p>下面对这些字段进行介绍</p>
<h3 id="通用首部字段"><a href="#通用首部字段" class="headerlink" title="通用首部字段"></a>通用首部字段</h3><p>通用首部字段是指请求报文和响应报文都会使用的首部</p>
<table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Cache-Control</td>
<td>控制缓存的行为</td>
</tr>
<tr>
<td>Connection</td>
<td>控制不再转发给代理的首部字段、管理持久连接</td>
</tr>
<tr>
<td>Date</td>
<td>创建报文的日期时间</td>
</tr>
<tr>
<td>Pragma</td>
<td>报文指令</td>
</tr>
<tr>
<td>Trailer</td>
<td>报文末端的首部一览</td>
</tr>
<tr>
<td>Transfer-Encoding</td>
<td>指定报文主体的传输编码方式</td>
</tr>
<tr>
<td>Upgrade</td>
<td>升级为其他协议</td>
</tr>
<tr>
<td>Via</td>
<td>代理服务器的相关信息</td>
</tr>
<tr>
<td>Warning</td>
<td>错误通知</td>
</tr>
</tbody></table>
<h3 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h3><table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Accept</td>
<td>用户代理可处理的媒体类型</td>
</tr>
<tr>
<td>Accept-Charset</td>
<td>优先的字符集</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>优先的内容编码</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>优先的语言（自然语言）</td>
</tr>
<tr>
<td>Authorization</td>
<td>Web 认证信息</td>
</tr>
<tr>
<td>Expect</td>
<td>期待服务器的特定行为</td>
</tr>
<tr>
<td>From</td>
<td>用户的电子邮箱地址</td>
</tr>
<tr>
<td>Host</td>
<td>请求资源所在服务器</td>
</tr>
<tr>
<td>If-Match</td>
<td>比较实体标记（ETag）</td>
</tr>
<tr>
<td>If-Modified-Since</td>
<td>比较资源的更新时间</td>
</tr>
<tr>
<td>If-None-Match</td>
<td>比较实体标记（与 If-Match 相反）</td>
</tr>
<tr>
<td>If-Range</td>
<td>资源未更新时发送实体 Byte 的范围请求</td>
</tr>
<tr>
<td>If-Unmodified-Since</td>
<td>比较资源的更新时间（与 If-Modified-Since 相反）</td>
</tr>
<tr>
<td>Max-Forwards</td>
<td>最大传输逐跳数</td>
</tr>
<tr>
<td>Proxy-Authorization</td>
<td>代理服务器要求客户端的认证信息</td>
</tr>
<tr>
<td>Range</td>
<td>实体的字节范围请求</td>
</tr>
<tr>
<td>Referer</td>
<td>对请求中 URI 的原始获取方</td>
</tr>
<tr>
<td>TE</td>
<td>传输编码的优先级</td>
</tr>
<tr>
<td>User-Agent</td>
<td>HTTP 客户端程序的信息</td>
</tr>
</tbody></table>
<h3 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a>实体首部字段</h3><table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Allow</td>
<td>资源可支持的 HTTP 方法</td>
</tr>
<tr>
<td>Content-Encoding</td>
<td>实体主体适用的编码方式</td>
</tr>
<tr>
<td>Content-Language</td>
<td>实体主体的自然语言</td>
</tr>
<tr>
<td>Content-Length</td>
<td>实体主体的大小</td>
</tr>
<tr>
<td>Content-Location</td>
<td>替代对应资源的 URI</td>
</tr>
<tr>
<td>Content-MD5</td>
<td>实体主体的报文摘要</td>
</tr>
<tr>
<td>Content-Range</td>
<td>实体主体的位置范围</td>
</tr>
<tr>
<td>Content-Type</td>
<td>实体主体的媒体类型</td>
</tr>
<tr>
<td>Expires</td>
<td>实体主体过期的日期时间</td>
</tr>
<tr>
<td>Last-Modified</td>
<td>资源的最后修改日期时间</td>
</tr>
</tbody></table>
<h1 id="4-HTTP响应报文"><a href="#4-HTTP响应报文" class="headerlink" title="4.HTTP响应报文"></a>4.HTTP响应报文</h1><p>HTTP响应报文和请求报文类似，只是第一行叫状态行、再由响应首部和响应数据组成</p>
<h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><p>状态码类别</p>
<p><img src="/images/image-20210313111945041.png" alt="image-20210313111945041"></p>
<p>下面是一些常用状态码</p>
<p><strong>2XX:成功</strong></p>
<p>200 OK 正常处理</p>
<p>204 No Content 请求处理成功，但是没有资源可返回</p>
<p>206 Partial Content 客户端范围请求，请求成功</p>
<p><strong>3XX：重定向</strong></p>
<p>301 永久重定向       资源分配了新的URI，以后使用该URI</p>
<p>302 临时重定向       希望用户本次访问使用该URI</p>
<p>303 See Other         功能和302类似，但制定客户端用GET方法访问</p>
<p>304 Not Modified    如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since等如果不满足条件，则服务器会返回 304 状态码。</p>
<p>307   临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。</p>
<p><strong>4XX：客户端错误</strong></p>
<p>400 请求报文语法错误</p>
<p>401 HTTP认证</p>
<p>403 服务器拒绝访问</p>
<p>404 没有请求资源</p>
<p><strong>5XX：服务器错误</strong></p>
<p>500 服务器内部执行请求发生错误</p>
<p>503 服务器超负载或者停机</p>
<h2 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a>响应首部字段</h2><table>
<thead>
<tr>
<th>Accept-Ranges</th>
<th>是否接受字节范围请求</th>
</tr>
</thead>
<tbody><tr>
<td>Age</td>
<td>推算资源创建经过时间</td>
</tr>
<tr>
<td>ETag</td>
<td>资源的匹配信息</td>
</tr>
<tr>
<td>Location</td>
<td>令客户端重定向至指定 URI</td>
</tr>
<tr>
<td>Proxy-Authenticate</td>
<td>代理服务器对客户端的认证信息</td>
</tr>
<tr>
<td>Retry-After</td>
<td>对再次发起请求的时机要求</td>
</tr>
<tr>
<td>Server</td>
<td>HTTP 服务器的安装信息</td>
</tr>
<tr>
<td>Vary</td>
<td>代理服务器缓存的管理信息</td>
</tr>
<tr>
<td>WWW-Authenticate</td>
<td>服务器对客户端的认证信息</td>
</tr>
</tbody></table>
<h1 id="5-HTTPS"><a href="#5-HTTPS" class="headerlink" title="5.HTTPS"></a>5.HTTPS</h1><p>前面说到HTTP有三个缺点。但是如果对这个三个缺点进行改进，即用</p>
<p>HTTP+加密+认证+完整性保护=HTTPS</p>
<p>HTTPS是身批SSL外壳的HTTP，SSL是指Secure Socket Layer，通常，HTTP直接与TCP通信，当使用SSL后，HTTP通信接口部分先和SSL通信，再由SSL和TCP通信</p>
<h2 id="SSL加密"><a href="#SSL加密" class="headerlink" title="SSL加密"></a>SSL加密</h2><h3 id="加密方法"><a href="#加密方法" class="headerlink" title="加密方法"></a>加密方法</h3><p><strong>对称密钥加密</strong></p>
<p>也叫共享密钥加密，即加密和解密用同一个密钥</p>
<ul>
<li>优点：运算速度快；</li>
<li>缺点：无法安全地将密钥传输给通信方</li>
</ul>
<p><strong>非对称密钥加密</strong></p>
<p>也叫公开密钥加密，加密和解密使用不同的密钥。</p>
<p>公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容（内含私有秘钥）后使用私有密钥解密。</p>
<p>非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。</p>
<ul>
<li>优点：可以更安全地将公开密钥传输给通信发送方；</li>
<li>缺点：运算速度慢。</li>
</ul>
<h3 id="HTTPS加密"><a href="#HTTPS加密" class="headerlink" title="HTTPS加密"></a>HTTPS加密</h3><p>上面提到对称密钥加密方式的传输效率更高，但是无法安全地将密钥 Secret Key 传输给通信方。而非对称密钥加密方式可以保证传输的安全性，因此我们可以利用非对称密钥加密方式将 Secret Key 传输给通信方。之后再采用对称加密的方式进行通信。</p>
<p>即HTTPS采用混合加密机制</p>
<h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><p>通过使用 <strong>证书</strong> 来对通信方进行认证。</p>
<p>数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。</p>
<p>服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。</p>
<p>进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。</p>
<h2 id="完整性保护"><a href="#完整性保护" class="headerlink" title="完整性保护"></a>完整性保护</h2><p>SSL 提供报文摘要功能来进行完整性保护。</p>
<p>HTTP 也提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生了篡改。</p>
<p>HTTPS 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。</p>
<p>最后学习了加密、认证、完整性保护，可以发现HTTPS还是有一定缺点</p>
<ul>
<li>因为需要进行加密解密等过程，因此速度会更慢</li>
<li>由于消耗更多的CPU资源，能处理的请求数量减少</li>
<li>需要支付证书授权的高额费用。</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>二分模板两个</title>
    <url>/2021/01/05/%E4%BA%8C%E5%88%86%E6%A8%A1%E6%9D%BF%E4%B8%A4%E4%B8%AA/</url>
    <content><![CDATA[<p>二分法主要用于二分查找，二分查找经常会运用在解题的一个步骤中，主要有两个模板</p>
<a id="more"></a>

<h1 id="1-查找是否存在某元素模板"><a href="#1-查找是否存在某元素模板" class="headerlink" title="1.查找是否存在某元素模板"></a><strong>1.查找是否存在某元素模板</strong></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int low &#x3D; 0;</span><br><span class="line">int high &#x3D; nums.length - 1;</span><br><span class="line">int mid;</span><br><span class="line">while(low &lt;&#x3D; high)&#123;</span><br><span class="line">    mid &#x3D; (low + high) &#x2F; 2;</span><br><span class="line">    if(nums[mid] &#x3D;&#x3D; target)</span><br><span class="line">    return mid;</span><br><span class="line">    if(nums[mid] &gt; target)</span><br><span class="line">    high &#x3D; mid - 1;</span><br><span class="line">    else</span><br><span class="line">    low &#x3D; mid + 1;</span><br><span class="line">&#125;</span><br><span class="line">return -1;</span><br></pre></td></tr></table></figure>
<h1 id="2-查找第一个符合条件的模板"><a href="#2-查找第一个符合条件的模板" class="headerlink" title="2.查找第一个符合条件的模板"></a><strong>2.查找第一个符合条件的模板</strong></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int low &#x3D; 0;</span><br><span class="line">int high &#x3D; nums.length;</span><br><span class="line">int mid;</span><br><span class="line">while(low &lt; high)&#123;</span><br><span class="line">    mid &#x3D; (low + high) &#x2F; 2;</span><br><span class="line">    if(条件) &#x2F;&#x2F; 大于或大于等于</span><br><span class="line">    high &#x3D; mid;</span><br><span class="line">    else</span><br><span class="line">    low &#x3D; mid + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于这个模板，条件那里如果是<code>nums[mid] &gt;= target</code>就是查找第一个大于等于目标值的下标，如果是<code>nums[mid] &gt; target</code> 就是查找第一个大于目标值的下标。</p>
<p>此外得注意拓展</p>
<ul>
<li><p>欲求最后一个等于target或小于target的下标可以转化成求 <code>nums[mid] &gt; target</code> 下标减1（再判断）</p>
</li>
<li><p>欲求第一个等于target 的下标就是<code>nums[mid] &gt;= target</code>就的下标，再判断</p>
<p>即模板2是包含模板1的，比模板1更强大</p>
</li>
<li><p>有的时候不方便思考下标问题，可以在<code>while</code>体后面对下标或者下标值进行判断即可</p>
</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
        <category>二分</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指11旋转数组最小数字</title>
    <url>/2021/01/05/%E5%89%91%E6%8C%8711%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<p><strong>剑指 Offer 11. 旋转数组的最小数字</strong></p>
<p><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">力扣链接</a></p>
<a id="more"></a>

<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 <code>[3,4,5,1,2]</code> 为 <code>[1,2,3,4,5]</code> 的一个旋转，该数组的最小值为1。 </p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[3,4,5,1,2]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[2,2,2,0,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<h1 id="思路：二分模板"><a href="#思路：二分模板" class="headerlink" title="思路：二分模板"></a>思路：二分模板</h1><p>典型的二分题目，因为遍历一遍数组是O(n)时间复杂度，那么要想最简，是O(logn),就很大可能是二分。</p>
<p>发现旋转后的最小元素有一个特点：其值比左边的值小，那就将题目转化成查找唯一一个小于左边值的数。</p>
<p>题目难度是在于判断最小值的位置：</p>
<ul>
<li><p>颠倒数组分为前后两个增序的数组，如果mid在后一个数组，最小值在其左侧，如果在前一个数组，最小值就在其右侧。只要如何判断前后数组，利用数组第一个值或最后一个值作为分界线即可</p>
</li>
<li><p>当数组实际没有被颠倒时，返回第一个数</p>
<p>最后套用模板一即可，时间复杂度O(logn),空间复杂度O(1)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">int</span> high = numbers.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> target = numbers[high];</span><br><span class="line">        <span class="comment">// 排除实际没有旋转的情况</span></span><br><span class="line">        <span class="keyword">if</span>(high == <span class="number">0</span> || target &gt; numbers[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">return</span> numbers[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 去掉重复元素，方便前后区，如果该数组没有重复元素，不需要这步</span></span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; numbers[low] == target)</span><br><span class="line">            low++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="comment">// 二分查找模板1</span></span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">            mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(numbers[mid] &lt; numbers[mid - <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> numbers[mid];</span><br><span class="line">            <span class="keyword">if</span>(target &lt; numbers[mid])</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 全是重复元素</span></span><br><span class="line">        <span class="keyword">return</span> numbers[low];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看了该题的官方题解，其二分的形式直接利用<code>number[high]</code>和<code>number[mid]</code>做对比更为简洁，附上代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = numbers.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> pivot = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (numbers[pivot] &lt; numbers[high]) &#123;</span><br><span class="line">                high = pivot;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numbers[pivot] &gt; numbers[high]) &#123;</span><br><span class="line">                low = pivot + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                high -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[low];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>典型的二分查找题目，熟记格式，理清楚思路，直接套即可，如果想查看总结的二分模板，可以在算法分类的二分分类中查看文章</p>
]]></content>
      <categories>
        <category>剑指Offer</category>
        <category>算法</category>
        <category>二分</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP杂谈</title>
    <url>/2021/01/06/TCP%E6%9D%82%E8%B0%88/</url>
    <content><![CDATA[<p>简单回顾一下所学的TCP知识</p>
<a id="more"></a>

<h1 id="引文"><a href="#引文" class="headerlink" title="引文"></a>引文</h1><p>如何保证一个传递数据的协议是可靠的，毕竟数据在链路层传输过程中可能会产生比特错误。</p>
<p>思路有二，一是差错纠正，可以解决<strong>错误丢包</strong>的问题；但是如果一个包是由于路由缓存不够由于排队策略而丢包（<strong>拥塞丢包</strong>），接收方根本接收不到包，那又怎么办？</p>
<p>这时第二个思路就是<strong>ARQ</strong>，自动重复请求，简单尝试重新发送，直到信息最终被接收。</p>
<p>ARQ构成了TCP的基础，利用超时和重传，再加上校验和检错，最终可以保证接受方收到正确的数据。</p>
<p>之后又产生了效率的问题，发送方不可能一次只发送一个小分组，不能充分利用带宽，所以TCP采用了<strong>滑动窗口</strong>的形式，希望充分利用带宽。发送的数据量多了，接收方可能接收不过来，又或者是网络中路由器处理过来，于此又引发了<strong>流量控制</strong>和<strong>拥塞控制</strong>等问题</p>
<p>每一种问题都有很多思考的细节</p>
<p>TCP是怎么连接的，分组的大小有限制吗?</p>
<p>怎么判断数据有没有被送到，多久没有收到算超时？</p>
<p>重传的策略，一定要超时重传吗？</p>
<p>滑动窗口怎么控制流量，又怎么进行拥塞控制？</p>
<p>…..</p>
<p>以下内容简短回顾一下上诉一下问题解决方案的学习。</p>
<h1 id="TCP头部与状态转换"><a href="#TCP头部与状态转换" class="headerlink" title="TCP头部与状态转换"></a>TCP头部与状态转换</h1><h2 id="头部"><a href="#头部" class="headerlink" title="头部"></a>头部</h2><p>下面是TCP的封装以及其头部信息 </p>
<p><img src="/images/image-20201212104849119.png" alt="image-20201212104849119"></p>
<p>TCP头部紧跟着IP头部或IPv6扩展头部，一般是20字节。如果带选项（如MSS、时间戳、窗口缩放），可达60字节。</p>
<p>下面是关于TCP头部的详细介绍：</p>
<p><img src="/images/image-20201212104923393.png" alt="image-20201212104923393"></p>
<p><strong>基本头部</strong></p>
<p>其中<strong>序列号</strong>可以让接受方判断是否收到重复数据、判断正确该TCP连接是否能正确建立</p>
<p>而<strong>确认号</strong>让发送方知道接收方接受数据情况，是滑动窗口移动、超时判断、丢包判断的基础</p>
<p><strong>CWR</strong>是发送方底层出现丢包（本地拥塞）或者收到显示拥塞通知ECN（即ECE置位）的分组时，采取的拥塞控制策略，每两个ACK减少一个cwnd。</p>
<p><strong>ECE</strong>是ECN回显，ECN主要在IP层运作</p>
<p><strong>ACK、SYN、FIN</strong>用于TCP连接的建立和关闭，其中ACK还可以用于数据的确认，窗口更新</p>
<p><strong>RST</strong></p>
<p>该位置位为重置报文段，同时ACK位也必须置位，确认号在正确窗口范围内，防止连接被恶意的RST报文段打断。主要作用：</p>
<ul>
<li>拒绝不正确的连接，表明目的端口不可达的消息</li>
<li>终止一条连接：对于FIN终止连接，称为有序释放，FIN当之前的所有数据已经发送后发出，而采用RST终止，称为终止释放，会丢弃排队的数据，不需要另一端响应，另一端会终止连接并通知当前连接已经被重置</li>
<li>未通知的半开连接：当未告知另一端的情况下一端关闭或者终止连接，TCP出于半开状态。当通信一方主机崩溃，只有不尝试通过半开连接传输数据，正常工作另一端不会检测出。而当服务器崩溃未通知重启时，收到半开连接对方的消息，由于丢失连接记忆，也有回应RST报文，关闭连接。当客户端崩溃时，收到服务器消息也同理</li>
</ul>
<p><strong>窗口大小</strong>用于流量控制，由于就16位，大小有限制，可以结合选项的窗口缩放选项进行放大，以适应高带宽情况</p>
<p><strong>TCP校验和</strong>，检测收到的数据是否正确，是保证可靠传输的重要一环，如果错误，直接丢弃该分组</p>
<p>紧急指针结合URG可以实现带外数据传输，和紧急传输</p>
<p><strong>TCP选项</strong></p>
<p>TCP头部包含多个选项，每一个选项头一个字节为种类，进行标识选项的类型。</p>
<ul>
<li><p><strong>最大段大小（MSS</strong>）：标识对方发送数据时能够使用的最大字段（TCP数据）</p>
<p>该字段与TCP的<strong>路径最大传输单元发现</strong>有关</p>
<p>路径最大传输单元发现：TCP为了避免分片，使用对外接口的MTU的最小值。在建立连接时，每一方会告知期待收到的MSS，如果对方没有指明MSS，己方默认发送536字节，设置DF字段。如果收到PTB（数据包过大消息），PTB中如果有推荐下一跳MTU，则使用，否则采用二分算法尝试多个数值（可能影响拥塞控制），直到满足。一定时间后，由于路由动态变化，会尝试一个更大值</p>
<p><strong>MTU=MSS+ TCP Header + IP Header</strong></p>
</li>
<li><p>**选择确认选项(SACK)**：保证重传时立即重传丢失部分</p>
<p>建立连接时建立，收到乱序的数据时，提供一个SACK选项来描述这些乱序数据，帮助对方有效重传，一般是SACK块保存已经收到的数据块序列号范围，在使用时间戳情况下，最大为3块（受选项大小和时间戳所限）</p>
<p>当接收方收到失序数据，第一个SACK块包含最近的收到的报文段范围（尽可能大）即失序数据，其它块填充按照接收顺序填充之前失序块，所以SACK块可以重复之前其他报文的块，具有备份、鲁棒性高。</p>
<p>发送方不仅记录积累的ACK信息，也记录接收到的SACK信息，以此来维护一个重传缓存，对相应的数据块标记SACKed，重发时跳过，最后根据优先级选择重传还是发送新数据（可以混合进行）</p>
<p>下图是一种可能的优先级示意图</p>
<p><img src="/images/image-20201215192546442.png" alt="image-20201215192546442"></p>
<p>由于SACK可能会变更，所以发送端不会根据SACK后立即情况重传缓存中数据，而是根据普通ACK号来清除。当重传计数器超时时，重传缓存中的数据块的SACKed标记需要清除，因为接收方可能已经异常。</p>
</li>
<li><p><strong>窗口缩放选项（WSOPT）</strong>：扩大窗口广告字段大小</p>
<p>正常窗口大小为16位，此选项可以扩大窗口广告字段大小到30位（1GB），在SYN报文中建立，与方向绑定，要双方响应有效。TCP用一个32位的值维护这个真实窗口的大小。</p>
<p>假设自己发送移动窗口数组为S，收到对方移动窗口数值为R：收到对方的16广告窗口左移R位得真实值，自己发送32位真实大小右移S为取16位填入TCP头部</p>
</li>
<li><p><strong>时间戳选项（TSOPT）</strong>：精确估计往返时间、防止绕回序列号</p>
<p>时间戳是一个单调增长的32位数值，使用该选项时，发送方发送自己时间戳做TSV部分，接收方将收到的时间戳做时间戳回显重试字段即TSER部分。</p>
<p>时间戳提供更多样本估计往返时间，此外，由于时间戳单调，序列号回绕时可以辨别</p>
<p>而一般，时间戳选项是默认开启的，下面是其具体作用详解</p>
<ul>
<li>时间戳测量RTT样本值:<ul>
<li>发送方每个发送报文的TSOPT的TSV部分携带发送时刻的TCP时钟值</li>
<li>接收方利用两个变量记录TSV和ACK号（LastACK）</li>
<li>如果发送方序列号等于LastACK，将TSV记录在变量中，变量并写入ACK的TSOPT的TSER部分</li>
<li>发送方收到ACK，利用当时TCP时钟值减去TSER即得新的RTT样本估计值</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h2><p><img src="/images/image-20201213144655277.png" alt="image-20201213144655277"></p>
<p>图中虚线是典型的服务器TCP状态转移，黑实线是典型的客户端TCP状态转移</p>
<p>状态解释：</p>
<ul>
<li>LISTEN：表示服务器的某个SOCKET处于监听状态，可以进行连接</li>
<li>SYN_SENT(客):客户端发送SYN，等待服务器发送ACK+SYN报文，一般是端口未打开或者中毒</li>
<li>SYN_RECV:服务器收到客户端发送的SYN报文，然后向客户端发送SYN+ACK报文，然后进入SYN_RECV状态</li>
<li>ESTABLISHED：表示连接已经建立</li>
<li>FIN_WAIT_1：客户端SOCKET想主动关闭连接，于是向服务器发送FIN报文，然后进入FIN_WAIT_1状态</li>
<li>FIN_WAIT_2：客户端收到服务器发来的ACK报文，此时客户端进入FIN_WAIT_2状态，此时客户端这边的连接已经关闭</li>
<li>CLOSING：双方刚好可能都在关闭连接</li>
<li>TIME_WAIT：收到了服务器发来的FIN报文，然后客户端发送ACK报文，等待2MSL之后进入CLOSED状态（等待客户端重新发送可能丢失的ACK报文）</li>
<li>CLOSE_WAIT:服务器收到客户端发来的FIN报文之后，发送ACK报文,随后服务器进入CLOSE_WAIT状态</li>
<li>LAST_ACK:向客户端发送FIN报文后，随即进入LAST_ACK状态，如果收到了客户端发来的ACK报文之后，就进入CLOSED状态</li>
</ul>
<p><strong>TCP建立连接和断开连接</strong></p>
<p><img src="/images/image-20201213145151710.png" alt="image-20201213145151710"></p>
<p>典型的三次握手和四次挥手即TCP建立连接阶段和断开连接阶段</p>
<p>建立连接过程：</p>
<p>一般SYN报文在此时会携带一些选项，交换信息，决定是否打开某个选项服务</p>
<p>除上述三次握手之外，如果双方同时打开，就需要发送4个报文段</p>
<p><img src="/images/image-20201213150711955.png" alt="image-20201213150711955"></p>
<p>双方先是进入SYN_SENT态，收到对方SYN后，发送SYN+ACK进入SYN_RECV态，等收到对方的SYN+ACK报文，再进入ESTABLISHED状态</p>
<p>建立连接过程中一方进程退出会导致连接失败（RST），当客户端在SYN_SENT超时也会导致连接失败</p>
<p>断开连接过程：</p>
<p>断开连接过程除常见的四次挥手也会有特殊情况</p>
<p>1.双方同时主动断开</p>
<p><img src="/images/image-20201213151423266.png" alt="image-20201213151423266"></p>
<p>双方同时发送FIN，先进入FIN_WAIT_1态,然后收到对方的FIN回复ACK进入CLOSING状态，等收到对方的ACK后进入TIME_WAIT态</p>
<p>2.被动关闭方收到FIN，直接发FIN+ACK</p>
<p>此时主动打开方会跳过FIN_WAIT_2，发送ACK，直接进入TIME_WAIT态</p>
<p><strong>半关闭状态</strong></p>
<p>仅关闭一条方向的数据流传输</p>
<p><strong>半开连接状态</strong></p>
<p>当未告知另一端的情况下一端关闭或者终止连接，TCP出于半开状态。当通信一方主机崩溃，只要不尝试通过半开连接传输数据，正常工作另一端不会检测出。此时崩溃方重启时，处于CLOSED态，收到对方消息，会发送RST报文关闭连接</p>
<p><strong>详解TIME_WAIT态</strong></p>
<p>TIME_WAIT也叫2MSL等待状态，客户端在此将会等待2倍最大段生存期，MSL是IP数据报在因特网中存活的最长时间。原因有以下几点：</p>
<ul>
<li>确保可靠终止，防止ACK丢失：注意细节是重发ACK不是TCP重传ACK（不消耗序列号，也不会被重传），而是另一方重传FIN</li>
<li>让老的重复分节（数据报）在网络中消逝：处于这个状态，通信双方的四元组定义为不可重新使用，不能再建立新的连接，不可使用处于2MSL的端口号的，否则假定原先的连接中还有数据报残存在网络之中，这样新的连接建立以后传输的数据极有可能就是原先的连接的数据报。</li>
</ul>
<p>对于上面不可使用处于2MSL的端口号的约束，可以会被绕开，如果新的连接初始序列号比之前最高的序列号还高或者开启时间戳选项可以辨别时是可以建立连接的，充分相信其不会和之前的报文段混淆，即使在TIME_WAIT段也可以允许新的连接到达</p>
<p>处于TIME_WAIT态，任何延迟到达的报文都被丢弃，但是会发送ACK，如果收到老报文，发送ACK给已经CLOSED的服务端，服务端会发送RET报文，加速客户端关闭</p>
<h1 id="TCP超时与重传"><a href="#TCP超时与重传" class="headerlink" title="TCP超时与重传"></a>TCP超时与重传</h1><p>TCP拥有两套重传操作，分别是基于时间、确认信息</p>
<h2 id="1-基于时间的重传"><a href="#1-基于时间的重传" class="headerlink" title="1.基于时间的重传"></a><strong>1.基于时间的重传</strong></h2><p>基于时间的重传在发送方发送数据时会启动一个计数器，如果超过时限没有收到确认就会触发重传。</p>
<p>其关键在于计时超时RTO的确认</p>
<p><strong>RTO确定</strong></p>
<p>由于TCP工作环境是动态的，需要动态设置RTO</p>
<p>下面是一些方法演变</p>
<p>以下RTT表示新的RTT样本值</p>
<ul>
<li><p>经典方法：</p>
<p>计算平滑的SRTT，再利用一个因子估计RTO，无法面对RTT变化大的情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SRTT &#x3D; ( ALPHA * SRTT ) + ((1-ALPHA) * RTT)</span><br><span class="line">RTO &#x3D; min[UBOUND,max[LBOUND,(BETA*SRTT)]]</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p>标准方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SRTT &#x3D; (1 - alpha) * SRTT + alpha * R&#39;</span><br><span class="line">RTTVAR &#x3D; (1 - beta) * RTTVAR + beta * |SRTT - R&#39;|</span><br><span class="line">RTO &#x3D; SRTT + max (G, K*RTTVAR)</span><br><span class="line">&#x2F;&#x2F; 或便于迭代形式</span><br><span class="line">Err &#x3D; RTT - SRTT</span><br><span class="line">SRTT &#x3D; SRTT + gErr</span><br><span class="line">RTTVAR &#x3D; RTTVAR + h(|Err| - RTTVAR)</span><br><span class="line">RTO &#x3D; SRTT + max (G, K*RTTVAR)</span><br><span class="line">K一般为4</span><br></pre></td></tr></table></figure>
<p>该方法利用平滑的SRTT和平滑偏差RTTVAR计算RTO，能适应RTT变化情况，但是在RTT大幅下降和时钟粒度过细时效果不好</p>
</li>
<li><p>Linux方法</p>
<p>标准方法主要有两个问题：1、RTT测量频繁、时钟粒度过细时，RTTVAR随时间减少为最小。 2、由于RTTVAR比重大，RTT大幅下降反而RTO上升</p>
<p>Linux时钟粒度很细，其特别设置RTO方法可以解决上述两个问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">记medv &#x3D; RTTVAR</span><br><span class="line">medv_max &#x3D; 出现medv最大值</span><br><span class="line">然后利用medv_max来更新RTO避免RTTVAR（medv）趋于最小</span><br><span class="line">再利用(SRTT - medv)作为RTT的估计范围下降，在RTT大幅下降时降低其对RTTVAR（medv）的影响，避免RTO增大</span><br><span class="line">if(RTT &lt; (SRTT - medv))</span><br><span class="line">medv &#x3D; (31&#x2F;32)*medv +1&#x2F;32 * Err</span><br><span class="line">else</span><br><span class="line">medv &#x3D; (3&#x2F;4)*medv +1&#x2F;4 * Err</span><br></pre></td></tr></table></figure>
<p>其中medv_max 不小于50ms，RTO也就不小于200ms</p>
</li>
<li><p>Karn算法</p>
<p>一个包出现重传后，不确定其收到的ACK对应哪个包也就不好计算RTT，此外重传二义性</p>
<p>Karn算法，不用重传时的RTT样本数据即排除二义性数据计算SRTT（RTO），并且设置一个退避系数，每当RTO超时时系数加倍，直到收到非重传数据系数设为正常值1</p>
<p>即RTO = kRTO</p>
</li>
</ul>
<p>最后强调两个点：</p>
<ul>
<li><p><strong>关于RTT的计算</strong>：RTT计算有两种方法：</p>
<ul>
<li><p>利用时间戳计算（RTTM）</p>
<p>在上文有所描述</p>
<p>RTT=当前时钟- 数据包中Timestamp选项的回显时间</p>
</li>
<li><p>利用重传队列中数据包的TCP控制块</p>
<p>在TCP重传队列中保存着发送而未被确认的数据包，数据包skb中的TCP控制块包含着一个变量，tcp_skb_cb-&gt;when，记录了该数据包的第一次发送时间。</p>
<p>当收到确认时</p>
<p>RTT = 当时时钟 - when</p>
</li>
</ul>
<p>综上，可以深入理解karn算法中第一部分要排除重传二义性的数据，因为用第二种计算方法不知道ACK是真的新还是就数据包，而使用时间戳计算RTT时就没有这个问题</p>
<p>一般Linux、近期Windows都默认启用时间戳选项（10字节），因为时间戳选项使发送方在丢包、延时、失序情况下也能测量RTT，此外其在处理失序、成功重传时具有鲁棒性</p>
</li>
<li><p><strong>关于RTO初始化问题</strong></p>
<p>在首个SYN交换前，TCP无法设置RTO初始值，当收到首个RTT后用下式估计</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SRTT &#x3D; RTT</span><br><span class="line">RTTVAR &#x3D; RTT &#x2F; 2</span><br></pre></td></tr></table></figure>
<p>时间上计时器超时重传不是必要的，由于RTO一般大于RTT，基于计时器的重传会导致网络利用率下降。</p>
</li>
</ul>
<h2 id="2-快速重传"><a href="#2-快速重传" class="headerlink" title="2.快速重传"></a><strong>2.快速重传</strong></h2><p>我们知道TCP对失序报文段具有重复ACK的机制</p>
<p>快速重传算法基于此机制：</p>
<p>当重复ACK到达一定阈值时，很有可能包已经丢失（再有小概率原因是延时达到），通常这个阈值是3。当达到阈值时，可以不用等到计时器超时重传可能丢失的包（也可以同时发送新数据！）：这里不采用SACK，收到有效ACK前至多重传一个报文段，采用SACK可以多个</p>
<ul>
<li><p><strong>基本快速重传算法</strong></p>
<p>重传+NewReno算法，如果是Reno算法，没有部分ACK的概念</p>
</li>
<li><p><strong>带选择确认的重传</strong></p>
<p>重传+SACK算法</p>
</li>
</ul>
<h2 id="3-伪重传问题"><a href="#3-伪重传问题" class="headerlink" title="3.伪重传问题"></a><strong>3.伪重传问题</strong></h2><p>称没有数据丢失引发的重传为伪重传，主要原因有伪超时、失序、包重复、ACK丢失</p>
<ul>
<li><p><strong>伪超时</strong></p>
<p>下图序列号和ACK号都基于包而非字节来表示，并且ACK号表示已接收到的包，而非期望接收的下一个包</p>
<p><img src="/images/image-20201215185024659.png" alt="image-20201215185024659"></p>
<p>这导致TCP出现了“回退N”的行为模式，并产生了更多的“重复ACK”返回发送端，这时就可能会触发快速重传</p>
<p>所以针对于超时，我们需要检测某个超时引起的重传是否真实，如果是伪超时，需要撤销或者减轻此超时带来的影响，而避免出现上图等行为。</p>
<p>下面是一些检测算法</p>
<ul>
<li><p><strong>重复SACK（DSACK）</strong></p>
<p>只要允许SACK中的序列号小于累计ACK，就可以实现DSACK。此时只要接收方收到重复的分段，也认为是失序，就会将其记录发送加入到SACK选项中，即DSACK，这时发送方比较如果累积ACK大于其选项值，就知道自己发送了重复分段。</p>
<p>DSACK的信息只包含在单个ACK中，不会在通常的SACK信息中重复，鲁棒性较SACK低。</p>
<p>如上图的伪超时、伪重传，其可以在发送一个重复分段并收到其返回DSACK（ACK）后，才能判决，所以也叫迟伪超时，不好避免后退N行为</p>
</li>
<li><p><strong>Eifel检测算法</strong></p>
<p>该方法基于时间戳选项，当发送超时重传数据后等待下一个ACK，若是针对于前一次传输的ACK，可以认为该重传是伪重传，此方法针对个别ACK丢失也有很好的鲁棒性</p>
<p>此方法比DSACK能更早检测到伪重传行为，能避免后退N</p>
</li>
<li><p><strong>前移RTO恢复（F-RTO）</strong></p>
<p>该方法是检测伪超时引起的伪重传的标准方法，不需要任何TCP选项</p>
<p>其修改TCP行为，在超时重传后收到第一个ACK时，发送新数据，响应一个ACK，如果两个ACK不重复，说明是伪重传</p>
<p>此方法也比DSACK能更早检测到伪重传行为，能避免后退N</p>
</li>
</ul>
<p>实际上上诉算法前者被被称为迟伪超时，后两者就称为伪超时。</p>
<p>前文对正常超时有karn算法，而如果是伪超时，也会有特殊的响应算法，即Efiel响应算法</p>
<p>此算法针对于检测出伪超时，通过将下一个要发送的报文段（SND.NXT）的序列号改为最新未发送过的报文段(SND.MAX)，避免了后退N，对于检测到一次迟伪超时，不改变SND.NXT。上面两种情况都会在收到重传报文的ACK后，以不同与前文的方式重设SRTT、RTTVAR、RTO的值，这时一般是居于新的RTT样本值是否较大判断是否重设</p>
</li>
<li><p>包失序</p>
<p>出现包失序的原因主要在于IP层不保证包传输有序进行，失序问题可能会出现在TCP连接的正向链路或者反向链路中</p>
<p>失序在反向链路中可能由于ACK引起发送端窗口快速前移，出现不必要的流量突然</p>
<p>失序出现在正向链路中，就会有了前文中无法确认是失序还是丢包，也就可能会引起伪重传</p>
<p>一般设置一个dupthresh，尽量避免伪重传，这也是快速重传的根据，一般设置为3就可以避免轻微的失序，Linux还可以动态调整dupthresh应对严重失序</p>
</li>
<li><p>包重复</p>
<p>包重复一般是由链路层网络协议执行重传时生成多个副本导致</p>
<p>当重复副本过多就会导致伪重传</p>
<p>利用SACK特别是DSACK可以防止此类伪重传</p>
</li>
</ul>
<h1 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h1><p>交互式TCP连接：传输按键操作、短消息、鼠标动作之类的小数据段用户数据，多用于远程登录、网络游戏</p>
<p>批量式TCP连接：传输较大的数据段、大批量数据。如Web、文件共享、备份、电子邮件等</p>
<p>后者通常占用了90%的TCP流量。</p>
<p>针对于两种不同的连接，有不同的处理手段</p>
<p><strong>延时确认ACK</strong>一般用于批量式数据传输，一般是2:1，减少网络负载</p>
<p>对于交互式数据传输，则采用<strong>Nagle算法</strong>当一个TCP连接有在传数据时，小的报文段就不能发送（小于SMSS），直到所有在传数据都收到ACK后，将收集到的小数据整合发送，类似于停等规程。该算法使得传输的包的数目减少，但是传输时延增大。一般不适合用在时延要求小的交互式应用。</p>
<p>如果结合累计确认和Nagle算法，很有可能造成一定程度死锁，影响性能，直到延时ACK计时器超时。下面SWS避免就有结合累计确认和Nagle算法。当然可以选择禁用Nagle算法</p>
<p><strong>流量控制和窗口管理</strong></p>
<p>TCP是通过滑动窗口来进行流量控制的，下面是滑动窗口结构</p>
<p>发送端：</p>
<p><img src="/images/image-20201216105630851.png" alt="image-20201216105630851"></p>
<p>一般窗口有三个动作</p>
<ul>
<li>关闭:窗口左边界右移，与收到ACK有关</li>
<li>打开：窗口右边界右移，与接收端可用缓存有关</li>
<li>收缩：窗口右边界左移，不支持做法，TCP需能够对其进行处理</li>
</ul>
<p>接收端：</p>
<p><img src="/images/image-20201216105657740.png" alt="image-20201216105657740"></p>
<p>对于接收端，只有当达到序列号等于RCV.NEXT时，数据不会被丢弃，窗口才能向前滑动，对于带SACK选项的TCP，还可以接收窗口内其他报文</p>
<p>下面将对窗口出现的几种特殊情况进行处理</p>
<ul>
<li><p><strong>零窗口</strong>：可知发送方的提供窗口由接收端的通告窗口控制，当其为0时，有效阻止发送方发送数据。当其可用时会再发送给发送端传输一个窗口更新。</p>
<p>但这个窗口更新一般是纯ACK，不可重传，为了避免该ACK丢失后的双方等待死锁，发送端会采用一个持续计时器间歇查询接收端(发<strong>送方发送窗口探测的传输</strong>)，看其窗口是否增长（强制要求接收端返回ACK），该间歇的时间与Karn算法类似（实际就是窗口探测报文的重传）。但是注意，窗口探测报文段含一个字节的数据，接收端缓存空间不够不一定会接收。</p>
</li>
<li><p><strong>糊涂窗口综合症</strong></p>
<p>Silly Window Syndrome（SWS），即交换数据段不是全长而是较小的数据段</p>
<p>可以采用以下约定避免</p>
<p>对于接收端：要求窗口更新通告大小需要为一个接收端MSS|接收端缓存窗口的一半，否则不能通告比当前窗 </p>
<p>口更大的窗口值</p>
<p>对于发送端：对于发送端报文段，一般用Nagle算法控制：全长MSS或者满足接收端通告过窗口最大值的一半          可以发送。对于Nagle算法，还注意其有个条件，如果没有未经确认的在传数据，显然无论大 小也可以发送 。如果Nagle算法被禁用，自然也能发送</p>
<p>对于SWS避免有一个细节，通告比当前窗口大的值时有约束条件，但是如果窗口是减小情况没有约束条件，这是避免发送端窗口收缩的优先级高于SWS避免</p>
</li>
<li><p><strong>大容量缓存与自动调优</strong></p>
<p>由上可知，当接收方缓存空间本身就小时，TCP吞吐性能会差，一般要求接收端缓存取一较大固定值，哪怕发送端指定较小值，也要忽略。</p>
<p>为了达到最大可用吞吐率，提出自动调优的方法，动态估计该连接的在传数据值（连接的带宽延时积），通告窗口不得小于此值（此处与拥塞控制有联系），自动调优，避免提前在接收发送端设置过大缓存。</p>
<p>在Windows系统中，默认自动设置接收端缓存大小，Linux较新版本默认支持自动调优</p>
</li>
</ul>
<h1 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h1><p>拥塞是指路由器无法处理高速率到达的流量而被迫丢弃数据信息</p>
<p>对于TCP发送方，没有精确的方法可以知道路由器状态，典型的TCP就用丢包来衡量拥塞状态，此外还有时延测量和显式拥塞通知可以在丢包前检测拥塞。</p>
<p>当知道处于拥塞时，就需要减缓TCP传输，前面有接收端通知窗口大小(awnd)通过接受速率来调节发送速率，考虑到网络传输能力，可以引入一个反应网络传输能力的拥塞窗口（cwnd），发送端实际可用窗口<code>W=min(cwnd,awnd)</code></p>
<p>为使TCP达到最大可用吞吐率，期待W接近带宽时延积（BDP），为RTT和链路最小通行速率的乘积，所以前面自动调优的awnd不能小于这个值（接收端缓存足够）</p>
<h2 id="1-cwnd的确定（基于丢包）"><a href="#1-cwnd的确定（基于丢包）" class="headerlink" title="1.cwnd的确定（基于丢包）"></a><strong>1.cwnd的确定（基于丢包）</strong></h2><p>一般获取cwnd最佳值的唯一方法是以越来越快的速率不断发送数据，直到出现数据包丢失，在不同阶段获取cwnd的方式有所不同</p>
<p>通常在传输初始阶段，由于未知网络传输能力，需要缓慢探测可用传输资源，防止大量数据注入导致拥塞，到达一定条件后使用其他算法</p>
<p><strong>慢启动</strong></p>
<p>在TCP连接建立阶段、或检测到重传超时导致的丢包时，执行慢启动算法。甚至发送端长时间处于空闲状态（即cwnd不能精确反应当前网络拥塞状态）也可能调用慢启动算法。</p>
<p>一般SYN交换之后，TCP发送一定大小的初始窗口（IW，IW一般较小，远比awnd小，这就是慢启动的由来）开始慢启动，之后假设没有丢包，每个数据包会有一个相应ACK，每收到一个好的ACK（大于之前ACK），慢启动算法会以<code>min(N,SMSS)</code>来增加cwnd的值，其中N为好的ACK能确定字节数，SMSS为发送方最大段大小。</p>
<p>于是在没有ACK延时的时候，意味着每收到一个好的ACK可以发两个新包，所以每一个RTT发送窗口随时间指数增长。如果ACK延时，也是指数增长，但是增长速度更慢，所以有的TCP连接会在慢启动阶段采用快速ACK，完成之后采用延迟ACK。</p>
<p><strong>拥塞避免</strong></p>
<p>慢启动一个RTT随指数增长，当awnd较大时，W由cwnd决定，可能cwnd突然翻倍之后，网络直接瘫痪，所以会采用一个阈值，当大于这个阈值之后，采用别的算法。</p>
<p>这个阈值称为慢启动阈值（ssthresh），记录没有丢包情况下，上一次最好的操作窗口估计值，即TCP最优窗口估计值的下界，当有重传现象发生<code>ssthresh=max(在外数据值（或者当前W）/ 2,2*SMSS)</code>,。至于为什么是W/2，为了达到最高的网络利用率，我们希望A和B之间的缓存(包括节点队列以及网络本身)中完全充盈着TCP的数据段，并且是持续维持，假设这个缓存数量为N，发送速率为r，发送端每发送一个数据段，接收端同时也会消费掉一个数据段，同时发出一个ACK，直到填满A，B间网络的那个数据段的ACK到达发送端为止，依照假定，ACK的速率和数据段的速率一致，则一个RTT内有<code>2N = r*RTT</code>,显然N没有被填满时，有空闲空间可以缓存，N被填满后，一旦拥塞，数据必丢失，而这个N值就是慢启动阈值，小于这个阈值时，采用慢启动可以激进的增加cwnd，一个ACK一个SMSS，大于这个阈值后，则需谨慎，一个窗口的ACK才增加一个SMSS即拥塞避免。</p>
<p>这里采用别的算法即拥塞避免算法，每收到一个ACK只增大SMSS/cwnd个SMSS大小的窗口，随时间呈线性增长。</p>
<p>拥塞控制算法假设有比特错误引起的丢包率很小，所有一旦丢包，则认为出现拥塞，故在无限网络中没有拥塞也传输很慢。此外慢启动和拥塞避免的cwnd的增大与RTT关系很大，在RTT较大时，可能网络资源得不到充分利用</p>
<p><strong>Tahoe算法</strong></p>
<p>连接之初慢启动，一旦丢包（超时或者快重）也是慢启动，并把cwnd设置为初始值，ssthresh设置为当前窗口值一半。</p>
<p>总结具有慢启动、快重传、拥塞避免</p>
<p><strong>Reno算法（几近于标准TCP）</strong></p>
<p>相较与Tahoe，多了一个快速回复阶段，当快速重传时，ssthresh设置和之前一致，而将cwnd设置为ssthresh+3SMSS，之后每收到一个重复ACK将cwnd临时增加1SMSS，直到收到好的ACK，再将ACK设置为ssthresh，进入拥塞避免，这就是快速恢复。</p>
<p>标准TCP<code>ssthresh大于max(在外数据值（或者当前W）/ 2,2*SMSS)</code>其他与Reno一致</p>
<p>总结有慢启动、快重传、快速恢复、拥塞避免</p>
<p><strong>NewReno算法</strong></p>
<p>Reno的快速恢复有一个问题，当有多个包丢失时，可能快速重传一个包收到好的ACK窗口膨胀停止，而其他丢失数据未必重传，之后可能会触发快速重传，导致ssthresh和cwnd再次下降；又或者是在传数据没有足够的ACK触发快速重传，导致重传计时器超时，进入慢启动。这两者操作都会影响网络吞吐性能。</p>
<p>我们称这种好的ACK为部分ACK（PACK），再定义上一个数据传输窗口的最大序列号，记为恢复点，当收到好的ACK小于恢复点ACK时（RACK），不会结束快速恢复阶段。在此种情况下，重传第一个没有确认的数据段。按确认的新数据量来减小拥塞窗口，如果这个部分确认确认了至少一个MSS的新数据，则加回一个MSS。如果cwnd的新值允许的话，发送一个新数据段</p>
<p>总结有慢启动、快重传、改进的快速恢复、拥塞避免</p>
<p><strong>SACK算法</strong></p>
<p>缺乏SACK算法时发送端只能选择两种恢复策略：</p>
<ol>
<li>每一个RTT时间内至多重传一个丢弃的包  (Reno和New Reno)</li>
<li>重传所有包，其中包括可能已经正确发送的包。  (Tahoe)</li>
</ol>
<p>TCP SACK在TCP Reno基础上增加了选择确认和选择重传，其快速重传时cwnd和ssthresh设置同Reno，但是随着快速恢复阶段cwnd的膨胀，发送方可以发送更多数据，此时理论上可以重传多个丢失包，即时重传。</p>
<p>但是如果短时间向网络注入大量数据可能起不到拥塞控制效果，显然恢复阶段只用cwnd作为发送方滑动窗口界限不够。这时可以采用一个pipe记录注入网络的数据量，假设awnd较大，W与cwnd有关，只要<code>cwnd - pipe &gt;= SMSS</code>任何时候SACK TCP均可发送数据。</p>
<p><strong>一些改进</strong></p>
<ul>
<li><p><strong>限制传输</strong>：目的在于使TCP能在更小的窗口下工作。Reno三次重复ACK才能触发快速重传/恢复机制，当窗口较小时可能不能触发，此时采用限制传输策略：TCP发送方每接收两个连续的重复ACK，就能发送一个新数据包，避免了长时间等待RTO超时而导致吞吐性能下降。限制传输在Linux中默认开启</p>
</li>
<li><p><strong>拥塞窗口校验（CWV）：</strong>如果发送方长期不发送数据（如发送端空闲，或者是应用受限），那cwnd也不会及时更新，可能不能准确反映当前网络的拥塞状况，这时可以采用CWV，用ssthresh记录之前的cwnd的记忆，再让cwnd随时间衰减。具体原理如下，需要发送新数据时，距离上次操作超过一个RTO空闲后：</p>
<ul>
<li><code>ssthresh = max（ssthresh，3/4cwnd）</code></li>
<li>对于发送端空闲，每一个RTT，<code>cwnd = 1/2cwnd</code></li>
<li>如果是应用受限，<code>cwnd = （已用窗口大小 + cwnd）/2</code></li>
</ul>
<p>一般在发送方长时间暂停后会进入慢启动阶段，Linux默认开启CWV</p>
</li>
<li><p><strong>拥塞窗口缩减（CWR）：</strong>一般出现本地拥塞或者受到ECE置位的ACK，发送端会进入CWR状态，在此阶段，先将ssthresh减半，之后发送方每收到两个ACK就将cwnd减一，直到cwnd到达新的ssthresh的值或者出现丢包。</p>
</li>
</ul>
<p><strong>Eifel响应算法</strong></p>
<p>如果出现伪超时引起的重传，前面讲诉了RTO的操作，以及防止后退的措施：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">此算法针对于检测出伪超时,通过将下一个要发送的报文段（SND.NXT）的序列号改为最新未发送过的报文段(SND.MAX)，避免了后退N，对于检测到一次迟伪超时，不改变SND.NXT。上面两种情况都会在收到重传报文的ACK后，以不同与前文的方式重设SRTT、RTTVAR、RTO的值，这时一般是居于新的RTT样本值是否较大判断是否重设</span><br></pre></td></tr></table></figure>
<p>这里讲诉其关于拥塞控制的反应</p>
<p>对于RTO超时，ssthresh会修改，并用pipe_prev = min(pipe,ssthresh)记录之前的ssthresh，并运行之前提到的检测算法</p>
<p>如果确定是伪超时，则达到第一个ACK后执行以下操作：</p>
<ul>
<li><p>若接收包含ECN-Echo标志位好的ACK，停止操作，避免引入不安全元素，否则：</p>
</li>
<li><p>cwnd = pipe + min(bytes_acked,IW),即运行不超过IW的新数据进入管道</p>
</li>
<li><p>ssthresh = pipe_prev ，撤销之前更改。</p>
</li>
</ul>
<h2 id="2-拥塞控制状态转换"><a href="#2-拥塞控制状态转换" class="headerlink" title="2.拥塞控制状态转换"></a>2.<strong>拥塞控制状态转换</strong></h2><p>前面介绍各种算法后，需了解拥塞控制的状态是如何转换的</p>
<p><img src="/images/image-20201225102319804.png" alt="image-20201225102319804"></p>
<ul>
<li>Open状态是拥塞控制状态机的默认状态。这种状态下，当ACK到达时，发送方根据拥塞窗口cwnd(Congestion Window)是小于还是大于慢启动阈值ssthresh(slow start threshold)，来按照慢启动或者拥塞避免算法来调整拥塞窗口。</li>
<li>当发送方检测到DACK(重复确认)或者SACK(选择性确认)时，状态机将转变为Disorder状态。在此状态下，数据包的到达会触发新数据传输，也即限制传输、速率减半。</li>
<li>当发送方接收到足够的DACK(重复确认)后，进入该状态。在该状态下，拥塞窗口cnwd每收到两个ACK就减少一个段，直到cwnd等于慢启动阈值ssthresh</li>
<li>一般出现本地拥塞或者受到ECE置位的ACK，发送端会进入CWR状态，在此阶段，先将ssthresh减半，之后发送方每收到两个ACK就将cwnd减一，直到cwnd到达新的ssthresh的值或者出现丢包。</li>
<li>当一个RTO(重传超时时间)到期后，发送方进入Loss状态。所有正在发送的数据标记为丢失，拥塞窗口cwnd设置为一个段发送方再次以慢启动算法增大拥塞窗口cwnd。Loss 和 Recovery 状态的区别是:Loss状态下，拥塞窗口在发送方设置为一个段后增大，而 Recovery 状态下，拥塞窗口只能被减小。Loss 状态不能被其他的状态中断，因此，发送方只有在所有 Loss 开始时正在传输的数据都得到成功确认后，才能退到 Open 状态。</li>
</ul>
<h2 id="3-基于延迟的cwnd"><a href="#3-基于延迟的cwnd" class="headerlink" title="3.基于延迟的cwnd"></a><strong>3.基于延迟的cwnd</strong></h2><p>通过检测RTT变化来判断是否拥塞，将不断增长的RTT作为拥塞形成的信号。</p>
<p><strong>Vegas算法</strong></p>
<p>经典的Vegas算法的基本思路：RTT增加，拥塞窗口减小；RTT减少，拥塞窗口变大。</p>
<p>Vegas通过比较实际吞吐量和期望吞吐量来调节拥塞窗口的大小。</p>
<p>期望吞吐量：Expected=cwmd/BaseRTT</p>
<p>实际吞吐量：Actual=cwnd/RTT</p>
<p>计算差值：diff=（Expected-Actual）*BaseRTT</p>
<p>BaseRTT是所有观测来回响应时间的最小值，一般是建立连接后所发的第一个数据包的RTT。</p>
<p>定义阈值a、b，当diff &lt; a,拥塞窗口增大，+1;当diff&gt;b，拥塞窗口缩小，-1;当a&lt;=diff&lt;=b,拥塞窗口不变。通常a=1，b=3，意味着该连接至少保留一个包在队列中。</p>
<p>由将上述方法用于慢启动：慢启动时，Vegas每经过两个RTT使cwnd拥塞窗口增加1倍。然后计算diff，当diff&gt;a,则结束慢启动，转入拥塞避免。这种慢启动事实严重降低了传输速率。</p>
<p>Vagas算法很容易受到反方向的拥塞的影响减小窗口大小。此外，由于一旦发生时延，Vegas算法可能就减小cwnd，所以其在和标准TCP算法竞争时是不公平的，标准TCP想填满网络中等待队列，而Vegas想让其保持空闲</p>
<p><strong>Westwood算法</strong></p>
<p>类似于Vegas，发送端维护一合格速率估计值，对连接中可用带宽进行估计（ERE，<code>单位时间分组数目*分组大小</code>），当出现丢包时，不会将cwnd减半，而是用估计的BDP值（观察到最小<code>RTT*ERE</code>）作为ssthresh值。</p>
<p>此外其比Vegas的慢启动也有所改变，其会反复设置ssthresh值，当ssthresh增长时，cwnd会指数增长</p>
<h2 id="4-ECN-积极队列管理"><a href="#4-ECN-积极队列管理" class="headerlink" title="4.ECN+积极队列管理"></a><strong>4.ECN+积极队列管理</strong></h2><p>传统路由采用FIFO+尾部丢弃处理，如果路由不采用上诉管理方式，我们认为路由采用了积极队列管理（AQM），若此时能将路由器和交换机的状态传输给端系统来实现AQM，就可以对经过路由器的数据包进行标记，以此得到拥塞状态，即显示拥塞通知（ECN）</p>
<p>当路由队列管理采用随机早期检测（RED）机制时，可以探测拥塞情况的发送，并控制数据包标记，当数据包被接收，如果其被拥塞标记了，接收端向发送端返回一个ACK数据包来通知拥塞情况。</p>
<p>整个ECN过程如下：</p>
<p>当包含ECN功能的路由器拥塞时，收到一个Ip数据包，检测IP头部ECN传输能力（ECT）标识是否置位，如果有效，传输层协议将开启ECN功能，路由器在IP头设置已发生拥塞（CE）标识。如果接收端收到数据包CE被置位，将ECE置位，接收端收到之后，将CWR置位，并进入CWR阶段。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指12-矩阵中的路径</title>
    <url>/2021/02/19/%E5%89%91%E6%8C%8712-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<p><strong>剑指 Offer 12. 矩阵中的路径</strong></p>
<p><a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/">力扣链接</a></p>
<a id="more"></a>

<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</p>
<p>[[“a”,”<strong>b</strong>“,”c”,”e”],<br>[“s”,”<strong>f</strong>“,”<strong>c</strong>“,”s”],<br>[“a”,”d”,”<strong>e</strong>“,”e”]]</p>
<p>但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：board &#x3D; [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word &#x3D; &quot;ABCCED&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：board &#x3D; [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]], word &#x3D; &quot;abcd&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= board.length &lt;= 200</code></li>
<li><code>1 &lt;= board[i].length &lt;= 200</code></li>
</ul>
<h1 id="思路：回溯法"><a href="#思路：回溯法" class="headerlink" title="思路：回溯法"></a>思路：回溯法</h1><p>由于不能再次进入格子，所以需要标记这个格子是否已经进入过，，又由于不同的起点不一定，又需要我们复原格子情况，是典型的回溯题目。</p>
<p>回溯题目一般都是用dfs+回溯来解决，假如在<code>board[i][j] </code>位置上，我们可以在二维数组上的上下左右进行寻找,直到找到相同字符串或者无法找下去（剪枝），注意剪枝即可，下面是其大概的模板</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dfs(状态参数)&#123;</span><br><span class="line">    <span class="keyword">if</span>(判断是否满足条件或者符合边界条件)&#123;</span><br><span class="line">        其他操作（记录打印）</span><br><span class="line">        <span class="keyword">return</span> ...;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(判断是否可以进入下一步深度搜索(也是剪枝，情况多用))&#123;</span><br><span class="line">        改变状态</span><br><span class="line">        dfs(下一步参数)</span><br><span class="line">        回溯状态   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是本题代码，大致按照上诉模板写的，思路比较清晰但可以优化去除一些冗余部分这里就不再做修改了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[][] b;</span><br><span class="line">    <span class="keyword">char</span>[] chars;</span><br><span class="line">    <span class="keyword">boolean</span>[][] isused;</span><br><span class="line">    <span class="keyword">int</span>[] x = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] y = &#123;<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        b = board;</span><br><span class="line">        chars = word.toCharArray();</span><br><span class="line">         n = b.length;</span><br><span class="line">         m = b[<span class="number">0</span>].length;</span><br><span class="line">        isused = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][m];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)&#123;</span><br><span class="line">                 <span class="keyword">if</span>(chars[<span class="number">0</span>] == b[i][j])</span><br><span class="line">                 &#123;</span><br><span class="line">                     isused[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                     <span class="keyword">if</span>(memorySearch(i,j,<span class="number">1</span>))</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    isused[i][j] = <span class="keyword">false</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">memorySearch</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == chars.length)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++)&#123;</span><br><span class="line">            <span class="keyword">int</span> xi = x[k] + i;</span><br><span class="line">            <span class="keyword">int</span> yi = y[k] + j;</span><br><span class="line">     </span><br><span class="line">            <span class="keyword">if</span>((<span class="number">0</span> &lt;= xi &amp;&amp; xi &lt; n) &amp;&amp; (<span class="number">0</span> &lt;= yi &amp;&amp; yi &lt; m) )&#123;</span><br><span class="line">           </span><br><span class="line">                <span class="keyword">if</span>(chars[index] == b[xi][yi] &amp;&amp; !isused[xi][yi])&#123;</span><br><span class="line">                isused[xi][yi] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(memorySearch(xi,yi,index + <span class="number">1</span>))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                isused[xi][yi] = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>回溯题目大多套路化，关键点有几个：用dfs搜寻、用一个数据结构保存遍历状态、用严格地判断条件作为剪枝即可</p>
]]></content>
      <categories>
        <category>剑指Offer</category>
        <category>算法</category>
        <category>回溯</category>
      </categories>
      <tags>
        <tag>回溯</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>流</title>
    <url>/2021/02/01/%E6%B5%81/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>剑指13-机器人的运动范围</title>
    <url>/2021/02/19/%E5%89%91%E6%8C%8713-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</url>
    <content><![CDATA[<p><strong>剑指 Offer 13. 机器人的运动范围</strong></p>
<p><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">力扣链接</a></p>
<a id="more"></a>

<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>地上有一个m行n列的方格，从坐标 <code>[0,0]</code> 到坐标 <code>[m-1,n-1]</code> 。一个机器人从坐标 <code>[0, 0] </code>的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：m &#x3D; 2, n &#x3D; 3, k &#x3D; 1</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：m &#x3D; 3, n &#x3D; 1, k &#x3D; 0</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n,m &lt;= 100</code></li>
<li><code>0 &lt;= k &lt;= 20</code></li>
</ul>
<h1 id="思路一：dfs"><a href="#思路一：dfs" class="headerlink" title="思路一：dfs"></a>思路一：dfs</h1><p>题目有一个起点是（0，0），我们可以从这个点出发向下或者向右遍历（可以保证能够遍历到所有的点，简化了题目）</p>
<ul>
<li>如果向下或向右的点符合可以进入，又从该点开始向下、向右遍历</li>
<li>不可进入，则此路不通该方向的遍历结束</li>
</ul>
<p>上诉是典型的深度优先搜索思路，最后，为了防止重复进入格子，我们用一个二维boolean数组标记状态，下面是具体代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span>[][] ismoved;</span><br><span class="line">    <span class="keyword">int</span> m,n,k;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ismoved = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">this</span>.m = m;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">        <span class="keyword">this</span>.k = k;</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &gt;= m || y &gt;= n)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span>(ismoved[x][y])</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span>(x % <span class="number">10</span> + x / <span class="number">10</span> + y % <span class="number">10</span> + y / <span class="number">10</span> &gt; k)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        count++;</span><br><span class="line">        ismoved[x][y] = <span class="keyword">true</span>;</span><br><span class="line">        dfs(x + <span class="number">1</span>,y);<span class="comment">// 向右遍历</span></span><br><span class="line">        dfs(x,y + <span class="number">1</span>);<span class="comment">// 向下遍历</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在力扣上运行时间0ms</p>
<h1 id="思路二：bfs"><a href="#思路二：bfs" class="headerlink" title="思路二：bfs"></a>思路二：bfs</h1><p>广度优先搜索也是一种遍历方式，也是从起点出发，区别在于其主要每一次都把改点附近能行的格子统计完了才到下一点</p>
<ul>
<li>搜寻向下和向右的格子，可以进入的加入队列</li>
<li>弹出队列中元素执行上一步操作，直到队列为空退出循环</li>
</ul>
<p>dfs靠的是递归，bfs靠的更像是循环</p>
<p>在这里，为了让队列简单的保存一个点的坐标信息，使用了一个小技巧对一个点的坐标进行映射，即用<code>x*x,y的最大范围 + y</code>只用一个int就能记录坐标信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 广度优先搜索</span></span><br><span class="line">        <span class="keyword">int</span>[] x = &#123;<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] y = &#123;<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        set.add(<span class="number">0</span>);</span><br><span class="line">        q.offer(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 这个做个坐标映射，x*100 + y 是独一无二的，所以可以用其代表坐标值</span></span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> num = q.poll();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> ; i++)&#123;</span><br><span class="line">                  <span class="keyword">int</span> a = num / <span class="number">100</span> + x[i];</span><br><span class="line">                  <span class="keyword">int</span> b = num % <span class="number">100</span> + y[i];</span><br><span class="line">                  <span class="keyword">if</span>(!set.contains(a * <span class="number">100</span> + b) &amp;&amp; <span class="number">0</span> &lt;= a &amp;&amp; a &lt;m &amp;&amp; <span class="number">0</span> &lt;= b &amp;&amp; b &lt; n )&#123;</span><br><span class="line">                      <span class="keyword">int</span> sum = a % <span class="number">10</span> + a / <span class="number">10</span> + b % <span class="number">10</span> + b / <span class="number">10</span>;</span><br><span class="line">                      <span class="keyword">if</span>( sum &lt;= k)&#123;</span><br><span class="line"></span><br><span class="line">                      q.offer(a * <span class="number">100</span> + b);</span><br><span class="line">                      set.add(a * <span class="number">100</span> + b);</span><br><span class="line">                      count++;&#125;</span><br><span class="line">                  &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>力扣上时间7ms，可见在速度方面，虽然这里有我用了set容器，以及增加了映射计算的原因，但是试过别人的代码最4快也ms，bfs比起dfs还是有一定劣势</p>
<h1 id="思路三：动态规划"><a href="#思路三：动态规划" class="headerlink" title="思路三：动态规划"></a>思路三：动态规划</h1><p>这个问题也可以用动态规划来解决，设一个boolean二维数组dp来存储可进入状态</p>
<p>状态转移方程：<code>dp[i][j] =(dp[i-1][j] || dp[i][j-1]) &amp; 该点是否可进入</code></p>
<p>然后一行一行的遍历即可，如下先遍历第一行和第一列的目的在于减少边界判断条件（比如i、j - 1是否越界）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m &amp;&amp; sum(i) &lt;= k; i ++) &#123;</span><br><span class="line">            count += <span class="number">1</span>;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n &amp;&amp; sum(i) &lt;= k; i ++) &#123;</span><br><span class="line">            count += <span class="number">1</span>;</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((dp[i -<span class="number">1</span>][j] || dp[i][j - <span class="number">1</span>]) &amp;&amp; sum(i) + sum(j) &lt;= k) &#123;</span><br><span class="line">                    count += <span class="number">1</span>;</span><br><span class="line">                    dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">            res += i % <span class="number">10</span>;</span><br><span class="line">            i /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行时间2ms，对比dfs，和bfs，动态规划是实打实的要遍历所有元素，虽然时间复杂度都为O(mn),但是前面的系数不一样</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这里主要对比一下dfs和bfs的优缺点吧</p>
<p>dfs优点是快，但是具有堆栈不确定问题，看到会爆栈</p>
<p>bfs由于使用了队列对元素进行操作，实践中可能实践复杂度前的常数比较大，可能运行速度比dfs慢</p>
<p>动规只是一个参照物</p>
]]></content>
      <categories>
        <category>剑指Offer</category>
        <category>算法</category>
        <category>深度优先搜索</category>
        <category>广度优先搜索</category>
      </categories>
      <tags>
        <tag>dfs</tag>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title>泛型</title>
    <url>/2021/02/19/%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<p>了解Java泛型，明白一些常见的问题</p>
<a id="more"></a>

<h1 id="Java泛型使用"><a href="#Java泛型使用" class="headerlink" title="Java泛型使用"></a>Java泛型使用</h1><p>在多态中，继承让我们实现了继承体系中的多态，而接口的出现突破了单继承体系的限制，当方法以接口而不是类作为参数时，这样的方法比单一继承体系的基类更为通用。</p>
<p>而即便是接口也还是有诸多限制。一旦指定了接口，它就要求你的代码必须使用特定的接口。而我们希望编写更通用的代码，能够适用“非特定的类型”，而不是一个具体的接口或类。这就是泛型，即适用于很多类型。</p>
<h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><p>集合就应用了泛型确保集合能够使用适用于不同类型，存储不同的元素，而不用修改代码</p>
<p>下面是一个用链表实现栈的泛型代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> firstlearn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedStack</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">U</span>&gt;</span>&#123;</span><br><span class="line">        U item;</span><br><span class="line">        Node&lt;U&gt; next;</span><br><span class="line">        Node()&#123;</span><br><span class="line">            item = <span class="keyword">null</span>;</span><br><span class="line">            next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node(U item,Node&lt;U&gt; next)&#123;</span><br><span class="line">            <span class="keyword">this</span>.item = item;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">end</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> item == <span class="keyword">null</span> &amp;&amp; next == <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt;  top = <span class="keyword">new</span> Node&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T item)</span></span>&#123;</span><br><span class="line">        top = <span class="keyword">new</span> Node&lt;T&gt;(item,top);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  T <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        T result = top.item;</span><br><span class="line">        <span class="keyword">if</span>(!top.end())</span><br><span class="line">            top = top.next;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  top.end();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        LinkedStack&lt;String&gt; stack = <span class="keyword">new</span> LinkedStack&lt;&gt;();</span><br><span class="line">        stack.push(<span class="string">&quot;begin&quot;</span>);</span><br><span class="line">        stack.push(<span class="string">&quot;then&quot;</span>);</span><br><span class="line">        stack.push(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            System.out.println(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>Linkedstack&lt;T&gt;</code>为泛型类，<code>Linkedstack&lt;String&gt;</code>为参数化的泛型。内部类<code>Node&lt;U&gt;</code>作为栈的组件也使用了泛型。</p>
<h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>泛型也经常用于接口，特别是函数式接口结合lambda表达式让接口有着更广泛的作用，必如生成器<code>Supplier&lt;T&gt;</code>,</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets a result.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>泛型类是从参数化整个类，也可以参数化方法即泛型方法，而作为准则，请“尽可能”使用泛型方法。通常<strong>将单个方法泛型化要比将整个类泛型化更清晰易懂</strong>，因为泛型类要在实例化的时候就指明类型，如果想换一种类型，不得不重新new一次，可能不够灵活；而泛型方法可以在调用的时候指明类型，更加灵活。</p>
<p>定义一个泛型方法</p>
<p>要定义泛型方法，请将泛型参数列表放置在返回值，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰词 泛型参数列表 返回值 函数名 (泛型参数)</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>对于泛型类，必须在实例化该类时指定类型参数。使用泛型方法时，通常不需要指定参数类型，因为编译器会找出这些类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">makeList</span><span class="params">(T... args)</span> </span>&#123;</span><br><span class="line">        List&lt;T&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (T item : args)</span><br><span class="line">            result.add(item);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>对于泛型类，必须在实例化该类时指定类型参数。使用泛型方法时，通常不需要指定参数类型，因为编译器会通过类型参数推断会找出这些类型。，所有，下面两种方式调用makeList方法均可以</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = 类名.makeList(<span class="string">&quot;ab&quot;</span>,<span class="string">&quot;ac&quot;</span>)<span class="comment">// 方法一,类型参数推断</span></span><br><span class="line">List&lt;String&gt; list = 类名.&lt;String&gt;makeList(<span class="string">&quot;ab&quot;</span>,<span class="string">&quot;ac&quot;</span>)<span class="comment">// 方法二，指定类型参数</span></span><br></pre></td></tr></table></figure>
<h1 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h1><p>Java实现泛型为了保证迁移做出了妥协，但代码在运行时，将无法在泛型代码内部，无法获取任何有关泛型参数类型的信息。</p>
<p>这意味着，<code>List&lt;Interger&gt; 和List&lt;String&gt;</code>在运行时，其方括号中的参数类型将不起作用，如下列中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class c1 = <span class="keyword">new</span> ArrayList&lt;String&gt;().getClass();</span><br><span class="line">Class c2 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;().getClass();</span><br><span class="line">System.out.println(c1 == c2);</span><br></pre></td></tr></table></figure>
<p>输出结果为true</p>
<p><code>ArrayList&lt;String&gt;</code> 和 <code>ArrayList&lt;Integer&gt;</code> 应该是不同的类型。但泛型擦除后，上面的程序认为它们是相同的类型。两者都被擦除成原生的·类型<code>ArrayList</code>这保证了其和之前没有使用泛型的代码的兼容性，但是也带来了很多问题</p>
<p>泛型类型只有在静态类型检测期间才出现，在此之后，程序中的所有泛型类型都将被擦除，替换为它们的非泛型上界。例如， <code>List&lt;T&gt;</code> 这样的类型注解会被擦除为 <strong>List</strong>，普通的类型变量在未指定边界的情况下会被擦除为 <strong>Object</strong>。</p>
<h2 id="泛型擦除的问题"><a href="#泛型擦除的问题" class="headerlink" title="泛型擦除的问题"></a>泛型擦除的问题</h2><p>由于运行时所有关于参数的类型信息都丢失了，泛型不能用于显式地引用运行时类型的操作中</p>
<ul>
<li><p><strong>泛型不能用于转型、instanceof 操作和 new 表达式</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Object&gt; q =  <span class="keyword">new</span> ArrayList&lt;String&gt;()</span><br><span class="line">A <span class="keyword">instanceof</span> T</span><br><span class="line"><span class="keyword">new</span> T()</span><br><span class="line">上诉代码是错误的</span><br></pre></td></tr></table></figure></li>
<li><p><strong>无法创建泛型数组</strong>，但是注意可以声明</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">T[] array = <span class="keyword">new</span> T[];<span class="comment">//error</span></span><br></pre></td></tr></table></figure>
<p>对于上诉问题，通用的解决方法是引入一个<strong>类型标记</strong><code>Class&lt;T&gt; type</code>,为所需的类型显式传递一个 <strong>Class</strong> 对象，以在类型表达式中使用它。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Class&lt;T&gt; kind; </span><br><span class="line"><span class="comment">// 如果传入一个参数类型给kind，kind可以用于instanceof操作</span></span><br><span class="line">kind.isInstance(arg);</span><br><span class="line"><span class="comment">// 可以创建泛型数组、或对象</span></span><br><span class="line">kind.newInstance();</span><br><span class="line"><span class="keyword">private</span> T[] array = (T[]) Array.newInstance(kind, size);</span><br><span class="line"></span><br><span class="line">   </span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>擦除导致方法使用受限制</strong></p>
<p>由于擦除会删除类型信息，因此唯一可用于无限制泛型参数的方法是那些 <strong>Object</strong> 可用的方法。但是，如果将该参数限制为某类型的子集，则可以调用该子集中的方法。为了应用约束，Java 泛型使用了 <code>extends</code> 关键字。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A&lt;T extends B&gt;&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时泛型擦除会将所有的T替换成B，而不是Object了</p>
</li>
</ul>
<h2 id="通配符问题"><a href="#通配符问题" class="headerlink" title="通配符问题"></a>通配符问题</h2><p>参数化的类型是不可变的，但有时我们需要更多的灵活性,这时我们可以使用有限制的通配符来提示API的灵活性。</p>
<p>如：</p>
<p><code>&lt;? extends E&gt;</code>:E的某个子类型，确定上限</p>
<p><code>&lt;? super E&gt;</code>:E的某个超类，确定下限</p>
<p><code>&lt;?&gt;</code>:某个类型，无限制</p>
<p>但通配符的使用是有限制的。一般用于：通作为参数，字段或局部变量的类型，有时作为返回类型。</p>
<p>比如常见的作为参数、或局部变量的声明</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;? extends Apple&gt; alist;</span><br><span class="line">f(List&lt;? extends Apple&gt; list);</span><br></pre></td></tr></table></figure>
<p>当作为参数时：</p>
<ul>
<li><code>&lt;? extends E&gt;</code>取出的参数相当于E,可以调用E的方法，但是不能向alist中加入任何元素（null除外），因为你不知道alist中的元素究竟是什么（alist中实际只有一种类型，如果加入orange，实际是Apple就会冲突；如果加入Object，取出时向下转型又会有问题）</li>
<li><code>&lt;? super E&gt;</code>代表该集合E的某个超类的集合，既然是超类，加入E肯定没有问题，但是由于取出类型不知道是什么类型，所以不能从alist中取出元素</li>
<li>无法将除null的任何元素放到<code>&lt;?&gt;</code>中</li>
</ul>
<p>这正好是<strong>PECS</strong>：生产者提供产品（取），用extends；消费者消费产品(加入)，用super。</p>
<p>无界通配符&lt;?&gt;的作用在于处理多个泛型参数时，有时允许一个参数可以是任何类型</p>
<h1 id="一些建议"><a href="#一些建议" class="headerlink" title="一些建议"></a>一些建议</h1><ul>
<li><p>一般来说，<strong>尽量使用泛型而不是原生态类型</strong>，主要在于，泛型可以在编译器有安全性检测和描述性的优势，可以极早的发现错误。</p>
</li>
<li><p><strong>列表优先于泛型数组</strong></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java语法</category>
        <category>进阶</category>
      </categories>
      <tags>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指14-剪绳子</title>
    <url>/2021/02/20/%E5%89%91%E6%8C%8714-%E5%89%AA%E7%BB%B3%E5%AD%90/</url>
    <content><![CDATA[<p><strong>剑指 Offer 14.剪绳子</strong></p>
<p><a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/">剑指 Offer 14- I. 剪绳子</a></p>
<p><a href="https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/">剑指 Offer 14- II. 剪绳子 II</a></p>
<a id="more"></a>

<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一根长度为 <code>n</code> 的绳子，请把绳子剪成整数长度的 <code>m</code> 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 <code>k[0],k[1]...k[m - 1]</code> 。请问 <code>k[0]*k[1]*...*k[m - 1]</code> 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 &#x3D; 1 + 1, 1 × 1 &#x3D; 1</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: 36</span><br><span class="line">解释: 10 &#x3D; 3 + 3 + 4, 3 × 3 × 4 &#x3D; 36</span><br></pre></td></tr></table></figure>


<p><strong>提示：</strong></p>
<ul>
<li><p><code>2 &lt;= n &lt;= 58</code>，对于剪绳子，答案也不要求取模</p>
</li>
<li><p><code>2 &lt;= n &lt;= 1000</code>，对于剪绳子 II</p>
</li>
</ul>
<p>即两题的区别在于可能会越界</p>
<h1 id="思路一：动态规划"><a href="#思路一：动态规划" class="headerlink" title="思路一：动态规划"></a>思路一：动态规划</h1><p>读题意知道绳子必须要剪，我们可以简化问题，假设一段绳子剪两段，一段固定，题目就转化求固定段*另一段乘积的最大值，而求另一段乘积的最大值就是重叠子问题，提醒我们该题可以用动态规划来解决。</p>
<p>假设dp[i]表示长度为i的绳子的最大乘积，又注意到当绳子较小时dp[i]未必有长度为i的绳子大，所以可以得出下面的状态转移方程</p>
<p><code>dp[i] = max(dp[i],max(dp[j]*(i - j),j*(i - j))),j：1~i-1、</code></p>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">1</span>; i - len &gt;= <span class="number">1</span>; len++)&#123;</span><br><span class="line">                dp[i] = Math.max(dp[i],Math.max(len * dp[i-len],len * (i-len)));          </span><br><span class="line">        &#125;&#125;   </span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是注意<strong>该题将n的范围扩大后</strong>，得到的dp[i]会非常大，int、long都可能出现大数越界，无法保存信息，如果还需要使用动态规划，就需要使用<code>BigInteger</code>开销倍增</p>
<p>而且该方法的时间复杂度是O(n²)</p>
<h1 id="思路二：数学规律"><a href="#思路二：数学规律" class="headerlink" title="思路二：数学规律"></a>思路二：数学规律</h1><p>由下面公式有</p>
<p><img src="/images/image-20210220151351235.png" alt="image-20210220151351235"></p>
<p>当划分段数一定时，绳子以相等的长度等分为多段，得到的乘积最大</p>
<p>下面研究段数即和划分长度的关系</p>
<p><img src="/images/image-20210220151645677.png" alt="image-20210220151645677"></p>
<p>求该函数的极值点，得极值点为e，但是绳子只能取整数，最终的绳子划分为3的整数段最大，再考虑到划分后绳子余1，余2的情况，余1，3<em>1&lt;2\</em>2；余2,2*3最大,为了统一处理可以用数组记录这些值，该问题已经转化为求3的幂的问题</p>
<p>求幂问题使用快速幂，时间复杂度O(logn)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp2[] = &#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">4</span>)</span><br><span class="line">        <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> a = n / <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> b = n % <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(pow(a-<span class="number">1</span>)*dp2[b] % <span class="number">1000000007</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">long</span> result = pow(a / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>((a&amp;<span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> (result * result * <span class="number">3</span>) % <span class="number">1000000007</span>;</span><br><span class="line">        <span class="keyword">return</span> (result * result) % <span class="number">1000000007</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上诉代码是递归实现，在下面的题目中遇到单纯的快速幂问题再做细解。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>该题不知道说是好还是不好，毕竟数学规律的题真出现在试题中未必能够想出来，就当巩固了动态规划和快速幂知识吧</p>
]]></content>
      <categories>
        <category>剑指Offer</category>
        <category>算法</category>
        <category>动态规划</category>
        <category>趣味题</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指15-二进制中1的个数</title>
    <url>/2021/02/20/%E5%89%91%E6%8C%8715-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<p><strong>剑指 Offer 15. 二进制中1的个数</strong></p>
<p><a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/">力扣链接</a></p>
<a id="more"></a>

<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：00000000000000000000000000001011</span><br><span class="line">输出：3</span><br><span class="line">解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#39;1&#39;。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：00000000000000000000000010000000</span><br><span class="line">输出：1</span><br><span class="line">解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &#39;1&#39;。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：11111111111111111111111111111101</span><br><span class="line">输出：31</span><br><span class="line">解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &#39;1&#39;。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>输入必须是长度为 <code>32</code> 的 <strong>二进制串</strong> 。</li>
</ul>
<h1 id="一些位运算知识"><a href="#一些位运算知识" class="headerlink" title="一些位运算知识"></a>一些位运算知识</h1><p>见我算法中位运算分类下的文章</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>了解位运算知识后我们知道<code>x&amp;(x-1)</code>可以将x二进制最右边一位1置零，如此我们只需要循环操作直到所有1变为0后即可统计出二进制中1的个数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            n = n&amp;(n-<span class="number">1</span>);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然如果不知道<code>x&amp;(x-1)</code>，也可以利用移位运算符一个一个的统计</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)&#123;</span><br><span class="line">            count += n &amp; <span class="number">1</span>;</span><br><span class="line">            n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>了解一些位运算的技巧还是很有必要</p>
]]></content>
      <categories>
        <category>剑指Offer</category>
        <category>算法</category>
        <category>位运算</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>常见位运算操作</title>
    <url>/2021/02/20/%E5%B8%B8%E8%A7%81%E4%BD%8D%E8%BF%90%E7%AE%97%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>了解一下一些常见的位运算操作</p>
<a id="more"></a>

<h1 id="位运算基础"><a href="#位运算基础" class="headerlink" title="位运算基础"></a>位运算基础</h1><ul>
<li><p>二进制基础</p>
<p>计算机中一般用<strong>补码</strong>计算和表示数字（统一加减）</p>
<p>正数：原码=反码=补码</p>
<p>负数：反码=原码除符号位取反</p>
<p>​            补码=反码+1</p>
<p>比如对应Java int 中对应的5和-5的二进制表示分别为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000101</span> <span class="number">5</span>反码补码</span><br><span class="line"><span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111011</span> -<span class="number">5</span>补码</span><br><span class="line"><span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111010</span> -<span class="number">5</span>反码</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;        System.out.println(Integer.toBinaryString(-<span class="number">5</span>);  System.out.println(Integer.toBinaryString(<span class="number">5</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/image-20210220201633151.png" alt="image-20210220201633151"></p>
</li>
<li><p>常见位运算有&amp;，|, ~, ^, &lt;&lt;, &gt;&gt;</p>
<p>~为取反，观察上面5和-5的补码，发现5取反+1 和-5的补码一致，就有<code>~a + 1 = -a</code></p>
<p>^为异或，相异为1；注意<code>-1异或任何数</code>相当于取反</p>
<p>&lt;&lt;为左移，相当于乘，a&lt;&lt;1相当于乘2</p>
<p>&gt;&gt;为右移，相当于除，a &gt;&gt;1相当于除2</p>
</li>
</ul>
<h1 id="位运算操作"><a href="#位运算操作" class="headerlink" title="位运算操作"></a>位运算操作</h1><ul>
<li><p>判断<strong>奇偶性</strong></p>
<p><code>a&amp;1==0//1奇0偶</code></p>
</li>
<li><p>对i=2^n进行<strong>取模运算</strong></p>
<p><code>a&amp;(i-1)</code></p>
</li>
<li><p>求<strong>相反数</strong>，由<code>~a=-(a+1)</code>有</p>
<p>相反数:<code>-a=~a+1</code></p>
</li>
<li><p>求<strong>绝对值</strong>，已知0异或任何数不变，-1异或任何数相当于取反</p>
<p>则可这样求绝对值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> j=i &gt;&gt; <span class="number">31</span>;    <span class="comment">// 取符号位</span></span><br><span class="line"><span class="keyword">return</span> (i ^ j)- j;<span class="comment">// 实际就是相反数公式</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>交换两数</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a^&#x3D;b;</span><br><span class="line">b^&#x3D;a;</span><br><span class="line">a^&#x3D;b;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>置位操作</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x&amp;(x-1) &#x2F;&#x2F;将x最右边第一个1及以外数字置0</span><br></pre></td></tr></table></figure>
<h1 id="Java源码实例"><a href="#Java源码实例" class="headerlink" title="Java源码实例"></a>Java源码实例</h1></li>
</ul>
<p>未完待续</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>位运算</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指16-数值的整数次方</title>
    <url>/2021/02/26/%E5%89%91%E6%8C%8716-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/</url>
    <content><![CDATA[<p><strong>剑指 Offer 16. 数值的整数次方</strong></p>
<p><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/">力扣链接</a></p>
<a id="more"></a>

<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2.00000, 10</span><br><span class="line">输出: 1024.00000</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2.10000, 3</span><br><span class="line">输出: 9.26100</span><br></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2.00000, -2</span><br><span class="line">输出: 0.25000</span><br><span class="line">解释: 2-2 &#x3D; 1&#x2F;22 &#x3D; 1&#x2F;4 &#x3D; 0.25 </span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<ul>
<li>-100.0 &lt; <em>x</em> &lt; 100.0</li>
<li><em>n</em> 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。</li>
</ul>
<h1 id="思路一：二分递归"><a href="#思路一：二分递归" class="headerlink" title="思路一：二分递归"></a>思路一：二分递归</h1><p>计算a的x次方时，如果知道a的x/2次方可以减少计算量，对x</p>
<ul>
<li><p>当x为奇时，<code>pow(a,x) = pow(a,x / 2)²*x</code></p>
</li>
<li><p>当x为偶时，<code>pow(a,x) = pow(a,x / 2)²</code></p>
</li>
<li><p>重复上诉操作，直到x为1</p>
</li>
</ul>
<p>显然上诉思路是二分，可以用递归实现，下面是递归代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">           x = <span class="number">1</span> / x;</span><br><span class="line">           n = -n;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> pow(x,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">pow</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">double</span> temp = pow(x,n / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>((n &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> temp * temp * x;</span><br><span class="line">        <span class="keyword">return</span> temp * temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路二：迭代"><a href="#思路二：迭代" class="headerlink" title="思路二：迭代"></a>思路二：迭代</h1><p>我们知道任何一个数可以用二进制表示，那x的n次方也可以的n也可以用二进制表示</p>
<p>比如</p>
<p><img src="/images/image-20210226193432682.png" alt="image-20210226193432682"></p>
<p>我们只需要统计n的二进制哪一位为1，再乘以对应的x的2i次方，n直到所有位数为1统计结束即可</p>
<p>为了方便迭代，我们有右移运算和与运算统计n二进制数那几位为1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> a = n;</span><br><span class="line">       <span class="keyword">if</span>(a &lt; <span class="number">0</span>)&#123;</span><br><span class="line">           x = <span class="number">1</span> / x;</span><br><span class="line">           a = -a;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">double</span> ans = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span>(a &gt; <span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span>((a &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">                ans *= x;</span><br><span class="line">            x *= x;</span><br><span class="line">            a = a &gt;&gt; <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>剑指Offer</category>
        <category>算法</category>
        <category>二分</category>
      </categories>
      <tags>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指19-正则表达式匹配</title>
    <url>/2021/02/22/%E5%89%91%E6%8C%8719-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<p><strong>剑指 Offer 19. 正则表达式匹配</strong></p>
<p><a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/">力扣链接</a></p>
<a id="more"></a>

<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>请实现一个函数用来匹配包含<code>&#39;. &#39;</code>和<code>&#39;*&#39;</code>的正则表达式。模式中的字符<code>&#39;.&#39;</code>表示任意一个字符，而<code>&#39;*&#39;</code>表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串<code>&quot;aaa&quot;</code>与模式<code>&quot;a.a&quot;</code>和<code>&quot;ab*ac*a&quot;</code>匹配，但与<code>&quot;aa.a&quot;</code>和<code>&quot;ab*a&quot;</code>均不匹配。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;aa&quot;</span><br><span class="line">p &#x3D; &quot;a&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;aa&quot;</span><br><span class="line">p &#x3D; &quot;a*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &#39;*&#39; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &#39;a&#39;。因此，字符串 &quot;aa&quot; 可被视为 &#39;a&#39; 重复了一次。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;ab&quot;</span><br><span class="line">p &#x3D; &quot;.*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: &quot;.*&quot; 表示可匹配零个或多个（&#39;*&#39;）任意字符（&#39;.&#39;）。</span><br></pre></td></tr></table></figure>
<ul>
<li><code>s</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母。</li>
<li><code>p</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母以及字符 <code>.</code> 和 <code>*</code>，无连续的 <code>&#39;*&#39;</code>。</li>
</ul>
<h1 id="思路一：动态规划"><a href="#思路一：动态规划" class="headerlink" title="思路一：动态规划"></a>思路一：动态规划</h1><p>我们看两个是否匹配可以倒着看</p>
<ul>
<li>如果p最后一个元素不是*，则看p和s最后一个字符是否匹配：如果匹配，显然问题转换成看p和s除去最后一个的子字符串是否匹配的子问题，显然这是重叠子问题</li>
<li>如果是<em>，则p还需要看前一个字符记c，这是只有两个情况：c\</em>匹配s最后一个字符和不匹配最后一个字符两种情况。匹配，由于c*还可匹配s前一个字符，所以转换成p和是去掉最后一个字符串的子问题；不匹配，则转化成s和p去掉最后两个字符的子问题</li>
</ul>
<p>终上重叠子问题的描述，该题可以用动态规划解决问题，涉及两个字符串，一般设<code>f[i][j]</code>表示s前i个和p前j个是否匹配：有如下的状态转移方程：</p>
<p><img src="/images/image-20210222103808605.png" alt="image-20210222103808605"></p>
<p>可以写出代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == p)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m = s.length();</span><br><span class="line">        <span class="keyword">int</span> n = p.length();</span><br><span class="line">        <span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] pattern = p.toCharArray();</span><br><span class="line">        <span class="keyword">boolean</span>[][] f = <span class="keyword">new</span> <span class="keyword">boolean</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m ; i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(pattern[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                   <span class="comment">// 该题*一定会在一个字符后面，此时j至少为2</span></span><br><span class="line">                    f[i][j] = f[i][j - <span class="number">2</span>];</span><br><span class="line">                    <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; (str[i - <span class="number">1</span>] == pattern[j - <span class="number">2</span>] || pattern[j - <span class="number">2</span>] == <span class="string">&#x27;.&#x27;</span>) )</span><br><span class="line">                        f[i][j] = f[i][j] || f[i - <span class="number">1</span>][j];</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span>&#123;</span><br><span class="line">                   <span class="keyword">if</span>(i != <span class="number">0</span>)&#123;</span><br><span class="line">                       f[i][j] = f[i - <span class="number">1</span>][ j - <span class="number">1</span>] &amp;&amp;(str[i - <span class="number">1</span>] == pattern[j - <span class="number">1</span>] || pattern[j - <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> f[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路二：非确定状态自动机"><a href="#思路二：非确定状态自动机" class="headerlink" title="思路二：非确定状态自动机"></a>思路二：非确定状态自动机</h1>]]></content>
      <categories>
        <category>剑指Offer</category>
        <category>算法</category>
        <category>字符串</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串查找基础</title>
    <url>/2021/02/25/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>描述字符串查找匹配的一些通用方法</p>
<a id="more"></a>

<h1 id="字符串匹配问题"><a href="#字符串匹配问题" class="headerlink" title="字符串匹配问题"></a>字符串匹配问题</h1><p>字符串匹配问题一般都可以简化为在一个文本S中，是否存在一个模式P，一般P是子字符串较小，而文本S较大</p>
<p>最简单的想法是暴力搜索，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">int</span> <span class="title">search</span><span class="params">(String s,String p)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> n = s.length();</span><br><span class="line">       <span class="keyword">int</span> m = p.length();</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= m - n; i ++)&#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(p.charAt(j) != s.charAt(i + j))&#123;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span>(j == m - <span class="number">1</span>)</span><br><span class="line">                   <span class="keyword">return</span> i;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span>  -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>该算法的时间复杂度是O(NM)</p>
<h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><h2 id="算法简要"><a href="#算法简要" class="headerlink" title="算法简要"></a>算法简要</h2><p>上诉暴力搜索法，在匹配i不成功时，又从j = 0开始匹配,。</p>
<p>但是实际上，可能匹配不成功时，我们已经看了到了S到了第i 位，P的第j位。我们知道了S的前<code>j - 1</code>个内容，与P的前<code> j - 1</code>个内容，由于P较短，我们可以预先处理P，在已知P和S前 <code>j - 1</code>个内容，并且知道<code>s.charAt( i)</code>，j应该回退到哪个位置开始同S下一位比较，减少j的回退，从而对算法进行优化</p>
<p>于是假设<code>dfa[s.charAt( i)][j]</code>表示文本在第i个位置与<code>p.charAt(j)</code>比较失败时，文本下一个字符比较时j应该回退多远,则此时，仅当<code>s.charAt( i) == p.charAt(j)</code>时，其值为j + 1，代表匹配继续比较下一位字符。</p>
<p>于是KMP算法可以写成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">int</span> <span class="title">search</span><span class="params">(String s,String p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> m = p.length();</span><br><span class="line">        makeDfa(p);</span><br><span class="line">        <span class="keyword">int</span> i ,j ;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span> , j = <span class="number">0</span>; i &lt; n &amp;&amp; j &lt; m; i++)&#123;</span><br><span class="line">            j = dfa[s.charAt(i)][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( j == m)</span><br><span class="line">            <span class="keyword">return</span> i - m;</span><br><span class="line">        <span class="keyword">return</span> - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>实际上，问题的关键是在于如果给定一个p，制定对于的dfa数组；</p>
<p>这里可以利用确定有限状态自动机完成，即DFA</p>
<h2 id="DFA"><a href="#DFA" class="headerlink" title="DFA"></a>DFA</h2><p>我们假设模式中每一个字符对应着一个状态，并且每个状态可以通过转换到达另一个状态，由于字符是有限的，所以是有限自动机</p>
<p>转换可以有匹配转化（比较下一个），和非匹配转换（回退），分别用右左箭头表示，下面就是一个模式的转化图</p>
<p><img src="/images/image-20210225151110363.png" alt="image-20210225151110363"></p>
<p>实际上，当在文本中查找p的过程，就是在状态转换图中进行状态转化的过程，起始状态为0，之后不断扫描S，当与P首字母状态相同时，进入状态1，如果找到匹配会进入下一个状态，否则，又会回退，直到p所有字符匹配完，到达终止态，就说明匹配成功。</p>
<p>具体到一个dfa的制作，p的长度决定了状态数，所有可能出现的字符是转化的条件。</p>
<p>当j = 0 时，显然只能通过<code>dfa[p.charAt(0)][0],</code>进入1状态</p>
<p>…</p>
<p>当j = k 时</p>
<ul>
<li>我们知道由于匹配失败只会回到之前的状态X&lt;j（向左），所以情况和前面相同</li>
<li>匹配成功<code>dfa[p.charAt(j)][j] == j + 1</code></li>
<li>X怎么确定：显然<code>X = dfa[p.charAt(j)][X]</code></li>
</ul>
<p>于是确定dfa的代码就如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">int</span> [][] dfa;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span>  <span class="keyword">int</span> M;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">makeDfa</span><span class="params">(String p)</span></span>&#123;</span><br><span class="line">        M = p.length(); <span class="comment">// 状态数</span></span><br><span class="line">        dfa = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>][M];</span><br><span class="line">        dfa[p.charAt(<span class="number">0</span>)][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> X = <span class="number">0</span>,j = <span class="number">1</span>; j &lt; M; j++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">                dfa[i][j] = dfa[i][X];</span><br><span class="line">            dfa[p.charAt(j)][j] = j + <span class="number">1</span>;</span><br><span class="line">            X = dfa[p.charAt(j)][X];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指17-打印从1到最大n位数</title>
    <url>/2021/02/27/%E5%89%91%E6%8C%8717-%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7n%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<p><strong>剑指 Offer 17. 打印从1到最大的n位数</strong></p>
<p><a href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/">力扣链接</a></p>
<a id="more"></a>

<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入数字 <code>n</code>，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 1</span><br><span class="line">输出: [1,2,3,4,5,6,7,8,9]</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li>用返回一个整数列表来代替打印</li>
<li>n 为正整数</li>
</ul>
<h1 id="解决题目"><a href="#解决题目" class="headerlink" title="解决题目"></a>解决题目</h1><p>由于题目要求返回一个整数列表，所以该题难度急速下降，没有难度，不用考虑大数问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] printNumbers(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">0</span>,<span class="number">9</span>,<span class="number">99</span>,<span class="number">999</span>,<span class="number">9999</span>,<span class="number">99999</span>,<span class="number">999999</span>,<span class="number">9999999</span>,<span class="number">99999999</span>,<span class="number">999999999</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> max = a[n];</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[max];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max; i++)</span><br><span class="line">            ans[i] = i + <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="题目进阶：全排列"><a href="#题目进阶：全排列" class="headerlink" title="题目进阶：全排列"></a>题目进阶：全排列</h1><p>如果该题考虑大数问题，只是单纯的要求打印出来，难度也会上升。</p>
<p>这里有两种思路，一个是用字符串模拟大数加法，思路比较类似，可以见算法模拟题分类的一篇文章，另一个是利用全排列的思路，就在此描述</p>
<p>实际上该题要求输出的数字也是0-9的数字全排列，共n位，再考虑到全排列可能前面高位为0的问题，我们可以专门建个函数进行打印。</p>
<p>下述为代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">permutation</span><span class="params">(<span class="keyword">int</span> n,String s)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         SpecialPrint(s);</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;=<span class="number">9</span> ; i++)&#123;</span><br><span class="line">         permutation(n-<span class="number">1</span>,s+i);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SpecialPrint</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span>(i &lt; s.length() &amp;&amp; s.charAt(i) == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">         i++;</span><br><span class="line">     <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">         System.out.println(s);</span><br><span class="line">     <span class="keyword">else</span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(i &lt; s.length())</span><br><span class="line">         System.out.println(s.substring(i,s.length()));&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>该方法可以解决大数问题</p>
]]></content>
      <categories>
        <category>剑指Offer</category>
        <category>算法</category>
        <category>模拟题</category>
      </categories>
      <tags>
        <tag>模拟题</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven</title>
    <url>/2021/02/27/Maven/</url>
    <content><![CDATA[<p>介绍Maven基础知识点，并用一实例体现其在IDEA上的用途</p>
<a id="more"></a>

<h1 id="Maven基础"><a href="#Maven基础" class="headerlink" title="Maven基础"></a>Maven基础</h1><p>　    理想的项目构建是高度自动化，跨平台，可重用的组件，标准化的，使用Maven就可以帮我们完成上述所说的项目构建过程。</p>
<p>​     Java 框架基本上都依赖于 Maven，其是跨平台项目管理工具，主要服务于基于Java平台的项目构建、依赖管理和项目信息管理：</p>
<ul>
<li>项目构建：项目构建经过清理项目、编译项目、测试项目、生成测试报告、打包项目、部署项目几个阶段，可以使用Maven完成</li>
<li>依赖管理：指jar包之间的相互依赖，Maven可以自动下载项目所需要的jar包，统一管理jar包之间的依赖关系。</li>
</ul>
<p>就最直观的依赖管理来说，Maven 可以自动化地解决依赖问题，也就是说只要你写清楚你需要什么包，那么 Maven 可以自动把这个包准备好，同时也会把所有的依赖包准备好，而不需要自己手动下载再一个一个添加。</p>
<h1 id="POM"><a href="#POM" class="headerlink" title="POM"></a>POM</h1><p>POM即项目对象模型，是一个包含项目信息的XML文件，每新建一个项目会有一个POM文件。</p>
<p>执行任务或目标时，Maven 会在当前目录中查找 POM。它读取 POM，获取所需的配置信息，然后执行目标。</p>
<p>在POM中可以指定一些配置，比如项目依赖、插件、项目构建profile、以及一些项目信息。</p>
<p>Maven与项目依赖：</p>
<p><img src="/images/image-20210228153514059.png" alt="image-20210228153514059"></p>
<p>Maven的项目信息：</p>
<p><img src="/images/image-20210228153647972.png" alt="image-20210228153647972"></p>
<p>所有 POM 文件都需要 project 元素和三个必需字段：groupId，artifactId，version。</p>
<p>groupId：项目组Id，全球唯一；groupId：项目组Id，全球唯一；version为项目版本</p>
<p><strong>父POM</strong></p>
<p>父（Super）POM是 Maven 默认的 POM。所有的 POM 都继承自一个父 POM（无论是否显式定义了这个父 POM）父POM 包含了一些可以被继承的默认设置。因此，当 Maven 发现需要下载 POM 中的依赖时，它会到 Super POM 中配置的默认仓库下载，如下面的仓库内容</p>
<h1 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h1><p>仓库是一个位置，用来管理构件（依赖、插件或者项目构建的输出），是放置所有JAR文件的地方。</p>
<p>仓库可以分本地仓库，中央仓库、远程仓库，也是依赖的搜索顺序</p>
<ul>
<li><p>本地仓库：用来存储项目的依赖库</p>
<p>默认地址在<code>$&#123;user.home&#125;/.m2/repository</code>,可以在conf的setings.xml文件中定义另一个路径</p>
<p><img src="/images/20151215145450769" alt="img"></p>
</li>
<li><p>中央仓库：用来下载依赖库的默认位置</p>
</li>
<li><p>远程仓库：中央仓库依赖库的补充，或者弥补中央仓库速度慢的问题</p>
</li>
<li><p>依赖的搜索顺序：本地仓库，中央仓库、远程仓库</p>
</li>
</ul>
<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p>Maven 构建生命周期定义了一个项目构建跟发布的过程。生命周期把每个项目构建跟发布按阶段顺序的执行</p>
<p>而Maven有三套独立的生命周期：clean、default（build）、site，每个生命周期又会分成几个阶段，在一个生命周期中，运行某个阶段的时候，它之前的所有阶段都会被运行！</p>
<ul>
<li><p><strong>clean：</strong>在真正的构造之前进行项目清理工作，其阶段划分如下：</p>
<ul>
<li>pre-clean：执行一些需要在clean之前完成的工作</li>
<li>clean：移除上一次构建生成的文件</li>
<li>post-clean：执行一些需要在clean之后立刻完成的工作</li>
</ul>
<p>这时来理解”在一个生命周期中，运行某个阶段的时候，它之前的所有阶段都会被运行“这句话，如果输入<code>mvn clean</code>，代表着已经运行了pre-clean，clean两个生命周期阶段。</p>
</li>
<li><p><strong>default：</strong>项目构建的核心，主要生命周期，阶段包括编译，测试，打包，部署等等。default生命周期有23个阶段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">validate</span><br><span class="line">initialize</span><br><span class="line">generate-sources</span><br><span class="line">process-sources</span><br><span class="line">generate-resources</span><br><span class="line">process-resources     复制并处理资源文件，至目标目录，准备打包。</span><br><span class="line">compile     编译项目的源代码。</span><br><span class="line">process-classes</span><br><span class="line">generate-test-sources </span><br><span class="line">process-test-sources</span><br><span class="line">generate-test-resources</span><br><span class="line">process-test-resources     复制并处理资源文件，至目标测试目录。</span><br><span class="line">test-compile     编译测试源代码。</span><br><span class="line">process-test-classes</span><br><span class="line">test     使用合适的单元测试框架运行测试。这些测试代码不会被打包或部署。</span><br><span class="line">prepare-package</span><br><span class="line">package     接受编译好的代码，打包成可发布的格式，如 JAR 。</span><br><span class="line">pre-integration-test</span><br><span class="line">integration-test</span><br><span class="line">post-integration-test</span><br><span class="line">verify</span><br><span class="line">install     将包安装至本地仓库，以让其它项目依赖。</span><br><span class="line">deploy     将最终的包复制到远程的仓库，以让其它开发人员与项目共享。</span><br></pre></td></tr></table></figure>
<p>在default生命周期，主要又是以下阶段序列</p>
<p><img src="/images/image-20210228162151444.png" alt="image-20210228162151444"></p>
</li>
<li><p><strong>site：</strong>生成项目报告，站点，发布站点。</p>
<ul>
<li><p>pre-site：执行一些需要在生成站点文档之前完成的工作</p>
</li>
<li><p>site：生成项目的站点文档</p>
</li>
<li><p>post-site：执行一些需要在生成站点文档之后完成的工作，并且为部署做准备</p>
</li>
<li><p>site-deploy：将生成的站点文档部署到特定的服务器上</p>
</li>
</ul>
</li>
</ul>
<h1 id="内置命令"><a href="#内置命令" class="headerlink" title="内置命令"></a>内置命令</h1><p>Maven有一些内置命令，可以结合前面的生命周期一起使用，注意使用时需要转到对于的项目目录下</p>
<ul>
<li>创建Maven的普通java项目：<br><code>mvn archetype:create -DgroupId=packageName -DartifactId=projectName</code></li>
<li>创建Maven的Web项目：<br><code>mvn archetype:create -DgroupId=packageName -DartifactId=webappName-DarchetypeArtifactId=maven-archetype-webapp</code></li>
<li>编译源代码：<code> mvn compile</code></li>
<li>编译测试代码：<code>mvn test-compile</code></li>
<li>运行测试：<code>mvn test</code></li>
<li>产生site：<code>mvn site</code></li>
<li>打包：<code>mvn package</code></li>
<li>在本地Repository中安装jar：<code>mvn install</code></li>
<li>清除产生的项目：<code>mvn clean</code></li>
<li>生成eclipse项目：<code>mvn eclipse:eclipse</code></li>
<li>生成idea项目：<code>mvn idea:idea</code></li>
<li>组合使用goal命令，如只打包不测试：<code>mvn -Dtest package</code></li>
<li>编译测试的内容：<code>mvn test-compile</code></li>
<li>只打jar包: <code>mvn jar:jar</code></li>
<li>只测试而不编译，也不测试编译：<code>mvn test -skipping compile -skipping test-compile</code>( -skipping 的灵活运用，当然也可以用于其他组合命令)</li>
<li>清除eclipse的一些系统设置:<code>mvn eclipse:clean</code></li>
</ul>
<h1 id="Nexus私服"><a href="#Nexus私服" class="headerlink" title="Nexus私服"></a>Nexus私服</h1><p>私服是一种特殊的远程仓库，它是架设在局域网内的仓库服务，私服代理广域网上的远程仓库，供局域网内的用户使用。当Maven需要下载构件的时候，它从私服请求，如果 私服上不存在该构件，则从外部远程仓库下载，缓存在私服上之后，再为Maven的下载请求提供服务。</p>
<h1 id="IDEA与Maven"><a href="#IDEA与Maven" class="headerlink" title="IDEA与Maven"></a>IDEA与Maven</h1><p>未完待续</p>
]]></content>
  </entry>
  <entry>
    <title>JUnit</title>
    <url>/2021/03/01/JUnit/</url>
    <content><![CDATA[<p>简单学习如何在IDEA上用JUnit进行单元测试</p>
<a id="more"></a>

<h1 id="单元测试概念"><a href="#单元测试概念" class="headerlink" title="单元测试概念"></a>单元测试概念</h1><p>单元测试是对软件或程序的基本（最小）组成单元的测试，对方法或者对象进行测试。这种以测试为驱动的开发模式最大的好处就是确保一个程序模块的行为符合我们设计的测试用例。在将来修改的时候，可以极大程度地保证该模块行为仍然是正确的</p>
<p>在编写单元测试的时候，我们要遵循一定的规范：</p>
<p>一是单元测试代码本身必须非常简单，能一下看明白，决不能再为测试代码编写测试；</p>
<p>二是每个单元测试应当互相独立，不依赖运行的顺序；</p>
<p>三是测试时不但要覆盖常用测试用例，还要特别注意测试边界条件，例如输入为<code>0</code>，<code>null</code>，空字符串<code>&quot;&quot;</code>等情况。</p>
<p>在Java中，一般使用Junit进行单元测试，这样比我们用main方法手动测试有以下优点</p>
<ul>
<li>新增加的测试，对原来的测试没有影响</li>
<li>如果测试失败了，会立即得到通知</li>
</ul>
<h1 id="配置IDEA上的Junit环境"><a href="#配置IDEA上的Junit环境" class="headerlink" title="配置IDEA上的Junit环境"></a>配置IDEA上的Junit环境</h1><ul>
<li><p>安装插件</p>
<ul>
<li>打开<code>File</code>菜单的下拉菜单<code>settings[设置]</code></li>
<li>点击左侧<code>Plugins[插件]</code>菜单</li>
<li>在输入框中输入<code>JUnitGenerator 2.0</code>进行<code>Install</code></li>
<li>重启<code>IDEA</code></li>
</ul>
</li>
<li><p>配置插件</p>
<ul>
<li>继续在<code>settings[设置]</code>中点击<code>other setting</code></li>
<li>点击<code>JUnit Generator</code>，在<code>Properties</code>中修改<code>Default Template</code>为<code>JUnit4</code></li>
<li>再在<code>JUnit4</code>页签将<code>package test.$entry.packageName;</code>修改成<code>package $entry.packageName;</code>即去掉<code>test</code></li>
<li>配置完成</li>
</ul>
</li>
</ul>
<h1 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h1><h2 id="简单入门"><a href="#简单入门" class="headerlink" title="简单入门"></a>简单入门</h2><p>创建一个项目，下面是一个项目结构</p>
<p><img src="/images/image-20210301165254576.png" alt="image-20210301165254576"></p>
<p>在项目文件结构中，一般会将测试的代码放在<code>test/java</code>文件中,可以点击该目录，右键，在<code>open Medule settings</code> 中确保<code>Test Source Folders</code>的目录是正确的</p>
<p><img src="/images/image-20210301165549571.png" alt="image-20210301165549571"></p>
<p>之后可以新建应该被测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sum</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接在测试类中<code>ctrl + shift + T</code>,就可以创造对应的测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Assert;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SumTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sum1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = Sum.sum1(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        Assert.assertEquals(<span class="number">3</span>,result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">sum2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Assert.assertEquals(<span class="number">3</span>,Sum.sum2());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应需要测试的方法加上Test注解，两个方法结果如下</p>
<p><img src="/images/image-20210301180553442.png" alt="image-20210301180553442"></p>
<h2 id="进阶用法"><a href="#进阶用法" class="headerlink" title="进阶用法"></a>进阶用法</h2><p>一般用Assert进行测试，除了判断是否相等，还有以下测试方法</p>
<ul>
<li><p><strong>Assert方法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assertTure();assertFalse();&#x2F;&#x2F;期待结果为true或false</span><br><span class="line">assertNotNull();&#x2F;&#x2F;期待结果非null</span><br><span class="line">assertArrayEquals();&#x2F;&#x2F;期待结果为数组并与期望数组每个元素的值均相等</span><br><span class="line">assertEquals(expected,actual);&#x2F;&#x2F;期待相等</span><br><span class="line">assertEquals(expected,actual,delta);&#x2F;&#x2F;当使用浮点数的时候，需要加上误差</span><br></pre></td></tr></table></figure></li>
<li><p><strong>其他注解</strong></p>
</li>
</ul>
<p>除了@Test注解，Junit还可以在测试中添加<code>@Before ,@After </code>测试框架注解,其注解的方法会在所有<code>@Test</code>方法前后自动运行，做准备工作和结束清理工作</p>
<p>下面是一个实例</p>
<p>被测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index ;</span><br><span class="line">    StringFactory()&#123;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span> + index++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.After;</span><br><span class="line"><span class="keyword">import</span> org.junit.Assert;</span><br><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringFactoryTest</span>&lt;<span class="title">Public</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;测试前的准备工作，比如链接数据库等等&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tearDown</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;测试结束后的工作，比如关闭链接等等&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringFactory factory = <span class="keyword">new</span> StringFactory();</span><br><span class="line">        Assert.assertNotNull(factory.getter());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Assert.assertEquals(<span class="number">0</span>,<span class="keyword">new</span> StringFactory().getIndex());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/image-20210301184524338.png" alt="image-20210301184524338"></p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
  </entry>
  <entry>
    <title>Spring</title>
    <url>/2021/03/02/Spring/</url>
    <content><![CDATA[<p>初步学习Spring,主要了解IoC和AOP，并在IDEA上简单应用</p>
<a id="more"></a>

<h1 id="Spring概述"><a href="#Spring概述" class="headerlink" title="Spring概述"></a>Spring概述</h1><p>Spring是轻量级的JavaEE框架，其主要有两个核心部分IoC和AOP</p>
<ul>
<li><p><strong>IoC控制反转</strong>：控制反转是一种设计原则，减少代码之间的耦合度；基本思想是借助第三方容器实现具有依赖关系之间对象的解耦。在Spring中体现是创建对象由以前的程序员自己new 构造方法来调用，变成了交由Spring创建对象，就像控制权从本来在自己手里，交给了Spring。这里也得提到<strong>DI依赖注入</strong>，DI是实现控制反转的一种设计模式，是指将一个实例传入一个对象中，其可以实现解耦，而不需要对象自己关注创建实例。</p>
</li>
<li><p><strong>AOP切面编程：</strong>在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程</p>
<p>一般而言，我们管切入到指定类指定方法的代码片段称为切面，而切入到哪些类、哪些方法则叫切入点。有了AOP，我们就可以把几个类共有的代码或者一个主要业务的周边功能，抽取到一个切片中，等到需要时再切入对象中去，从而改变其原有的行为。</p>
</li>
</ul>
<h1 id="基于IDEA的一个入门实例"><a href="#基于IDEA的一个入门实例" class="headerlink" title="基于IDEA的一个入门实例"></a>基于IDEA的一个入门实例</h1><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><ul>
<li><p>安装好IDEA的Utilmate版本，社区版不支持Spring</p>
</li>
<li><p>安装好的IDEA带有Maven，新建一个Maven项目</p>
</li>
<li><p>在Maven的pom.xml文件中增加关于Spring的依赖，自动下载管理Spring相关的jar包</p>
<p>下述为依赖部分源码</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>在<code>src/main</code>目录下新建一个resources文件夹，将其设置为Resources Root （右键设置）</p>
</li>
</ul>
<p><img src="/images/image-20210303150900100.png" alt="image-20210303150900100"></p>
<ul>
<li><p>最后在resources中新建一个xml配置文件，如果有Spring的config，则说明前面的依赖成功</p>
<p><img src="/images/image-20210303151457605.png" alt="image-20210303151457605"></p>
</li>
</ul>
<ul>
<li>一个Spring项目建立完成</li>
</ul>
<h2 id="入门实例"><a href="#入门实例" class="headerlink" title="入门实例"></a>入门实例</h2><ul>
<li>在main下的包中创建一个Hello类，包含一个name属性，和一个简单方法</li>
</ul>
<p><img src="/images/image-20210303151943537.png" alt="image-20210303151943537"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>在Spring的xml文件中的bean组件中加入Hello类的信息</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><span class="line">    <span class="comment">// 新加的bean信息，包含id，类名，属性名，属性值</span></span><br><span class="line">    &lt;bean id=<span class="string">&quot;hello&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;org.example.Hello&quot;</span>&gt;</span><br><span class="line">        &lt;property name=&quot;name&quot; value=&quot;Spring&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>另建一个类，在其中新建应用上下文类，利用其getBean方法创建一个Hello类实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        Hello obj = (Hello) context.getBean(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        obj.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<p><img src="/images/image-20210303152920939.png" alt="image-20210303152920939"></p>
</li>
</ul>
<p>可见在上诉例子中App类中并没有new 一个Hello实例，而是利用Spring的应用上下文创建了一个Hello对象，实现了IoC</p>
<h1 id="IoC容器底层原理"><a href="#IoC容器底层原理" class="headerlink" title="IoC容器底层原理"></a>IoC容器底层原理</h1><p>IoC底层原理主要靠<strong>xml解析、工厂模式、反射</strong>实现</p>
<p>在上诉的案例中</p>
<ul>
<li>首先在xml中加入了对于类的配置信息</li>
<li>然后，Spring会解析xml得到对应的类名和属性</li>
<li>最后，利用反射和得到的类名等信息，新建类</li>
</ul>
<p>IoC使得bean之间的耦合度降低，IoC容器实际就是一个对象工厂</p>
<p>Spring实现IoC容器主要靠两大核心接口，分别是<code>BeanFactory</code>和<code>ApplicationContext</code></p>
<ul>
<li><p><code>BeanFactory</code>，直译Bean工厂，我们一般称<code>BeanFactory</code>为IoC容器只提供基本DI服务，而称<code>ApplicationContext</code>为应用上下文，派生于前者，提供更多服务,一般开放使用</p>
</li>
<li><p><code>ApplicationContext</code>是<code>BeanFactory</code>的子接口，最主要的方法就是<code>getBean(String beanName)</code>。</p>
</li>
</ul>
<p>两者有一个显著区别，前者在使用时才创建对象，后者一加载配置文件时就创建对象</p>
<h1 id="Bean的生命周期及管理"><a href="#Bean的生命周期及管理" class="headerlink" title="Bean的生命周期及管理"></a>Bean的生命周期及管理</h1><p>Spring通过应用上下文将所有的将bean组件装配在一起，就可形成一个完整的应用</p>
<h2 id="Beam的生命周期"><a href="#Beam的生命周期" class="headerlink" title="Beam的生命周期"></a>Beam的生命周期</h2><ul>
<li><p><strong>bean的生命周期</strong></p>
<p><img src="/images/image-20210303162631404.png" alt="image-20210303162631404"></p>
<p>首先明确通常意义bean的生命周期是指默认的单例模式，如果是原型模式，容器在初始化、配置、装饰或者是装配完一个prototype实例后，将它交给客户端，随后就不再管理该实例</p>
<p>在上诉图中，bean主要有四个生命周期</p>
<ul>
<li>实例化：调用构造函数进行实例化，<strong>Spring默认调用无参构造函数</strong></li>
<li>属性填充：依赖注入bean的值和引用</li>
<li>初始化：如果bean实现了<code>InitializingBean</code>接口，spring将调用它的<code>afterPropertiesSet</code>接口方法，如果Bean在Spring配置文件中配置了<code>init-method</code>属性会自动调用其配置的初始化方法</li>
<li>销毁:若bean实现了DisposableBean接口，spring将调用它的distroy()接口方法。同样的，如果bean使用了destroy-method属性声明了销毁方法，则该方法被调用；</li>
</ul>
<p>上诉只是主要的生命周期，而实际上还有不少的扩展点比如诸多Aware类型的接口的作用就是让我们能够拿到Spring容器中的一些资源，其在初始化之前调用,并且只能作用于单一的bean，是bean级生命周期</p>
<p>实例化时期间的<code>InstantiationAwareBeanPostProcessor</code>和初始化之前的<code>BeanPostProcessor</code>接口的这些后处理器方法作用于每一个bean，是容器级生命周期</p>
</li>
<li><p><strong>bean的作用域：</strong></p>
<p><img src="/images/image-20200924104801025.png" alt="image-20200924104801025"></p>
<ul>
<li>request、session和global session三种作用域仅在基于web的应用中使用，只能用在基于web的Spring ApplicationContext环境。</li>
<li>singleton是单列模式，是bean作用域的默认形式，创建起容器时就自动创建了一个bean对象，之后每次返回都是这个对象</li>
<li>prototype表示一个bean对象可以创建多个对象实例，仅在需要获取对象的时候才创建实例</li>
<li>singleton和prototype区别：能对一个prototype bean的整个生命周期负责：容器在初始化、配置、装饰或者是装配完一个prototype实例后，将它交给客户端，随后就不再管理该实例</li>
</ul>
</li>
</ul>
<h2 id="xml管理bean"><a href="#xml管理bean" class="headerlink" title="xml管理bean"></a>xml管理bean</h2><ul>
<li><p><strong>实例化</strong></p>
<ul>
<li>无参构造方法实例化</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hello&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.example.Hello&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>有参构造方法实例化</li>
</ul>
<p>在之前的hello类中添加一有参构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hello</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>再在xml中配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hello&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.example.Hello&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;constructor&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/images/image-20210303170847683.png" alt="image-20210303170847683"></p>
</li>
<li><p><strong>依赖注入</strong></p>
<ul>
<li><p>注入属性(setter方法注入，即该类有对应的setter方法)</p>
<p>如之前入门实例</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hello&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.example.Hello&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Spring&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>注入对象</p>
<p>我们新建一个<code>ControlHello</code>类，持有一个Hello对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControlHello</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span>  Hello hello;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myControl</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; control &quot;</span> + <span class="string">&quot;say hello!&quot;</span>);</span><br><span class="line">        hello.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHello</span><span class="params">(Hello hello)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hello = hello;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用ref注入对象</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hello&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.example.Hello&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;constructor&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;c&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.example.ControlHello&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;helloControl&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hello&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;hello&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>集合属性注入</p>
<p>新建一个Student类如下,包含对应的属性和setter方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Integer&gt; scores;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Course&gt; courses;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScores</span><span class="params">(Map&lt;String, Integer&gt; scores)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.scores = scores;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCourses</span><span class="params">(List&lt;Course&gt; courses)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.courses = courses;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, scores=&quot;</span> + scores +</span><br><span class="line">                <span class="string">&quot;, courses=&quot;</span> + courses +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>创建一个Course类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Course</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String tea;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTea</span><span class="params">(String tea)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tea = tea;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Course&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;CollectionBean.xml&quot;</span>);</span><br><span class="line">        Student student = (Student) context.getBean(<span class="string">&quot;stu&quot;</span>);</span><br><span class="line">        System.out.println(student.toString());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时我们尝试利用xml来为集合注入属性</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;stu&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.example.Student&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Andy&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;courses&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;course1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;course2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;course3&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.example.Course&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Hadoop&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;scores&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;计算机网络&quot;</span> <span class="attr">value</span>=<span class="string">&quot;91&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;深度学习&quot;</span> <span class="attr">value</span>=<span class="string">&quot;94&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;Hadoop&quot;</span> <span class="attr">value</span>=<span class="string">&quot;88&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;course1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.example.Course&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;计算机网络&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;course2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.example.Course&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;程度学习&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当需要多个属性时，声明其对应的type就可以添加多组值</p>
<p>注意一下ref对应的是对象</p>
</li>
</ul>
</li>
<li><p><strong>bean的作用域</strong></p>
<p>前面已知bean默认是单例对象，可以通过Scope属性设置为原型模式</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;c&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.example.ControlHello&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;helloControl&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hello&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;hello&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>两者处理除上述生命周期管理有区别外，创建的时机也有区别，几乎就是<code>BeanFactory</code>和<code>ApplicationContext</code>的区别</p>
</li>
</ul>
<h2 id="注解管理bean"><a href="#注解管理bean" class="headerlink" title="注解管理bean"></a>注解管理bean</h2><p>使用注解可以简化xml文件配置，</p>
<p>Spring管理bean中的注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>:设置配置类</span><br><span class="line"><span class="meta">@ComponScan</span>:设置扫描路径</span><br><span class="line"><span class="meta">@Component</span>:表明此类是bean</span><br><span class="line"><span class="meta">@AutoWired</span>: 根据属性类型注入，指注入对象</span><br><span class="line"><span class="meta">@Qualifier</span>:根据属性名称进行注入，指注入对象</span><br><span class="line"><span class="meta">@Resource</span>:可以根据类型或名称注入,javax包中，指注入对象</span><br><span class="line"><span class="meta">@Value</span>：注入普通类型属性</span><br></pre></td></tr></table></figure>
<p>步骤</p>
<ul>
<li><p>通过设置一个配置类</p>
<p>@Configuration:设置配置类<br>@ComponScan:设置扫描范围，来代替xml文件的作用</p>
</li>
<li><p>通过@Component注解一个类，表明此类是bean，又通过</p>
<p>@AutoWired: 根据属性类型注入，指注入对象<br>@Qualifier:根据属性名称进行注入，指注入对象，如果属性类型有多种，就再用这个<br>@Resource:可以根据类型或名称注入,javax包中，指注入对象，推荐使用上面两个组合<br>@Value：注入普通类型的属性</p>
<p>等注解来注入属性</p>
</li>
<li><p>在建立运用上下文时，标明的是配置类的类名，就可以利用其生成bean对象了</p>
</li>
</ul>
<p>下面是一个没有xml文件的Spring注解综合实例</p>
<p><strong>配置类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span> <span class="comment">// 设置配置类，代替xml文件</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.springioc&quot;&#125;)</span> <span class="comment">// 确定扫描空间</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>bean类</strong></p>
<p>Course</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.springioc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Course</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value( value =  &quot;计网&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Course&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Student</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.springioc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Scope;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(value = &quot;Andy&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Course course;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, course=&quot;</span> + course +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfigTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(SpringConfig.class);</span><br><span class="line">        System.out.println(context.getBean(<span class="string">&quot;student&quot;</span>).toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<p><img src="/images/image-20210303210646137.png" alt="image-20210303210646137"></p>
<h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><p>即面向切面编程，可以对业务逻辑的各个部分进行隔离从而使业务的耦合度降低，提高程序可重用性和开发效率</p>
<p>我们如果把把功能分为<strong>核心业务功能</strong>，和<strong>周边功能</strong>。<br>所谓的核心业务，比如登陆，增加数据，删除数据都叫核心业务<br>所谓的周边功能，比如性能统计，日志，事务管理等等</p>
<p>周边功能在Spring的面向切面编程AOP思想里，即被定义为<strong>切面</strong></p>
<p>在面向切面编程AOP的思想里面，核心业务功能和切面功能分别<strong>独立进行开发</strong><br>然后把切面功能和核心业务功能 <strong>“编织”</strong> 在一起，这就叫AOP</p>
<p>其实和代理模式比较像，就是在不修改核心业务代码的前提下，增加其功能。</p>
<h2 id="AOP底层原理"><a href="#AOP底层原理" class="headerlink" title="AOP底层原理"></a>AOP底层原理</h2><p><strong>动态代理</strong></p>
<ul>
<li>如果有接口，则使用jDK的动态代理</li>
</ul>
<p>即类似于在设计模式中的动态代理，使用<code>InvocationHandler</code>接口和<code>Proxy</code>类实现接口类，增强接口的功能</p>
<ul>
<li><p>如果没有接口，使用了CGLIB动态代理</p>
<p>创建当前类子类的代理对象增强功能</p>
</li>
</ul>
<h2 id="一个AOP实例（基于注解）"><a href="#一个AOP实例（基于注解）" class="headerlink" title="一个AOP实例（基于注解）"></a>一个AOP实例（基于注解）</h2><ul>
<li><strong>环境配置（引入依赖）</strong></li>
</ul>
<p>Spring的AOP实际是利用aspectJ框架实现，除了上诉入门实例引入的依赖，需要在Maven项目中的pom文件中引入aspectj的相关依赖，下载相关资源</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjrt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>同上，可以在<code>src/main</code>目录下新建一个resources文件夹，将其设置为Resources Root （右键设置</p>
<p>最后生成一个该项目的Spring xml配置文件</p>
<p>（前面我们完全基于注解完成，用注解类代替xml，这里我们尝试利用两者共同工作）</p>
<ul>
<li><strong>基础知识和继承类</strong></li>
</ul>
<p>首先了解一些AOP的一些术语</p>
<p>连接点：可以被增强的方法</p>
<p>切入点：实际增强的方法</p>
<p>通知：实际增强的逻辑部分：有前置、后置、环绕、异常、最终通知</p>
<p>切面：把通知应用到切入点的过程</p>
<p>了解这些术语后我们首先创建一个用户类，包含核心业务，之后在创建一个增强类，增加日志的辅助功能</p>
<p>用户类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.springaop;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">core</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;核心业务执行中&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>增强类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.springaop;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserProxy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        SimpleDateFormat formatter = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd  HH:mm:ss&quot;</span>);</span><br><span class="line">        Date date = <span class="keyword">new</span> Date(System.currentTimeMillis());</span><br><span class="line">        System.out.println(<span class="string">&quot;业务执行时间:&quot;</span>+formatter.format(date));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>xml文件配置</strong></p>
<p>之前我们是用注解开启来组件扫描的区域，这里我们用在Spring xml文件进行配置，需要先导入context名称空间，在context中确定要扫描的区域</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd   </span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.springaop&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspectj-autoproxy</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>最后利用<code>&lt;context:component-scan base-package=&quot;com.springaop&quot;&gt;&lt;/context:component-scan&gt;</code>,确定扫描的包</p>
<p>此外，在这里我们还加入了aop的命名空间，目的在于利用<code>&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;</code>可以自动生成功能增强的代理类</p>
</li>
<li><p><strong>增加对应注解</strong></p>
</li>
</ul>
<p>首先这两个类都是bean，都需要增加<code>@Component</code>注解</p>
<p>当增强方法是，我们要知道，哪个类是增强类，需要添加<code>@Aspect</code>注解</p>
<p>前面说到通知有五种：有前置、后置、环绕、异常、返回通知，对应以下注解</p>
<p><img src="/images/image-20210306164521962.png" alt="image-20210306164521962"></p>
<p>我们将对应的通知弄到增强类的对应方法上，这里是一个日志，我设为<code>@Before</code></p>
<p>最后一步，确定该增强的方法给谁增强，即找到正确的切入点</p>
<p>这里有一个切入点表达式</p>
<p><code>execution([返回类型][类全路径][方法名称]([参数列表]))</code></p>
<p>Spring 通过这个正则表达式判断具体要拦截的是哪一个类的哪一个方法</p>
<p>将这个切点表达式放在<code>@Before</code>注解的值里即可</p>
<p>最终注解代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">core</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;核心业务执行中&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个顶级类是分开的，这里只是为了便于观察</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserProxy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Before( value = &quot;execution(* com.springaop.User.core())&quot;)</span></span><br><span class="line">    <span class="comment">// 切点表达式是*表示任意返回值，之后是包路径里面User类的被增强的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        SimpleDateFormat formatter = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd  HH:mm:ss&quot;</span>);</span><br><span class="line">        Date date = <span class="keyword">new</span> Date(System.currentTimeMillis());</span><br><span class="line">        System.out.println(<span class="string">&quot;业务执行时间:&quot;</span>+formatter.format(date));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>结果</p>
<p>我们可以在一个Test中查看最后的结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;aopBean.xml&quot;</span>);</span><br><span class="line">        User user = (User) context.getBean(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        user.core();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/image-20210306165608843.png" alt="image-20210306165608843"></p>
</li>
</ul>
<p>可以发现，我们只是创建了一个User bean，但是Spring直到帮我们创建了代理类，并成功将其日志方法增加到了核心业务执行前，实现了核心业务和周边事物的解耦</p>
]]></content>
      <categories>
        <category>框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指18-删除链表的节点</title>
    <url>/2021/03/03/%E5%89%91%E6%8C%8718-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<p><strong>剑指 Offer 18. 删除链表的节点</strong></p>
<p><a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/">力扣链接</a></p>
<a id="more"></a>

<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p>
<p>返回删除后的链表的头节点。</p>
<p><strong>注意：</strong>此题对比原题有改动</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: head &#x3D; [4,5,1,9], val &#x3D; 5</span><br><span class="line">输出: [4,1,9]</span><br><span class="line">解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: head &#x3D; [4,5,1,9], val &#x3D; 1</span><br><span class="line">输出: [4,5,9]</span><br><span class="line">解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ul>
<li>题目保证链表中节点的值互不相同</li>
<li>若使用 C 或 C++ 语言，你不需要 <code>free</code> 或 <code>delete</code> 被删除的节点</li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>该题对剑指Offer书上的题目有了修改，在本题基础下，我们需要找到被删除的节点，由于由于找到的节点需要被删除，我们可以找到其前一个指针pre，方便删除，注意考虑删除节点就是头结点的特殊情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteNode</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.val == val)</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">        ListNode pre;</span><br><span class="line">        pre = head;</span><br><span class="line">        <span class="keyword">while</span>(pre.next.val != val)&#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.next = pre.next.next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="题目进阶"><a href="#题目进阶" class="headerlink" title="题目进阶"></a>题目进阶</h1><p>如果将题目给定<strong>单向链表的头指针和一个要删除的节点的值</strong>改为给<strong>定单向链表的头指针和一个要删除的节点的指针</strong>，是否有更简便的方法</p>
<p>这时候如果还是从头结点遍历，时间复杂度是O(n),如果认为<strong>要删除的节点节点值不在就是删除</strong>的话，我们可以把删除节点的节点值改为下一个节点值，并指向下一个节点的next指针，达到删除的目的，这时时间复杂度是O(1)</p>
<p>下面是在原题的基础上进行的修改，多了个findNode函数将题意转化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteNode</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode cur = findNode(head,val);</span><br><span class="line">        <span class="keyword">if</span>(cur == head)</span><br><span class="line">            <span class="keyword">return</span> head.next;</span><br><span class="line">        <span class="keyword">if</span>(cur.next == <span class="keyword">null</span>)</span><br><span class="line">              &#123;   <span class="comment">// 待删除节点为尾节点,这里也要了解Java值的传递方式</span></span><br><span class="line">            ListNode pre = head;</span><br><span class="line">            <span class="keyword">while</span> (pre.next != cur)&#123;</span><br><span class="line">                pre = pre.next;</span><br><span class="line">            &#125;</span><br><span class="line">            pre.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">        cur.val = cur.next.val;</span><br><span class="line">        cur.next = cur.next.next;&#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">findNode</span><span class="params">(ListNode head,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head.val == val)</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>剑指Offer</category>
        <category>算法</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指20-表示数值的字符串</title>
    <url>/2021/03/03/%E5%89%91%E6%8C%8720-%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>剑指 Offer 20. 表示数值的字符串</p>
<p><a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/">力扣链接</a></p>
<a id="more"></a>

<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”、”5e2”、”-123”、”3.1416”、”-1E-16”、”0123”都表示数值，但”12e”、”1a3.14”、”1.2.3”、”+-5”及”12e+5.4”都不是。</p>
<h1 id="思路一：正常处理"><a href="#思路一：正常处理" class="headerlink" title="思路一：正常处理"></a>思路一：正常处理</h1><p>思路见注释，就是正常遍历，然后考虑到各种情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumber</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// s为空对象或 s长度为0(空字符串)时, 不能表示数值</span></span><br><span class="line">        <span class="keyword">boolean</span> isNum = <span class="keyword">false</span>, isDot = <span class="keyword">false</span>, ise_or_E = <span class="keyword">false</span>; <span class="comment">// 标记是否遇到数位、小数点、‘e’或&#x27;E&#x27;</span></span><br><span class="line">        <span class="keyword">char</span>[] str = s.trim().toCharArray();  <span class="comment">// 删除字符串头尾的空格，转为字符数组，方便遍历判断每个字符</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;str.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; str[i] &lt;= <span class="string">&#x27;9&#x27;</span>) isNum = <span class="keyword">true</span>; <span class="comment">// 判断当前字符是否为 0~9 的数位</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">&#x27;.&#x27;</span>) &#123; <span class="comment">// 遇到小数点</span></span><br><span class="line">                <span class="keyword">if</span>(isDot || ise_or_E) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 小数点之前可以没有整数，但是不能重复出现小数点、或出现‘e’、&#x27;E&#x27;</span></span><br><span class="line">                isDot = <span class="keyword">true</span>; <span class="comment">// 标记已经遇到小数点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">&#x27;e&#x27;</span> || str[i] == <span class="string">&#x27;E&#x27;</span>) &#123; <span class="comment">// 遇到‘e’或&#x27;E&#x27;</span></span><br><span class="line">                <span class="keyword">if</span>(!isNum || ise_or_E) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// ‘e’或&#x27;E&#x27;前面必须有整数，且前面不能重复出现‘e’或&#x27;E&#x27;</span></span><br><span class="line">                ise_or_E = <span class="keyword">true</span>; <span class="comment">// 标记已经遇到‘e’或&#x27;E&#x27;</span></span><br><span class="line">                isNum = <span class="keyword">false</span>; <span class="comment">// 重置isNum，因为‘e’或&#x27;E&#x27;之后也必须接上整数，防止出现 123e或者123e+的非法情况</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">&#x27;-&#x27;</span> ||str[i] == <span class="string">&#x27;+&#x27;</span>) &#123; </span><br><span class="line">                <span class="keyword">if</span>(i!=<span class="number">0</span> &amp;&amp; str[i-<span class="number">1</span>] != <span class="string">&#x27;e&#x27;</span> &amp;&amp; str[i-<span class="number">1</span>] != <span class="string">&#x27;E&#x27;</span>) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 正负号只可能出现在第一个位置，或者出现在‘e’或&#x27;E&#x27;的后面一个位置</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 其它情况均为不合法字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路二：DFA"><a href="#思路二：DFA" class="headerlink" title="思路二：DFA"></a>思路二：DFA</h1><p>该题也可以用确定有限状态机来做，我们可以进简单的预处理，减少状态数</p>
<ul>
<li>预处理，利用trim()去掉首尾空格，如果第一位是符号，并且去掉一个符号位，这样一个数值应该是以下形式：<code>整数部分 . 小数部分 e||E 符号位 指数部分</code></li>
<li>记以上状态为0,1,2,3,4,5，并且分析其遇到遇到数字、小数点、指数、符号位的状态变化得到状态表</li>
<li>最后利用状态表进行状态转化，通过最后状态是否合法确定其是否为数值</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] state = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">7</span>&#125;,&#123;<span class="number">2</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">7</span>&#125;,&#123;<span class="number">2</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">7</span>&#125;,&#123;<span class="number">5</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>&#125;,&#123;<span class="number">5</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>&#125;&#125;;</span><br><span class="line">      <span class="comment">// 该题比较难受、题意不清晰，开头可能会出现空格，进行需预处理</span></span><br><span class="line">        <span class="comment">// 预处理，利用trim()去掉收尾空格，如果第一位是符号，并且去掉一个符号位，这样一个数值应该是以下形式</span></span><br><span class="line">        <span class="comment">// 整数部分 . 小数部分 e||E 符号位 指数部分，记以上状态为0,1,2,3,4,5，并默认处理后字符串初始状态为</span></span><br><span class="line">        <span class="comment">// 如果最后状态处于0,2,5,肯定是数值，进入1时的保证左右两边至少有个数字，并且设置一个异常态记7</span></span><br><span class="line">        <span class="comment">// 现在不同状态遇到数字、小数点、指数、符号位 变化如下</span></span><br><span class="line">        <span class="comment">//    整数对应变化: 0     1      3     7</span></span><br><span class="line">        <span class="comment">//  小数点对应变化: 2     7      3     7</span></span><br><span class="line">        <span class="comment">//    小数部分变化: 2     7      3     7</span></span><br><span class="line">        <span class="comment">//           指数：5     7       7     4</span></span><br><span class="line">        <span class="comment">//           符号：5     7       7     7</span></span><br><span class="line">        <span class="comment">//        指数部分：5     7       7     7</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&#x27;0&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&#x27;e&#x27;</span> || c== <span class="string">&#x27;E&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumber</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        s = s.trim();</span><br><span class="line">        <span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="comment">// 前处理去掉最开始符号位</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; n &amp;&amp; (str[i] == <span class="string">&#x27;+&#x27;</span> || str[i] == <span class="string">&#x27;-&#x27;</span>))</span><br><span class="line">            i++;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span>(i &gt;= n)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 判断起始状态是否合理</span></span><br><span class="line">        <span class="keyword">int</span> begin = getNum(str[i++]);</span><br><span class="line">        <span class="keyword">if</span>(begin == <span class="number">0</span> || (begin == <span class="number">1</span> &amp;&amp; i  &lt; n &amp;&amp; getNum(str[i]) == <span class="number">0</span>) )&#123;</span><br><span class="line">            <span class="keyword">while</span>(i  &lt; n )&#123;</span><br><span class="line">                </span><br><span class="line">                    <span class="keyword">int</span> num = getNum(str[i++]);</span><br><span class="line">                    <span class="keyword">if</span>(num == -<span class="number">1</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    begin = state[begin][num];</span><br><span class="line">                    <span class="keyword">if</span>(begin == <span class="number">7</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> &lt;= begin &amp;&amp; begin &lt;= <span class="number">2</span> || begin == <span class="number">5</span> )</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="思路三：正则表达式"><a href="#思路三：正则表达式" class="headerlink" title="思路三：正则表达式"></a>思路三：正则表达式</h1><p>具体正则表达式规则见该算法、字符串分类下文章</p>
<p>该题的正则表达式可以描述为</p>
<p><code>^[+|-]?((\\d+\\.?)|(\\d*\\.?\\d+))([E|e][+|-]?\\d+)?$</code></p>
<p>则可以直接用正则表达式搞定</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumber</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        String regex = <span class="string">&quot;^[+|-]?((\\d+\\.?)|(\\d*\\.?\\d+))([E|e][+|-]?\\d+)?$&quot;</span>;</span><br><span class="line">       <span class="keyword">return</span> s.trim().matches(regex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>可能正常在面试中前两种方法比较受欢迎，而值得一提的是，一般正则表达式也是由有限状态机实现的，不过一般是NFA</p>
]]></content>
      <categories>
        <category>剑指Offer</category>
        <category>算法</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>状态机</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指22-链表倒数第k个结点</title>
    <url>/2021/03/06/%E5%89%91%E6%8C%8722-%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<p><strong>剑指 Offer 22. 链表中倒数第k个节点</strong></p>
<p><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">力扣链接</a></p>
<a id="more"></a>

<p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</p>
<p>例如，一个链表有 <code>6</code> 个节点，从头节点开始，它们的值依次是 <code>1、2、3、4、5、6</code>。这个链表的倒数第 <code>3</code> 个节点是值为 <code>4</code> 的节点。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k &#x3D; 2.</span><br><span class="line"></span><br><span class="line">返回链表 4-&gt;5.</span><br></pre></td></tr></table></figure>
<h1 id="思路一：递归"><a href="#思路一：递归" class="headerlink" title="思路一：递归"></a>思路一：递归</h1><p>注意前面一道剑指Offer题目，从尾到头打印指针，跟链表倒序有关的题目，一般可以利用递归的特性实现</p>
<p>我们可以采用递归，递归到链表尾部开始计数，计数到倒数第k个打印其值即可，代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getKthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode ans = getKthFromEnd(head.next,k);</span><br><span class="line">        <span class="keyword">if</span>(++p &gt; k)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路二：快慢双指针"><a href="#思路二：快慢双指针" class="headerlink" title="思路二：快慢双指针"></a>思路二：快慢双指针</h1><p>该题也可以用双指针法来解决，让块指针先走k步，两个再同速前进，那么当快指针到尾部时，慢指针恰好是倒数第k个</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getKthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode low = head;</span><br><span class="line">        <span class="keyword">while</span>(k-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            low = low.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指Offer</category>
        <category>算法</category>
        <category>链表</category>
        <category>双指针</category>
        <category>递归</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指24-反转链表</title>
    <url>/2021/03/06/%E5%89%91%E6%8C%8724-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p><strong>剑指 Offer 24. 反转链表</strong></p>
<p><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/">力扣链接</a></p>
<a id="more"></a>

<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure>
<p><strong>限制：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 &lt;&#x3D; 节点个数 &lt;&#x3D; 5000</span><br></pre></td></tr></table></figure>
<h1 id="思路一：头插法"><a href="#思路一：头插法" class="headerlink" title="思路一：头插法"></a>思路一：头插法</h1><p>典型的链表题目，采用头插法可以将链表结构改变，变成倒序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode begin = head.next;</span><br><span class="line">        <span class="comment">// 设置头结点，方便头插</span></span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        ListNode temp;</span><br><span class="line">        <span class="keyword">while</span>(begin != <span class="keyword">null</span>)&#123;</span><br><span class="line">            temp = begin.next;</span><br><span class="line">            begin.next = head;</span><br><span class="line">            head = begin;</span><br><span class="line">            begin = temp;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路二：递归"><a href="#思路二：递归" class="headerlink" title="思路二：递归"></a>思路二：递归</h1><p>联系一下上面的文章，有说到，对于链表倒序的问题，很有可能可以使用递归解决</p>
<p>我们递归到最后一层时，知道最后一个节点是头节点，肯定需要将这个值返回，之后再将这个结点指向上一个节点，但是这里注意，为了方便达成这个指向操作，我们可以在上一层进行（因为上一层可以有这个节点和上一个节点），如此，就有代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="comment">// 最后一个节点是新头结点，记录返回</span></span><br><span class="line">        ListNode ans = reverseList(head.next);</span><br><span class="line">        <span class="comment">// 在上一层时完成反转操作</span></span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>头插法大家都了解，注意这点为了方便利用两个指针，在上一层进行反转的操作，就有像想我们迭代删除节点时，记录的是pre指针</p>
]]></content>
      <categories>
        <category>剑指Offer</category>
        <category>算法</category>
        <category>链表</category>
        <category>递归</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指21-调整数组奇偶顺序</title>
    <url>/2021/03/06/%E5%89%91%E6%8C%8721-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E5%A5%87%E5%81%B6%E9%A1%BA%E5%BA%8F/</url>
    <content><![CDATA[<p><strong>剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</strong></p>
<h4 id="力扣链接"><a href="#力扣链接" class="headerlink" title="力扣链接"></a><a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">力扣链接</a></h4><a id="more"></a>

<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3,4]</span><br><span class="line">输出：[1,3,2,4] </span><br><span class="line">注：[3,1,2,4] 也是正确的答案之一</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>0 &lt;= nums.length &lt;= 50000</code></li>
<li><code>1 &lt;= nums[i] &lt;= 10000</code></li>
</ol>
<h1 id="思路一：首尾双指针"><a href="#思路一：首尾双指针" class="headerlink" title="思路一：首尾双指针"></a>思路一：首尾双指针</h1><p>典型的双指针题目，而且这种调整顺序的题目，很容易想到快排的partition部分，一左一右</p>
<p>我们假设有左右两个指针位于首尾，如果是奇数左指针右移，如果是偶数右指针左移，当不移动时交换两个指针的值，直到两指针相遇，说明已经排好</p>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] exchange(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; (nums[i] &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; (nums[j] &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">                j--;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; j)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[j];</span><br><span class="line">                nums[j] = nums[i];</span><br><span class="line">                nums[i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路二：快慢双指针"><a href="#思路二：快慢双指针" class="headerlink" title="思路二：快慢双指针"></a>思路二：快慢双指针</h1><p>快慢指针也是双指针题目中常见的一种类型</p>
<p>假设慢指针左侧全是奇数，快指针寻找奇数，那么当快指针找到了一个奇数就可以和慢指针交换数值，慢指针就可以前移一位，直到快指针遍历完所有数组，不过这个方法，较之前者可能要遍历多一点点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] exchange(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">while</span>(fast &lt; n)&#123;</span><br><span class="line">            <span class="keyword">if</span>((nums[fast] &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">               </span><br><span class="line">                    </span><br><span class="line">                        <span class="keyword">int</span> temp = nums[fast];</span><br><span class="line">                        nums[fast] = nums[low];</span><br><span class="line">                        nums[low] = temp;</span><br><span class="line">                    </span><br><span class="line">                low++;</span><br><span class="line">                &#125;</span><br><span class="line">                fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>双指针问题中，对于同一个数组，一般有一前一后，相向而行或者是，一快一慢，同向而行两种思路，注意体会</p>
]]></content>
      <categories>
        <category>剑指Offer</category>
        <category>算法</category>
        <category>双指针</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>Servlet</title>
    <url>/2021/03/07/Servlet/</url>
    <content><![CDATA[<p>学习Spring MVC前，掌握Servlet的学习</p>
<a id="more"></a>

<h1 id="Servlet概念"><a href="#Servlet概念" class="headerlink" title="Servlet概念"></a>Servlet概念</h1><p>Java Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。</p>
<p><img src="/images/image-20210307164102396.png" alt="image-20210307164102396"></p>
<p>Servlet 本身不能独立运行，需要在一个web应用中运行，而一个web应用是部署在tomcat中的，所以开发一个servlet需要如下几个步骤<br>创建web应用项目<br>编写servlet代码<br>部署到tomcat中</p>
<p>下面我们首先学习一个基于IDEA的简单的实例来体会这个过程</p>
<h1 id="一个基于IDEA的简单Servlet实例"><a href="#一个基于IDEA的简单Servlet实例" class="headerlink" title="一个基于IDEA的简单Servlet实例"></a>一个基于IDEA的简单Servlet实例</h1><p>根据前面的三个步骤，我们首先要对IDEA进行一些准备</p>
<ul>
<li><p><strong>IDEA集成Tomcat</strong></p>
<p>具体见该博客框架分类下Tomcat的内容</p>
</li>
<li><p><strong>保证能创建Java web应用项目</strong></p>
<p>按ctrl+Alt+Shift+/快捷键，在registry中找到<code>javaee.legacy.project.wizard</code>确保其被勾上</p>
</li>
<li><p><strong>创建web应用项目</strong></p>
<p>新建一个project，选择Java EE，点击Web Application之后，next即可</p>
<p><img src="/images/image-20210307165241199.png" alt="image-20210307165241199"></p>
<p>之后就是命名不再赘述</p>
<p>下面是目录结构，out是运行后产生的，不用多管</p>
<p><img src="/images/image-20210307165803292.png" alt="image-20210307165803292"></p>
</li>
<li><p><strong>编写Servlet代码</strong></p>
<p>现在只是一个web项目，我们要在src下新建一个包，包里新建一个类继承HttpServlet才算一个Servlet项目</p>
<p>再重写HttpServlet类中的server方法，对HTTP请求进行处理，给出反馈</p>
<p>最后加上<code>@WebServlet(&quot;/hello&quot;)</code>注解，指定访问的路径</p>
<p>最后代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxx.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问路径最后以/hello结尾</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletLearn</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 处理请求的逻辑，这里是打印内容到控制台</span></span><br><span class="line">        System.out.println(<span class="string">&quot;hello servlet!&quot;</span>);</span><br><span class="line">        <span class="comment">// 通过流输出数据到浏览器</span></span><br><span class="line">        resp.getWriter().write(<span class="string">&quot;Hello Servlet!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>Tomcat部署</strong></p>
<p>在右上角Tomcat的下三角箭头进入Edit可以部署Tomcat 服务器</p>
<p><img src="/images/image-20210307170734812.png" alt="image-20210307170734812"></p>
<p>可以在这里看到访问URL，或者对URL进行一些修改</p>
<p><img src="/images/image-20210307170938986.png" alt="image-20210307170938986"></p>
</li>
<li><p><strong>运行及结果</strong></p>
<p>运行代码，服务器也在运行，找到之前部署的URL，在末尾加上我们设置访问路径hello <code>http://localhost:8088/s01/hello</code>在浏览器中访问</p>
<p>结果如下</p>
<p><img src="/images/image-20210307171341851.png" alt="image-20210307171341851"></p>
</li>
</ul>
<p>到此一个简单实例完成</p>
<h1 id="Servlet的继承体系和生命周期"><a href="#Servlet的继承体系和生命周期" class="headerlink" title="Servlet的继承体系和生命周期"></a>Servlet的继承体系和生命周期</h1><p>Servlet 是服务 HTTP 请求并实现 <strong>javax.servlet.Servlet</strong> 接口的 Java 类。下面是Servlet接口定义的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig var1)</span> <span class="keyword">throws</span> ServletException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ServletConfig <span class="title">getServletConfig</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest var1, ServletResponse var2)</span> <span class="keyword">throws</span> ServletException, IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getServletInfo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上诉接口的方法中也蕴含了Servlet的<strong>生命周期</strong>，下面是Servlet生命周期的过程：</p>
<ul>
<li><p>Servlet 初始化后调用 <strong>init ()</strong> 方法。</p>
</li>
<li><p>Servlet 调用 <strong>service()</strong> 方法来处理客户端的请求。</p>
</li>
<li><p>Servlet 销毁前调用 <strong>destroy()</strong> 方法。</p>
</li>
<li><p>最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。</p>
<p>整个Servlet工作的过程可以用下图描述</p>
<p><img src="/images/image-20210308152733195.png" alt="image-20210308152733195"></p>
</li>
<li><p>Servlet只初始化一次，它是单例的，只有一个实例，通过多线程访问。即Servlet是多线程单实例的</p>
</li>
<li><p>实例化过程中，先调用构造方法，再调用init方法，所以初始化操作可以覆盖写到init方法中，init 方法被设计成只调用一次。它在第一次创建 Servlet 时被调用，在后续每次用户请求时不再调用</p>
</li>
<li><p>service() 方法是执行实际任务的主要方法，Servlet 容器（即 Web 服务器）调用 service() 方法来处理来自客户端（浏览器）的请求，并把格式化的响应写回给客户端。</p>
</li>
<li><p>destroy() 方法只会被调用一次，在 Servlet 生命周期结束时被调用，在调用 destroy() 方法之后，servlet 对象被标记为垃圾回收</p>
</li>
</ul>
<p>上诉描述还有一个重点，在实际调用service()方法时，service() 方法检查 HTTP 请求类型（GET、POST、PUT、DELETE 等），并在适当的时候调用 doGet、doPost、doPut，doDelete 等方法。</p>
<p>但是我们的Servlet并没有实现这些方法，这时得看Servlet的<strong>继承体系</strong></p>
<p><img src="/images/image-20210308153321284.png" alt="image-20210308153321284"></p>
<p>所以，Web 应用程序开发人员通常编写 Servlet 来扩展 javax.servlet.http.HttpServlet，并实现 Servlet 接口的抽象类专门用来处理 HTTP 请求，我们所做的一般是继承HTTPServlet类，重写oGet、doPost定义自己的业务逻辑即可</p>
<p>这里可以做一个小验证，我们修改之前简单实例的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletLearn</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.init();</span><br><span class="line">        System.out.println(<span class="string">&quot;第&quot;</span>+count+<span class="string">&quot;次调用init()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello servlet!&quot;</span>+count);</span><br><span class="line">        resp.getWriter().write(<span class="string">&quot;Hello Servlet!&quot;</span>+count++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在网页上多次访问该资源，结果控制台情况如下</p>
<p><img src="/images/image-20210308155311695.png" alt="image-20210308155311695"></p>
<h1 id="HTTPServletRequest对象"><a href="#HTTPServletRequest对象" class="headerlink" title="HTTPServletRequest对象"></a>HTTPServletRequest对象</h1><p>该对象之后简称Request对象，该对象主要作用是接收客户端发送过来的请求信息，比如请求参数、头信息等，我们的HttpServlet 的service方法中的形参就是HttpServletRequest的实例化对象，由Tomcat封装好传递过来。</p>
<p>我们主要需要取出该对象中的数据、进行分析、处理</p>
<h2 id="Request常见方法"><a href="#Request常见方法" class="headerlink" title="Request常见方法"></a>Request常见方法</h2><p><strong>常见方法</strong></p>
<p>下列方法可以从request对象中获取相应的信息，其中，最重要的是前两个获取具体参数的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxx.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(&quot;/method&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestMethod</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 常用方法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取指定名称的参数</span></span><br><span class="line">        String  name = req.getParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;uname:&quot;</span> + name);</span><br><span class="line">        <span class="comment">// 获取指定参数所用值</span></span><br><span class="line">        String[] hobby = req.getParameterValues(<span class="string">&quot;hobby&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(hobby != <span class="keyword">null</span> &amp;&amp; hobby.length &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;hobby&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(String s : hobby)</span><br><span class="line">                System.out.print(s + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取请求时URL，完整路径,从http开始，到？前结束</span></span><br><span class="line">        String url = req.getRequestURL().toString();</span><br><span class="line">        System.out.println(<span class="string">&quot;url:&quot;</span> + url);</span><br><span class="line">        <span class="comment">// 获取请求时部分路径，从站点名，到？前结束</span></span><br><span class="line">        String uri = req.getRequestURI();</span><br><span class="line">        System.out.println(<span class="string">&quot;uri:&quot;</span> + uri);</span><br><span class="line">        <span class="comment">// 获取请求时所有参数</span></span><br><span class="line">        String str = req.getQueryString();</span><br><span class="line">        System.out.println(<span class="string">&quot;query string:&quot;</span> + str);</span><br><span class="line">        <span class="comment">// 获取请求方式</span></span><br><span class="line">        String method = req.getMethod();</span><br><span class="line">        System.out.println(<span class="string">&quot;method:&quot;</span> + method);</span><br><span class="line">        <span class="comment">// 获取当前协议版本</span></span><br><span class="line">        String protocol = req.getProtocol();</span><br><span class="line">        System.out.println(<span class="string">&quot;protocol:&quot;</span> + protocol);</span><br><span class="line">        <span class="comment">// 获取项目站点名，项目对外访问路径</span></span><br><span class="line">        String web = req.getContextPath();</span><br><span class="line">        System.out.println(web);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们此时<code>http://localhost:8088/request/method?name=Lucy&amp;hobby=sing&amp;hobby=dance&amp;hobby=rap</code></p>
<p>结果如下：</p>
<p><img src="/images/image-20210308172213170.png" alt="image-20210308172213170"></p>
<p><strong>获取头信息</strong></p>
<p><code>equest.getHeader(String s)</code>可以获取浏览器传递过来的头信息。<br><code>request.getHeaderNames() </code>获取浏览器所有的头信息名称，根据头信息名称就能遍历出所有的头信息</p>
<p>下面是一些常见的头信息</p>
<p>host: 主机地址<br>user-agent: 浏览器基本资料<br>accept: 表示浏览器接受的数据类型<br>accept-language: 表示浏览器接受的语言<br>accept-encoding: 表示浏览器接受的压缩方式，是压缩方式，并非编码<br>connection: 是否保持连接<br>cache-control: 缓存时限</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/method&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestMethod</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取头部信息</span></span><br><span class="line">        Enumeration&lt;String&gt; names = req.getHeaderNames();</span><br><span class="line">        <span class="keyword">while</span>(names.hasMoreElements())&#123;</span><br><span class="line">            String name = names.nextElement();</span><br><span class="line">            String info = req.getHeader(name);</span><br><span class="line">            System.out.println(name + <span class="string">&quot;: &quot;</span> + info);</span><br><span class="line">            resp.getWriter().println(name + <span class="string">&quot;: &quot;</span> + info);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/image-20210311134606550.png" alt="image-20210311134606550"></p>
<h2 id="乱码问题"><a href="#乱码问题" class="headerlink" title="乱码问题"></a>乱码问题</h2><p>原来的TomCat服务器有中文乱码问题，对于Request</p>
<ul>
<li><p>TomCat 7 以下 get 方法和post方法均有中文乱码问题,默认情况下，使用<code>getParameter()</code>请求参数时，默认使用的是ISO-8859-1编码，不支持中文</p>
<p>可以采用<code>req.setCharacterEncoding()</code>方式设置正文即实体编码，但此方法只对实体有效，也即只对post方法有效；get方法的参数在url中，得设置server配置文件或者利用<code>new String(name.getBytes(&quot;ISO-8859-1&quot;), &quot;UTF-8&quot;);</code>将参数转化为字节码后，再编码</p>
</li>
<li><p>TomCat 8 已经将get 方法的的url编码方法默认设为UTF-8，不会乱码，只需要考虑post方法</p>
</li>
<li><p>TomCat 10 当我测试乱码问题时发现无论是post还是get方法都很正常，查找文档发现使用<code>&lt;request-character-encoding&gt;</code>和 <code>&lt;response-character-encoding&gt;</code>in <code>conf/web.xml</code>将默认请求和响应字符编码设置为UTF-8，所以可能对于request不用再考虑中文乱码问题了</p>
</li>
</ul>
<h2 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a>请求转发</h2><p>请求转发属于服务器跳转，相当于方法调用，在执行当前文件的过程中转向执行目标文件，两个文件(当前文件和目标文件)属于同一次请求，前后页共用一个request，这时可以通过下列两个方法传递、获取一些参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">req.getRequestDispatcher(<span class="string">&quot;/loadfail.jsp&quot;</span>).forward(req,resp);<span class="comment">// 请求转发命令</span></span><br><span class="line">request.setAttribute() 设置参数</span><br><span class="line">request.getAttribute() 获取参数</span><br></pre></td></tr></table></figure>
<p>值得注意的是该跳转得在web应用内，即站内跳转，可以跳转到一个servlet、html、jsp，当然如果要使用数据的话，不能跳转到html，因为其是静态页面</p>
<h2 id="登陆界面制作"><a href="#登陆界面制作" class="headerlink" title="登陆界面制作"></a>登陆界面制作</h2><p>这里简单利用表单和请求转发做一个小demo</p>
<p>首先制作一个登陆的表单，利用post方法将其参数传递到我们的<code>method</code>Servlet中，我们再检测用户参数，利用请求转发跳转到登陆成功或者失败的界面</p>
<p>登陆表单</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;登录界面&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form action=<span class="string">&quot;method&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">   用户名： &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;uname&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">    密码：&lt;input type=<span class="string">&quot;password&quot;</span> name=<span class="string">&quot;psd&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">    &lt;button&gt;登陆&lt;/button&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>method逻辑处理和请求转发</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/method&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestMethod</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        String name = req.getParameter(<span class="string">&quot;uname&quot;</span>);</span><br><span class="line">        String psw = req.getParameter(<span class="string">&quot;psd&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;uname : &quot;</span> + name );</span><br><span class="line">        System.out.println(<span class="string">&quot;psw : &quot;</span> + psw );</span><br><span class="line">        req.setAttribute(<span class="string">&quot;name&quot;</span>,name);</span><br><span class="line">        <span class="keyword">if</span>(name == <span class="keyword">null</span> || psw == <span class="keyword">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            req.getRequestDispatcher(<span class="string">&quot;/loadfail.jsp&quot;</span>).forward(req,resp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            req.getRequestDispatcher(<span class="string">&quot;/loadok.jsp&quot;</span>).forward(req,resp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>登陆成功或者失败界面</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;登陆成功&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    String name = (String) request.getAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    System.out.println(name + request.getParameter(<span class="string">&quot;psd&quot;</span>));</span><br><span class="line">    response.getWriter().println(name + <span class="string">&quot;你好！&quot;</span>);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;登陆失败&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;登陆失败&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>登陆界面</p>
<p><img src="/images/image-20210311151913935.png" alt="image-20210311151913935"></p>
<p>请求跳转界面，注意地址没有改变</p>
<p><img src="/images/image-20210311151940188.png" alt="image-20210311151940188"></p>
<h1 id="HTTPServletRespose对象"><a href="#HTTPServletRespose对象" class="headerlink" title="HTTPServletRespose对象"></a>HTTPServletRespose对象</h1><p>Web服务器收到客户端的http请求，会针对每一次请求，分别创建一个用于代表请求的request对象、和代表响应的response对象。获取网页提交过来的数据，只需要找request对象就行了。要向网页输出数据，只需要找response对象。</p>
<p>HttpServletResponse对象代表服务器的响应。这个对象中封装了向客户端发送数据、发送响应头，发送响应状态码的方法。</p>
<h2 id="消息响应"><a href="#消息响应" class="headerlink" title="消息响应"></a>消息响应</h2><p>Response向客户端发送数据主要使用下面两种方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getOutputStream() 该方法用于返回Servlet引擎创建的字节输出流对象，Servlet程序可以按字节形式输出响应正文。   </span><br><span class="line">getWriter() 该方法用于返回Servlet引擎创建的字符输出流对象，Servlet程序可以按字符形式输出响应正文。</span><br></pre></td></tr></table></figure>
<p>需要注意</p>
<ul>
<li><p>getOutputStream()和getWriter()这两个方法互相排斥，调用了其中的任何一个方法后，就不能再调用另一方法。</p>
</li>
<li><p>getOutputStream()返回的字节输出流对象，类型为：ServletOutputStream，直接输出字节数组中的二进制数据。</p>
</li>
<li><p>getWriter()方法将Servlet引擎的数据缓冲区包装成PrintWriter类型的字符输出流对象后返回，PrintWriter对象只能输出字符文本内容</p>
</li>
</ul>
<h2 id="乱码问题-1"><a href="#乱码问题-1" class="headerlink" title="乱码问题"></a>乱码问题</h2><p>response在响应时也可能会有乱码问题，其原因在于服务器和客户端的编码方式不一致</p>
<p>同request一样，我们可以使用<code>setCharacterEncoding()</code>方式设置正文即实体编码为UTF-8,但是如果客户端没有使用相同的编码也会出现乱码问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/output&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutPut</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        resp.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        resp.getWriter().println(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/image-20210311164049627.png" alt="image-20210311164049627"></p>
<p>可以通过设置响应对象头，确保浏览器或者客户端的编码方式也为”UTF-8”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/output&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutPut</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        resp.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        resp.setHeader(<span class="string">&quot;content-type&quot;</span>, <span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">        resp.getWriter().println(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/image-20210311164317137.png" alt="image-20210311164317137"></p>
<p>更简洁的方法，还是利用<code>setContentType(&quot;text/html;charset=UTF-8&quot;)</code>,该方法可以控制服务器和浏览器的编码方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/output&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutPut</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">        resp.getWriter().println(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后，我并没有设置<code>resp.setCharacterEncoding(&quot;UTF-8&quot;)</code>,仅控制了客户端的编码也是正常的，可见TomCat 10 以后应该默认是UTF-8</p>
<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p>利用<code>resp.sendRedirect(String s)</code>,可以实现重定向</p>
<p>重定向是指一个web资源收到客户端请求后，通知客户端去访问另外一个web资源，这称之为请求重定向</p>
<p>重定向与请求转发主要区别：在于是否能跨域以及请求转发是一次请求，重定向是两次请求 </p>
<h2 id="文件下载demo"><a href="#文件下载demo" class="headerlink" title="文件下载demo"></a>文件下载demo</h2><p>了解response后，需要学会利用其做一些小demo，比如文件下载、页面自动刷新、生成验证码图片等</p>
<p>下面是一个文件下载的小demo</p>
<p>首先可以在web应用中建立一个资源文件夹，作为存储供下载文件的文件夹，这里我命名为download</p>
<p><img src="/images/image-20210312202353988.png" alt="image-20210312202353988"></p>
<p>设置一个download.jsp页面，打开这个界面可以呈现资源的下载链接</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;下载资源&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;a href=&quot;/response/do?fileName=捕获.JPG&quot;&gt;图片&lt;/a&gt;</span><br><span class="line">&lt;a href=&quot;/response/do?fileName=捕获.docx&quot;&gt;文档&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>效果如下</p>
<p><img src="/images/image-20210312202703167.png" alt="image-20210312202703167"></p>
<p>下载文件的链接指向我们定义的一个servlet类，传递文件名作为参数</p>
<p>我们就在这个servlet类中进行下载处理，代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(&quot;/do&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DownloadFile</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        download(req, resp);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        download(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">download</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span><span class="keyword">throws</span> ServletException, IOException</span>&#123;</span><br><span class="line">        </span><br><span class="line">        resp.setContentType(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取文件名</span></span><br><span class="line">        String filename = req.getParameter(<span class="string">&quot;fileName&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取资源所在位置的决对路径</span></span><br><span class="line">        String path = req.getServletContext().getRealPath(<span class="string">&quot;/download/&quot;</span> + filename);</span><br><span class="line">        <span class="comment">// 设置响应对象头，使浏览器以附件方式打开资源</span></span><br><span class="line">        resp.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>,<span class="string">&quot;attachment;filename=&quot;</span>+filename);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 下载资源的步骤</span></span><br><span class="line">        FileInputStream in = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line">     </span><br><span class="line">        ServletOutputStream out = resp.getOutputStream();</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span>((len = in.read(bytes)) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            out.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        in.close();</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中下载资源步骤就是设置文件输入流，设置文件输出流、创建一个缓存数组，读写文件的过程</p>
<h1 id="Cookie和Session"><a href="#Cookie和Session" class="headerlink" title="Cookie和Session"></a>Cookie和Session</h1><p>我们认为会话是指客户端和web服务器之间连续发生的一系列请求和响应的过程，而Cookie和Session的作用就在于保存会话过程中产生的数据</p>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p> 当用户通过浏览器访问Web服务器时，服务器会给客户端发送一些信息，这些信息会保存在Cookie中。这样，当浏览器再次访问服务器时，会在请求头中将Cookie发送给服务器，方便服务器对浏览器做出正确的响应。 </p>
<p>下面是一个简单的Cookie学习demo</p>
<p>首先做个一个post的登陆界面表单</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;load...&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form method=<span class="string">&quot;post&quot;</span> action=<span class="string">&quot;co&quot;</span>&gt;</span><br><span class="line">    用户名：&lt;input name=<span class="string">&quot;uname&quot;</span> type=<span class="string">&quot;text&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">    密码：&lt;input name=<span class="string">&quot;psd&quot;</span> type=<span class="string">&quot;password&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">    &lt;button&gt;登陆&lt;/button&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>由于收到post方法的数据，所以重写doPost方法逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jakarta.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.Cookie;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(&quot;/co&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CookieLearn</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        req.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历cookie</span></span><br><span class="line">        Cookie[] cookies = req.getCookies();</span><br><span class="line">        <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">            System.out.println(cookie.getName()+<span class="string">&quot; &quot;</span> + cookie.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取表单参数</span></span><br><span class="line">        String uname = req.getParameter(<span class="string">&quot;uname&quot;</span>);</span><br><span class="line">        String psd = req.getParameter(<span class="string">&quot;psd&quot;</span>);</span><br><span class="line">        </span><br><span class="line">       <span class="comment">// 新建cookie</span></span><br><span class="line">        Cookie cookie1 = <span class="keyword">new</span> Cookie(<span class="string">&quot;uname&quot;</span>,uname);</span><br><span class="line">        Cookie cookie2 = <span class="keyword">new</span> Cookie(<span class="string">&quot;psd&quot;</span>,psd);</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 设置cookie作用路径</span></span><br><span class="line">        cookie1.setPath(req.getContextPath() );</span><br><span class="line">        cookie2.setPath(req.getContextPath());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// cookie 持久化时间</span></span><br><span class="line">        cookie1.setMaxAge(<span class="number">100</span>);</span><br><span class="line">        cookie2.setMaxAge(<span class="number">100</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 添加cookie</span></span><br><span class="line">        resp.addCookie(cookie1);</span><br><span class="line">        resp.addCookie(cookie2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当两次登陆后，打印结果如下</p>
<p><img src="/images/image-20210315105919816.png" alt="image-20210315105919816"></p>
<p>可见第一次登陆没有新建cookie的信息，第二次就多了用户名和密码信息</p>
<p>对于上诉cookie，除了新建和添加cookie比较固定，还有一些关键点</p>
<ul>
<li><p><strong>cookie作用路径</strong></p>
<p>可以通过<code>setPath()</code>方法设置Cookie的作用域，即在那些地方可以看到cookie，可以作用域当前目录及其子目录</p>
<p>所以主要如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">默认不设置为新建Cookie的目录</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前Tomcat下的所有web项目</span></span><br><span class="line">    setPath(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"><span class="comment">// 具体目录</span></span><br><span class="line">    setPath(req.getContextPath() + <span class="string">&quot;/load.jsp&quot;</span>);</span><br><span class="line">	setPath(<span class="string">&quot;/cookie/load.jsp&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>如果需要跨域访问或者说是不同Tomcat访问同一个Cookie，就需要用到<code>setDomain()</code>方法</p>
</li>
<li><p><strong>cookie持久化时间</strong></p>
<p>cookie的默认存活时间是浏览器关闭，可以通过<code>setMaxAge()</code>方法设置其存活时间，将Cookie存到硬盘中，注意单位是秒，这时可以关闭浏览器后打开也能获取</p>
</li>
</ul>
<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><h3 id="Session底层原理"><a href="#Session底层原理" class="headerlink" title="Session底层原理"></a><strong>Session底层原理</strong></h3><ul>
<li><p>浏览器访问某个Servlet，这时如果服务器要从请求对象中获取Session对象（第一次获取也是创建），那么服务器会为这个Session对象创建一个id：JSESSIONID</p>
</li>
<li><p>同时在对浏览器的响应过程中，这个Session会将JSESSIONID这个id以Cookie形式回送给客户端浏览器，记住，这时候Cookie服务器没有设置有效时间，因此是存在浏览器的缓存中，而不是在硬盘文件。</p>
</li>
<li><p>当用户继续在这个会话过程中访问其他Servlet，这时候这个Servlet再从请求对象中获取Session对象，注意这时候获取Session对象是从浏览器发来的请求中查询是否有名为JSESSIONID的这个Cookie，如果有，那么这个Session就不用再创建，而是直接根据查询服务器中这个相同JSESSIONID值的Session，换句话说就可以取得之前存在这个Session中的数据。</p>
</li>
</ul>
<p>即Session的底层原理是通过<strong>Cookie实现</strong>的</p>
<h3 id="Session常用方法"><a href="#Session常用方法" class="headerlink" title="Session常用方法"></a><strong>Session常用方法</strong></h3><p>下面是一个创建Session，并且利用Session的实例</p>
<p>首先创建一个Servlet，在其内部可以创建Session</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxx.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpSession;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(&quot;/se&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionBase</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        req.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        HttpSession session = req.getSession();</span><br><span class="line">        System.out.println(session.getId());</span><br><span class="line">        <span class="keyword">if</span>(session.isNew())&#123;</span><br><span class="line">        String uname = req.getParameter(<span class="string">&quot;uname&quot;</span>);</span><br><span class="line">        String hobby = req.getParameter(<span class="string">&quot;hobby&quot;</span>);</span><br><span class="line">        session.setAttribute(<span class="string">&quot;hobby&quot;</span>,hobby);</span><br><span class="line">        session.setAttribute(<span class="string">&quot;uname&quot;</span>,uname);&#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            Enumeration&lt;String&gt; it = session.getAttributeNames();</span><br><span class="line">            <span class="keyword">while</span>(it.hasMoreElements())&#123;</span><br><span class="line">                String name = it.nextElement();</span><br><span class="line">                System.out.println(name + <span class="string">&quot;: &quot;</span> + session.getAttribute(name));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        resp.sendRedirect(req.getContextPath() + <span class="string">&quot;/show.jsp&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后在重定向的页面中查看Session携带的数据</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;show&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    HttpSession session1 = request.getSession();</span><br><span class="line">    <span class="keyword">if</span>(!session1.isNew())&#123;</span><br><span class="line">        Enumeration&lt;String&gt; it = session1.getAttributeNames();</span><br><span class="line">        <span class="keyword">while</span>(it.hasMoreElements())&#123;</span><br><span class="line">            String name = it.nextElement();</span><br><span class="line">            response.getWriter().println(name + <span class="string">&quot;: &quot;</span> + session1.getAttribute(name));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>两次访问<code>http://localhost:8088/session/se?uname=andy&amp;hobby=rap</code></p>
<p><code>http://localhost:8088/session/se</code></p>
<p>第一次带参，第二次不带参结果均如下</p>
<p><img src="/images/image-20210315153733059.png" alt="image-20210315153733059"></p>
<p>控制台结果如下</p>
<p><img src="/images/image-20210315153830459.png" alt="image-20210315153830459"></p>
<p>可见其确实靠JSESSIONID作为标识</p>
<h3 id="对Session进行设置"><a href="#对Session进行设置" class="headerlink" title="对Session进行设置"></a><strong>对Session进行设置</strong></h3><p>我们已经知道Session是靠名为JSESSIONID的Cookie的ID值标识定位的，所以Session的生命周期和作用域都和这个Cookie有关。</p>
<p>由于这个cookie没有设置<code>setMaxAge</code>，因此这个cookie只存在于浏览器的缓冲，浏览器关闭即被销毁。</p>
<p>又由于这个cookie不设置路径默认为新建Cookie的目录,所以可能访问这个web应用的其他资源就无法再使用Session了，得注意一下路径问题</p>
<p>综上，如果需要对这些进行修改，主要是对JSESSIONID的Cookie进行修改</p>
<p>通过<code>Cookie cookie = new Cookie(&quot;JSESSIONID&quot;, session.getId());</code>就可以对此Cookie进行修改。</p>
<p>此外当不关闭浏览器用户不进行操作时，session默认维持30分钟，可以在Tomcat的<code>web.xml</code>进行全局设置修改，或者在每个web应用中的web.xml文件中自定义添加<code>&lt;session-config&gt;</code>和<code>&lt;session-timeout&gt;</code>进行设置。这里得注意<strong>设置的cookie有效时间就不要超过服务器默认的<code>session-timeout</code>时间。</strong></p>
<h2 id="表单重复提交demo"><a href="#表单重复提交demo" class="headerlink" title="表单重复提交demo"></a>表单重复提交demo</h2><p>学习完Cookie和Session后，我们考虑一个运用场景</p>
<p>在平时开发中，如果网速比较慢的情况下，用户提交表单后，发现服务器半天都没有响应，那么用户可能会以为是自己没有提交表单，就会再点击提交按钮重复提交表单，我们在开发中必须防止表单重复提交。</p>
<p>可以在表单提交后，将提交按钮设置为不可用，但是如果用户刷新界面、或者利用回退提交表单，该场景就很难在客户端解决</p>
<p>这时可以用Session在服务端解决该问题</p>
<p><strong>思路：</strong></p>
<p>在服务器端生成一个唯一的随机标识号，专业术语称为Token(令牌)，同时在当前用户的Session域中保存这个Token。然后将Token发送到客户端的Form表单中，在Form表单中使用隐藏域来存储这个Token，表单提交的时候连同这个Token一起提交到服务器端，然后在服务器端判断客户端提交上来的Token与服务器端生成的Token是否一致，如果不一致，那就是重复提交了，此时服务器端就可以不处理重复提交的表单。如果相同则处理表单提交，处理完后清除当前用户的Session域中存储的标识号。</p>
<p><strong>步骤：</strong></p>
<ul>
<li><p>创建一个FormServlet类，生成token保存到Session中并传递到表单</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxx.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(&quot;/form&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FromServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        String token = Token.getInstance().getToken();</span><br><span class="line">        System.out.println(token);</span><br><span class="line">        req.getSession().setAttribute(<span class="string">&quot;token&quot;</span>,token);</span><br><span class="line">        req.getRequestDispatcher(<span class="string">&quot;/form.jsp&quot;</span>).forward(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在表单中传递隐藏数据</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;提交界面&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form method=<span class="string">&quot;post&quot;</span> action= <span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/doform&quot;</span> &gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;hidden&quot;</span> name=<span class="string">&quot;token&quot;</span> value=<span class="string">&quot;&lt;%=request.getSession().getAttribute(&quot;</span>token<span class="string">&quot;) %&gt;&quot;</span>&gt;</span><br><span class="line">    提交数据:&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;userdata&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>对表单数据进行处理，判重</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/doform&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoForm</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isRepeated(req))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;你已重复提交数据&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;正在处理提交数据&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        req.getSession().removeAttribute(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRepeated</span><span class="params">(HttpServletRequest request)</span></span>&#123;</span><br><span class="line">        String client_token = request.getParameter(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(client_token == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        String server_token = (String) request.getSession().getAttribute(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(server_token == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> !client_token.equals(server_token);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>用一个Token类来生成token</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxx.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Token</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Token token = <span class="keyword">new</span> Token();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Token</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Token <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getToken</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (System.currentTimeMillis() + <span class="keyword">new</span> Random().nextInt(<span class="number">999999999</span>)) + <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




</li>
</ul>
<p><img src="/images/image-20210315171953967.png" alt="image-20210315171953967"></p>
<h1 id="ServletConfig和ServerContext对象"><a href="#ServletConfig和ServerContext对象" class="headerlink" title="ServletConfig和ServerContext对象"></a>ServletConfig和ServerContext对象</h1><h2 id="ServletConfig"><a href="#ServletConfig" class="headerlink" title="ServletConfig"></a>ServletConfig</h2><p>当servlet配置了初始化参数后，web容器在创建servlet实例对象时，会自动将这些初始化参数封装到ServletConfig对象中，并在调用servlet的init()方法时，将ServletConfig 对象传递给servlet。进而，通过ServletConfig对象就可以得到当前servlet的初始化参数。</p>
<h2 id="ServerContext"><a href="#ServerContext" class="headerlink" title="ServerContext"></a>ServerContext</h2><p>每一个web应用都有且仅有一个ServletContext对象，其与应用程序相关，在Web容器启动时为web应用创建</p>
<p>其主要用来作为<strong>域对象共享数据（整个程序中）</strong>和保存了一些<strong>应用程序相关信息</strong>或者<strong>读取资源文件</strong></p>
<p><strong>常用方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/con&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContentLearn</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        ServletContext c1= req.getServletContext();</span><br><span class="line">        ServletContext c2 = getServletContext();</span><br><span class="line">        ServletContext c3 = req.getSession().getServletContext();</span><br><span class="line">        ServletContext c4 = getServletConfig().getServletContext();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 结果为true</span></span><br><span class="line">        System.out.println(c1 == c2 &amp;&amp; c3 == c4 &amp;&amp; c1 == c4);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;服务器信息：&quot;</span> + c1.getServerInfo());</span><br><span class="line">        System.out.println(<span class="string">&quot;真实路径：&quot;</span> + c1.getRealPath(<span class="string">&quot;/&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ServletContext对象的获取比较多元化，有直接获取或者利用其它域对象获取，一般主要是利用其来获取一些信息，很少用其来共享数据，其共享数据的方法命名和Request和Session一致</p>
<p><strong>两者的区别</strong></p>
<ul>
<li>定义</li>
</ul>
<p>ServletConfig：Servlet的配置对象，容器在初始化Servlet时通过它传递信息给Servlet。</p>
<p>ServletContext：上下文对象，提供了一系列方法供Servlet与Web容器交互。</p>
<ul>
<li><p>创建时机</p>
<p>ServletConfig：在容器初始化Servlet的时候，并为其提供上下文初始化参数的名/值对的引用。</p>
<p>ServletContext：容器启动的时候，并为其提供Servlet初始化参数的名/值对的引用。</p>
</li>
<li><p>作用范围（可见性）</p>
<p>ServletContext：每个Web应用一个ServletContext。</p>
<p>ServletConfig：每个Web应用的每个Servlet一个ServletConfig。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat安装</title>
    <url>/2021/03/07/Tomcat%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>安装Tomcat，设置环境变量，并且在IDEA上进行配置</p>
<a id="more"></a>

<h1 id="Tomcat概述"><a href="#Tomcat概述" class="headerlink" title="Tomcat概述"></a>Tomcat概述</h1><p>Tomcat 服务器是一个免费的开放源代码的Web 应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，也是Servlet的容器</p>
<p>其目录结构一般如下</p>
<p><img src="/images/image-20210307153940964.png" alt="image-20210307153940964"></p>
<p>其中</p>
<ul>
<li><p>bin是命令文件，我们一般只会用到其中startup和shutdown打开和关闭服务器</p>
</li>
<li><p>conf是配置文件，我们可能会需要打开其server.xml文件，在如下位置修改端口号</p>
<p>默认是8080，我们可以选择修改为8088，因为安装Oracle数据库，Oracle会占用8080端口，可能造成端口冲突</p>
<p><img src="/images/image-20210307155114695.png" alt="image-20210307155114695"></p>
</li>
<li><p>lib：tomcat运行所需要的jar包</p>
</li>
<li><p>logs：tomcat服务器日志文件</p>
</li>
<li><p>temp：tomcat运行产生的临时文件</p>
</li>
<li><p><strong>webapps：需要发布的项目存放在webapps下，放置web应用</strong></p>
</li>
<li><p>work：JSP翻译（编译）成servlet产生的代码</p>
</li>
</ul>
<h1 id="Tomcat安装"><a href="#Tomcat安装" class="headerlink" title="Tomcat安装"></a>Tomcat安装</h1><ul>
<li><p><strong>下载zip包（免安装，解压即可）</strong>，解压在自己常用的根目录下</p>
<p><a href="https://tomcat.apache.org/download-10.cgi">下载链接</a></p>
<p>解压打开后目录一个同概述的目录一致</p>
</li>
<li><p><strong>环境配置</strong></p>
<ul>
<li><p>在高级系统设置中，点击环境变量，配置系统变量</p>
</li>
<li><p>新建一个TOMCAT_HOME系统变量，变量值同解压后绝对路径</p>
<p><img src="/images/image-20210307150608806.png" alt="image-20210307150608806"></p>
</li>
<li><p>在Path中新建%TOMCAT_HOME%\bin;</p>
<p><img src="/images/image-20210307151107180.png" alt="image-20210307151107180"></p>
</li>
<li><p>在Classpath（没有即新建）中最后添加%TOMCAT_HOME%\lib\servlet-api.jar</p>
</li>
</ul>
</li>
<li><p><strong>配置完成</strong></p>
<p>双击解压后bin目录下的startup批处理文件，如果窗口能够打开，上面环境配置成功，此时相当于打开了Tomcat服务器</p>
<p>点击<a href="http://localhost:8080/">http://localhost:8080/</a>     便可以访问</p>
</li>
</ul>
<h1 id="在IDEA集成Tomcat"><a href="#在IDEA集成Tomcat" class="headerlink" title="在IDEA集成Tomcat"></a>在IDEA集成Tomcat</h1><p>点击file-&gt;settings</p>
<p>找到如下位置</p>
<p><img src="/images/image-20210307160037872.png" alt="image-20210307160037872"></p>
<p>初始时应该是空的，点击+号，添加Tomcat server</p>
<p><img src="/images/image-20210307160209360.png" alt="image-20210307160209360"></p>
<p>添加路径时，到我们解压目录bin上一级即可</p>
<p>之后一直ok，集成完毕</p>
]]></content>
      <categories>
        <category>框架</category>
        <category>IDEA相关</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指25-合并两个排序的链表</title>
    <url>/2021/03/08/%E5%89%91%E6%8C%8725-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p><strong>剑指 Offer 25. 合并两个排序的链表</strong></p>
<p><a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">力扣链接</a></p>
<a id="more"></a>

<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure>
<p><strong>限制：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 &lt;&#x3D; 链表长度 &lt;&#x3D; 1000</span><br></pre></td></tr></table></figure>
<h1 id="思路一：双指针"><a href="#思路一：双指针" class="headerlink" title="思路一：双指针"></a>思路一：双指针</h1><p>典型的归并排序的merge过程，一般直接用双指针解决，这里有个技巧，构造一个伪头结点可以简化初始头结点的判断，减少代码重复</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode pre = head;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">               l1 = merge(pre,l1);</span><br><span class="line">               pre = pre.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>  &#123;</span><br><span class="line">                l2 = merge(pre,l2);</span><br><span class="line">                pre = pre.next;&#125;</span><br><span class="line">    </span><br><span class="line">        &#125;</span><br><span class="line">        pre.next = l1 != <span class="keyword">null</span> ? l1 : l2;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">merge</span><span class="params">(ListNode pre ,ListNode l)</span></span>&#123;</span><br><span class="line">        pre.next = l;</span><br><span class="line">        <span class="keyword">return</span> l.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路二：递归"><a href="#思路二：递归" class="headerlink" title="思路二：递归"></a>思路二：递归</h1><p>也可以尝试用递归来做,比较简洁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        ListNode head ;</span><br><span class="line">        <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">            head = l1;</span><br><span class="line">            head.next = mergeTwoLists(l1.next,l2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            head = l2;</span><br><span class="line">            head.next = mergeTwoLists(l1,l2.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指Offer</category>
        <category>算法</category>
        <category>链表</category>
        <category>双指针</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC</title>
    <url>/2021/03/18/JDBC/</url>
    <content><![CDATA[<p>简单介绍Java的JDBC，并了解一下连接池</p>
<a id="more"></a>

<h1 id="建立一个JDBC实例"><a href="#建立一个JDBC实例" class="headerlink" title="建立一个JDBC实例"></a>建立一个JDBC实例</h1><ul>
<li><p>新建一个简单的Maven项目</p>
</li>
<li><p>在pom.xml文件中添加数据库驱动的依赖</p>
<p>可以在该网站查询<a href="https://mvnrepository.com/">Maven查询</a>最后查询的我mysql 8.0.23对对应的数据库驱动的依赖如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.23<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>编写一个JDBC代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">jdbc</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数据库url，tablelearn为数据库的名字</span></span><br><span class="line">        String url = <span class="string">&quot;jdbc:mysql://localhost:3306/tablelearn?serverTimezone=GMT%2B8&quot;</span>;</span><br><span class="line">        String user = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        String psd = <span class="string">&quot;root&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册驱动</span></span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">        <span class="comment">// 连接数据库</span></span><br><span class="line">        Connection connection = DriverManager.getConnection(url,user,psd);</span><br><span class="line">        <span class="comment">//   实例化statement对象</span></span><br><span class="line">        Statement statement = connection.createStatement();</span><br><span class="line">        <span class="comment">//定义数据库查询语句</span></span><br><span class="line">        String sql = <span class="string">&quot;select id,name from hero&quot;</span>;</span><br><span class="line">        <span class="comment">// 执行语句返回结果</span></span><br><span class="line">        ResultSet resultSet = statement.executeQuery(sql);</span><br><span class="line">        <span class="comment">// 查询结果处理</span></span><br><span class="line">        <span class="keyword">while</span>(resultSet.next())&#123;</span><br><span class="line">            String name = resultSet.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> id = resultSet.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;id: &quot;</span> + id + <span class="string">&quot; name: &quot;</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">        resultSet.close();</span><br><span class="line">        statement.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<p><img src="/_posts/JDBC.assets/image-20210318104619541.png" alt="image-20210318104619541"></p>
<p>总结编写一个JDBC代码主要需要以下几步：</p>
<ul>
<li>加载驱动</li>
<li>连接数据库  DriverManager</li>
<li>获得执行sql的对象 Statement</li>
<li>获得返回结果集  ResultSet</li>
<li>数据处理</li>
<li>释放连接</li>
</ul>
</li>
</ul>
<p>此外下面有两点需要注意：</p>
<ul>
<li><strong>PreparedStatement</strong></li>
</ul>
<p>正常来说，我们用Statement执行增删查改等操作，就如上诉案例所示，但Java中还有<code>PreparedStatement</code>也是用来执行sql语句的，与创建Statement不同的是，需要根据sql语句创建<code>PreparedStatement</code>,除此之外，还能够通过设置参数，指定相应的值，而不是Statement那样使用字符串拼接</p>
<p>此外<code>PrepareStatement</code>还有两个优点</p>
<ul>
<li><code>PreparedStatement</code>有预编译机制，性能比Statement更快</li>
<li><code>PreparedStatement</code>预编译可以防止SQL注入式攻击</li>
</ul>
<p>具体见下面一个小例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 利用PreparedStatement每一个下标就是一个参数，从1开始</span></span><br><span class="line">        String sql = <span class="string">&quot;insert into hero values(null,?,?,?)&quot;</span>;</span><br><span class="line">        Statement statement = connection.createStatement();</span><br><span class="line">        PreparedStatement preparedStatement = connection.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> t1 = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Statement需要进行字符串拼接，可读性和维修性比较差</span></span><br><span class="line">            String sql0 = <span class="string">&quot;insert into hero values(null,&quot;</span> + <span class="string">&quot;&#x27;提莫&#x27;&quot;</span> + <span class="string">&quot;,&quot;</span></span><br><span class="line">                    + <span class="number">313.0f</span> + <span class="string">&quot;,&quot;</span> + <span class="number">50</span> + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">            statement.execute(sql0);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> t2 = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;Statement时间： &quot;</span> + (t2 - t1));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> t3 = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            preparedStatement.setString(<span class="number">1</span>, <span class="string">&quot;提莫&quot;</span>);</span><br><span class="line">            preparedStatement.setFloat(<span class="number">2</span>, <span class="number">313.0f</span>);</span><br><span class="line">            preparedStatement.setInt(<span class="number">3</span>, <span class="number">50</span>);</span><br><span class="line">            preparedStatement.execute();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> t4 = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;preparedStatement: &quot;</span> + (t4 - t3));</span><br></pre></td></tr></table></figure>
<p>结果如下</p>
<p><img src="/images/image-20210318154537497.png" alt="image-20210318154537497"></p>
<p>反而发现<code>preparedStatement</code>更慢，因为<strong>mysql不支持<code>preparedStatement</code></strong></p>
<ul>
<li><strong>executeUpdate</strong></li>
</ul>
<p><code>executeUpdate</code>同<code>execute</code>：都可以执行增加，删除，修改;但是<code>execute</code>还可以执行查询语句.</p>
<p><code>execute</code>返回boolean类型，true表示执行的是查询语句，false表示执行的是insert,delete,update等等<br><code>executeUpdate</code>返回的是int，表示有多少条数据受到了影响</p>
<h1 id="事务操作"><a href="#事务操作" class="headerlink" title="事务操作"></a>事务操作</h1><ul>
<li><p><strong>事务</strong></p>
<p>可以利用connext的下列两个方法规定事务的多组操作,这些操作要么都执行，要么都不执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">....</span><br><span class="line">commit();</span><br></pre></td></tr></table></figure>
<p> 下面是一段代码</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Transaction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 数据库url，tablelearn为数据库的名字</span></span><br><span class="line">        String url = <span class="string">&quot;jdbc:mysql://localhost:3306/tablelearn?serverTimezone=GMT%2B8&quot;</span>;</span><br><span class="line">        String user = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        String psd = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        <span class="comment">// 注册驱动</span></span><br><span class="line">    	Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line">    	<span class="comment">// try-with-resources</span></span><br><span class="line">   	 <span class="keyword">try</span>(Connection connection = DriverManager.getConnection(url,user,psd);</span><br><span class="line">        Statement statement = connection.createStatement())&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 事务开始点</span></span><br><span class="line">        connection.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">        String sql1 = <span class="string">&quot;insert into hero values(null,&quot;</span>+<span class="string">&quot;&#x27;凯&#x27;&quot;</span>+<span class="string">&quot;,&quot;</span>+<span class="number">400</span>+<span class="string">&quot;,&quot;</span>+<span class="number">120</span>+<span class="string">&quot;)&quot;</span>;</span><br><span class="line">        String sql2 = <span class="string">&quot;insert into hero values(null,&quot;</span>+<span class="string">&quot;&#x27;刘备&#x27;&quot;</span>+<span class="string">&quot;,&quot;</span>+<span class="number">400</span>+<span class="string">&quot;,&quot;</span>+<span class="number">100</span>+<span class="string">&quot;)&quot;</span>;</span><br><span class="line">        String sql3 = <span class="string">&quot;select id,name from hero&quot;</span>;</span><br><span class="line">        statement.execute(sql1);</span><br><span class="line">        statement.execute(sql2);</span><br><span class="line">        ResultSet resultSet = statement.executeQuery(sql3);</span><br><span class="line">        <span class="comment">// 事务结束点</span></span><br><span class="line">        connection.commit();</span><br><span class="line">        <span class="keyword">while</span>(resultSet.next())&#123;</span><br><span class="line">            String name = resultSet.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> id = resultSet.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;id: &quot;</span> + id + <span class="string">&quot; name: &quot;</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (SQLException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>上诉操作必须在3个操作都成功才能算是完成，这样不会因为某个操作错误而修改了数据库</p>
</li>
</ul>
<h1 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h1><p>有多个线程，每个线程都需要连接数据库执行SQL语句的话，那么每个线程都会创建一个连接，并且在使用完毕后，关闭连接。</p>
<p>创建连接和关闭连接的过程也是比较消耗时间的，当多线程并发的时候，系统就会变得很卡顿。</p>
<p>同时，一个数据库同时支持的连接总数也是有限的，如果多线程并发量很大，那么数据库连接的总数就会被消耗光，后续线程发起的数据库连接就会失败。</p>
<p>类似于线程池的思想连接池在使用之前，就会创建好一定数量的连接。如果有任何线程需要使用连接，那么就从连接池里面借用，，而不是自己重新创建使用完毕后，又把这个连接归还给连接池供下一次或者其他线程使用。倘若发生多线程并发情况，连接池里的连接被借用光，那么其他线程就会临时等待，直到有连接被归还回来，再继续使用。整个过程，这些连接都不会被关闭，而是不断的被循环使用，从而节约了启动和关闭连接的时间</p>
<p>下面是一个简易实现连接池的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> jdbc;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionPool</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    List&lt;Connection&gt; cs = <span class="keyword">new</span> ArrayList&lt;Connection&gt;();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConnectionPool</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//这里恰恰不能使用try-with-resource的方式，因为这些连接都需要是&quot;活&quot;的，不要被自动关闭了</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                Connection c = DriverManager</span><br><span class="line">                        .getConnection(<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line">  </span><br><span class="line">                cs.add(c);</span><br><span class="line">  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (cs.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Connection c = cs.remove(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">returnConnection</span><span class="params">(Connection c)</span> </span>&#123;</span><br><span class="line">        cs.add(c);</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java编写连接连接池需要实现<code>DataSource</code>接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DataSource</span>  <span class="keyword">extends</span> <span class="title">CommonDataSource</span>, <span class="title">Wrapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">  <span class="function">Connection <span class="title">getConnection</span><span class="params">(String username, String password)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Tomcat默认使用了开源的DBCP连接池</p>
<h1 id="ORM和DAO"><a href="#ORM和DAO" class="headerlink" title="ORM和DAO"></a>ORM和DAO</h1><p><code>ORM=Object Relationship Database Mapping</code></p>
<p>即<strong>对象和关系数据库的映射</strong></p>
<p>比如下列根据id返回一个对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> jdbc;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> charactor.Hero;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJDBC</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Hero <span class="title">get</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        Hero hero = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> (Connection c = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8&quot;</span>,<span class="string">&quot;root&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line">            Statement s = c.createStatement();) &#123;</span><br><span class="line"> </span><br><span class="line">            String sql = <span class="string">&quot;select * from hero where id = &quot;</span> + id;</span><br><span class="line">   </span><br><span class="line">            ResultSet rs = s.executeQuery(sql);</span><br><span class="line">   </span><br><span class="line">            <span class="comment">// 因为id是唯一的，ResultSet最多只能有一条记录</span></span><br><span class="line">            <span class="comment">// 所以使用if代替while</span></span><br><span class="line">            <span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">                hero = <span class="keyword">new</span> Hero();</span><br><span class="line">                String name = rs.getString(<span class="number">2</span>);</span><br><span class="line">                <span class="keyword">float</span> hp = rs.getFloat(<span class="string">&quot;hp&quot;</span>);</span><br><span class="line">                <span class="keyword">int</span> damage = rs.getInt(<span class="number">4</span>);</span><br><span class="line">                hero.name = name;</span><br><span class="line">                hero.hp = hp;</span><br><span class="line">                hero.damage = damage;</span><br><span class="line">                hero.id = id;</span><br><span class="line">            &#125;</span><br><span class="line">   </span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hero;</span><br><span class="line">   </span><br><span class="line">    &#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
<p>DAO=<strong>D</strong>ata<strong>A</strong>ccess <strong>O</strong>bject</p>
<p><strong>数据访问对象</strong></p>
<p>实际上就是运用了ORM中的思路，把数据库相关的操作都封装在这个类里面，其他地方看不到JDBC的代码</p>
<p>DAO接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DAO</span></span>&#123;</span><br><span class="line">    <span class="comment">//增加</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Hero hero)</span></span>;</span><br><span class="line">    <span class="comment">//修改</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Hero hero)</span></span>;</span><br><span class="line">    <span class="comment">//删除</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">    <span class="comment">//获取</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Hero <span class="title">get</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">    <span class="comment">//查询</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Hero&gt; <span class="title">list</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//分页查询</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Hero&gt; <span class="title">list</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> count)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java语法</category>
        <category>进阶</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql</title>
    <url>/2021/03/16/Mysql/</url>
    <content><![CDATA[<p>了解MySQL</p>
<a id="more"></a>

<h1 id="MySQL概念"><a href="#MySQL概念" class="headerlink" title="MySQL概念"></a>MySQL概念</h1><p>数据库（Database）是按照数据结构来组织、存储和管理数据的仓库。</p>
<p>每个数据库都有一个或多个不同的 API 用于创建，访问，管理，搜索和复制所保存的数据。</p>
<p>我们也可以将数据存储在文件中，但是在文件中读写数据速度相对较慢。</p>
<p>所以，现在我们使用关系型数据库管理系统（RDBMS）来存储和管理大数据量。所谓的关系型数据库，是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。</p>
<p>RDBMS 即关系数据库管理系统(Relational Database Management System)的特点：</p>
<ul>
<li>1.数据以表格的形式出现</li>
<li>2.每行为各种记录名称</li>
<li>3.每列为记录名称所对应的数据域</li>
<li>4.许多的行和列组成一张表单</li>
<li>5.若干的表单组成database</li>
</ul>
<p>MySQL 是最流行的关系型数据库管理系统，在 WEB 应用方面 MySQL 是最好的 RDBMS(Relational Database Management System：关系数据库管理系统)应用软件之一。</p>
<h1 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h1><ul>
<li><p><strong>下载安装包</strong></p>
<p>  <a href="https://dev.mysql.com/downloads/windows/installer/8.0.html">下载链接</a>，点击链接后，选择 第二个（为安装版），点击下载，可以选择不注册下载</p>
</li>
<li><p><strong>具体安装教程</strong></p>
<p>该部分是在网上找的，我把自己安装参考的博客转载过来</p>
<p><a href="https://www.cnblogs.com/2020javamianshibaodian/p/mysql8020anzhuangjiaocheng.html">参考博客</a></p>
</li>
<li><p><strong>客户端选择</strong></p>
<p>正常来说安装完mysql可以使用客户端，这里我使用官方的Mysql  WorkBench，按照上诉过程安装既有</p>
<p>据说最好用的客户端是 Navicat，但不免费</p>
</li>
</ul>
<h1 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h1><p>基于Mysql  WorkBench使用一些常见命令</p>
<h2 id="表相关"><a href="#表相关" class="headerlink" title="表相关"></a>表相关</h2><ul>
<li><p>创建一个数据库和表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create database tablelearn;</span><br><span class="line">use tablelearn;</span><br><span class="line">CREATE TABLE hero (</span><br><span class="line">  id int(11) AUTO_INCREMENT,</span><br><span class="line">  name varchar(30) ,</span><br><span class="line">  hp float ,</span><br><span class="line">  damage int(11) ,</span><br><span class="line">  PRIMARY KEY (id)</span><br><span class="line">)  DEFAULT CHARSET&#x3D;utf8;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p>修改表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  ALTER TABLE &lt;表名&gt; [修改选项]</span><br><span class="line">  修改选项：</span><br><span class="line">&#123; ADD COLUMN &lt;列名&gt; &lt;类型&gt;</span><br><span class="line">  | CHANGE COLUMN &lt;旧列名&gt; &lt;新列名&gt; &lt;新列类型&gt;</span><br><span class="line">  | ALTER COLUMN &lt;列名&gt; &#123; SET DEFAULT &lt;默认值&gt; | DROP DEFAULT &#125;</span><br><span class="line">  | MODIFY COLUMN &lt;列名&gt; &lt;类型&gt;</span><br><span class="line">  | DROP COLUMN &lt;列名&gt;</span><br><span class="line">  | RENAME TO &lt;新表名&gt; &#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="增删查改"><a href="#增删查改" class="headerlink" title="增删查改"></a>增删查改</h2><ul>
<li><p>插入数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into hero values (null, &#39;盖伦&#39;, 616, 100)</span><br></pre></td></tr></table></figure></li>
<li><p>修改数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update hero set name &#x3D; &quot;典韦&quot; where id &#x3D; 2</span><br></pre></td></tr></table></figure></li>
<li><p>查询数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from hero limit 0,2</span><br></pre></td></tr></table></figure></li>
<li><p>删除数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delete from hero where id &#x3D; 1</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h1 id="Mysql和IDEA的连接"><a href="#Mysql和IDEA的连接" class="headerlink" title="Mysql和IDEA的连接"></a>Mysql和IDEA的连接</h1><p>该连接的效果仅仅是使IDEA充当Mysql  WorkBench可视化的功能，真正要在代码中使用还得用JDBC</p>
<ul>
<li><p>点<code>view-&gt;tool windows-&gt;database</code></p>
<p>之后点击database的+号，添加mysql源</p>
<p><img src="/images/image-20210317164459805.png" alt="image-20210317164459805"></p>
</li>
<li><p>填入个人信息，即下载主要是下载时设置的密码，其他可以保持默认</p>
<p><img src="/images/image-20210318095103092.png" alt="image-20210318095103092"></p>
<p>如果用的是mysql 8 以上版本需要注意时区问题，要在Url加上<code>?serverTimezone=GMT%2B8</code></p>
<p>最后选择<code>test Connection</code>即可</p>
<p>第一次注意在左下角点击下载驱动</p>
</li>
<li><p>连接成功</p>
<p>此时可以尝试在IDEA中编辑数据库、表</p>
</li>
</ul>
<h1 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h1><p>Mysql服务器逻辑架构如下</p>
<p><img src="/images/image-20210317201823243.png" alt="image-20210317201823243"></p>
<ul>
<li>其中最上服务器层主要负责连接管理与安全性，MySQL客户端与服务端的通信连接管理以及用户名密码、对数据库及表的权限校验，都是在这一层完成的</li>
<li>第二层包括MySQL核心服务功能，像查询解析、分析、优化、缓存、所有的内置函数以及所有跨存储引擎的功能（存储过程、触发器、视图等）都在这一层</li>
<li>第三层就是存储引擎层，存储引擎负责数据的存储和提取，服务器通过一套标准的API可以和不同的存储引擎进行通信，这些API屏蔽了不同存储引擎之间的差异</li>
</ul>
<p>而mysql中的索引是在最底层的存储引擎层实现的，不同存储引擎可能使用不同的存储结构存储索引。</p>
<h2 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B+Tree索引"></a>B+Tree索引</h2><p>InnoDB是mysql的默认事务型引擎，主要采用<strong>B+Tree</strong>的结构存储索引</p>
<p>B+Tree主要是由B树演变而来，相较于B-Tree，主要有以下区别：</p>
<ul>
<li><p>B树每个节点都存储数据，所有节点组成这棵树，B+树只有叶子节点存储数据，所有非叶节点只起到索引作用。</p>
</li>
<li><p>B+所有的叶子结点使用链表相连</p>
</li>
<li><p>关键字和子树范围不一致</p>
</li>
</ul>
<p>首先最大的区别B+树只有叶子节点存储数据，其一个关键字代表一个子树的最值，并指向该子树，所以造成了第三点区别</p>
<p>其次正是由于B+树只有叶子节点存储数据，所以其所有的叶子结点使用链表相连才有意义，这给B+数带来了很大的优点：</p>
<ul>
<li>所有的叶子结点使用链表相连，<strong>便于区间查找和遍历</strong></li>
<li>B+树叶子节点顺序存储，B树则需要进行每一层的递归遍历，相邻的元素可能在内存中不相邻，所以<strong>缓存命中性</strong>没有B+树好。</li>
</ul>
<p>数据库索引是存储在磁盘上的，考虑磁盘IO的影响，无论是B+树还是B树，都能<strong>减少IO次数</strong>，特别数据量大时，就不能把整个索引全部加载到内存了，只能逐一加载每一个磁盘页（对应索引树的节点），对于树来说，IO次数就是树的高度，而m的大小取决于磁盘页的大小。<br>由于采用了B+Tree结构，mysql非常适用于<strong>全键值、键值范围或键前缀查找</strong></p>
<p>值得注意，其中mysql键前缀查找只适用于<strong>最左前缀的查找</strong>，所以对索引列的顺序要求很高，不可能跳过第一列索引去查找其他列索引，第一列索引也是最左前缀查找，比如以名字为索引的索引中，很难查找以名字的最后一个字为结尾的人</p>
<h2 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h2><p>哈希索引基于hash表实现，只有在精确匹配索引所有列的查询才有效，即<strong>全键值查找</strong></p>
<p>采用Hash索引时，对于每行数据，存储引擎都会根据所有索引列值计算一个哈希码，哈希索引将所有的哈希码存储在索引中，同时哈希表中保存指向每个数据行的指针</p>
<p>在mysql中只有Memory引擎显示支持哈希索引，并且支持非唯一值哈希索引（即可以存在hash冲突）</p>
<p>由于hash表的特性其在<strong>全键值查找</strong>中有很快的速度，但是不能支持<strong>范围查询</strong>或者<strong>部分索引列查询</strong></p>
<p>InnoDB引擎有一个特殊的功能加做<strong>自适应哈希索引</strong>，当某些索引值被频繁使用时，会在内存中基于B+Tree的索引上再创建一个哈希索引，这个是自动的、内部的行为。</p>
<h2 id="索引的适应范围"><a href="#索引的适应范围" class="headerlink" title="索引的适应范围"></a>索引的适应范围</h2><p>总的来说，索引的目的是为了快速定位到表的指定位置，但是除此之外，索引还有以下几个优点：</p>
<ul>
<li>大大减少服务器需要扫描的数据量</li>
<li>使服务器避免排序和临时表</li>
<li>可以将随机I/O变成顺序I/O</li>
</ul>
<p>但是注意索引页带来了额外的开销，只有其快速定位的好处大于这些开销时，索引才是有效的，因此索引主要用于中到大型表。对于小表，简单的全表扫描更高效，对于特大的表维护索引的开销代价更大，需要类似于分区技术等技术直接区分出查询需要的一组数据</p>
<h2 id="高性能索引策略"><a href="#高性能索引策略" class="headerlink" title="高性能索引策略"></a>高性能索引策略</h2><p>索引三个等级：</p>
<p>1.索引将相关记录放在一起</p>
<p>2.索引数据顺序和查找排列顺序一致</p>
<p>3.索引列包含查询需要的全部列</p>
<ul>
<li><p><strong>独立的列</strong></p>
<p>索引列不要作为表达式的一部分，也不能是函数的参数，应该使索引列单独放在比较符号的一侧</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">where id + 1 &gt; 5   error</span><br><span class="line">where id &gt; 4       right</span><br></pre></td></tr></table></figure></li>
<li><p><strong>前缀索引和索引选择性</strong></p>
<p><strong>索引选择性</strong>是指不重复的索引值和数据表的记录总数的比值</p>
<p><strong>前缀索引</strong>在于选择足够长的前缀保持较高的选择性，同时又不能太长（和完整列的选择性比较即可）可以节约索引空间，从而提高索引效率</p>
<p>创建前列索引</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">alter table xx add <span class="title">key</span> <span class="params">(city(<span class="number">7</span>)</span>) <span class="comment">// 7是前缀长度</span></span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>多列索引和单列索引比较</strong></p>
<p>多个单例索引最多只能保持第一个等级，这时需要考虑创建多列索引，特别是会对这<strong>多个单列索引进行相交、联合操作时</strong></p>
</li>
<li><p><strong>选择合适的索引列顺序</strong></p>
<p>不考虑排序和分组时，考虑<strong>选择性高</strong>的索引放前面通常较好</p>
<p>同时也要注意where子句中的排序、分组和范围条件等其他因素</p>
</li>
<li><p><strong>覆盖索引</strong></p>
<p>指一个索引包含（覆盖）所有需要查询的字段的值，这时就不需要回表，能极大的提高性能，减少数据访问量。此外我们知道InnoDB的二级索引中保存了行的主键值，如果二级主键能够覆盖查询，可以避免对主键的二次查询，</p>
</li>
<li><p><strong>聚簇索引</strong></p>
<p>聚簇索引不是一种单独的索引类型，也是一种数据存储方式，<strong>聚簇表示数据行和相邻的键值紧凑地存储在一起</strong></p>
<p>InnoDB通过主键聚集数据</p>
<p>优点：</p>
<ul>
<li>相关数据保存在一起减少磁盘I/O</li>
<li>数据访问比非聚簇索引中查找块</li>
<li>使用覆盖索引扫描的查询可以直接使用页节点主键值</li>
</ul>
<p>缺点：</p>
<ul>
<li>数据如果全在内存中优势不大</li>
<li>插入速度严重依赖插入顺序：主键最快</li>
<li>更新代价高，每个被更新行会被移动到新的位置</li>
<li>插入、更新行可能会导致页分裂占用更多的磁盘空间</li>
<li>可能导致全表扫描变慢</li>
<li>二级索引可能更大（引用行主键列），访问也需要两次，先找到主键值再去聚簇查询</li>
</ul>
</li>
<li><p>利用索引扫描来做排序</p>
<p>mysql可以考索引顺序扫描和顺序全表排序操作生成有序的结果，和覆盖索引类似。如果索引列顺序和排序列顺序一致，就可以使用索引来对结果做排序优化性能</p>
</li>
<li><p><strong>索引选择基本原则</strong></p>
<p>索引的使用尽量选择<code>查询频率比较高的字段</code>作为<code>最左字段</code>，优先考虑<code>联合索引</code>, 尽量查询可以去做到<code>覆盖索引</code>，索引字段需要<code>比较小的字段</code> ，没事不要把<code>范围查询</code>放在联合索引，<code>变得快的字段</code>不建议建立索引</p>
</li>
</ul>
<h1 id="Mysql查询优化"><a href="#Mysql查询优化" class="headerlink" title="Mysql查询优化"></a>Mysql查询优化</h1><p>查询的生命周期大致可以分为：从客户端到服务器，服务器上解析生成执行计划，执行（检索数据、调用存储引擎、数据处理），最后返回结果给客户端</p>
<p>查询优化，首先得了解一点在上诉周期的时间消耗</p>
<h2 id="数据访问优化"><a href="#数据访问优化" class="headerlink" title="数据访问优化"></a>数据访问优化</h2><ul>
<li><p><strong>不用请求不需要的数据</strong></p>
<ul>
<li><p>如果没有必要取出全部列，或者也没有必要请求全部行，那就不用请求</p>
</li>
<li><p>如果总是要查询相同的数据，得考虑缓存</p>
</li>
</ul>
</li>
<li><p><strong>减少额外的扫描记录</strong></p>
<p>如果查询需要扫描大量数据但是只是需要少数行，可以尝试：</p>
<ul>
<li>使用索引覆盖扫描，减少回表</li>
<li>改变库表结构，建立汇总表</li>
</ul>
</li>
</ul>
<h2 id="查询重构优化"><a href="#查询重构优化" class="headerlink" title="查询重构优化"></a>查询重构优化</h2><ul>
<li><p><strong>一个复杂查询是否能够分解为几个简单查询</strong></p>
</li>
<li><p><strong>切分查询</strong></p>
<p>和上诉的区别在于切分的小查询是减少了查询数据量，但是功能一致，降低对服务器的影响</p>
</li>
<li><p><strong>分解关联查询</strong></p>
</li>
</ul>
<h2 id="特定类型查询优化"><a href="#特定类型查询优化" class="headerlink" title="特定类型查询优化"></a>特定类型查询优化</h2><ul>
<li><p><strong>count查询优化</strong></p>
<p>count可以用来统计某个列值数量（不统计NULL）也可以用来统计行数</p>
<p>当mysql认为括号里面的表达式值不可能为空时，实际就是统计行数，所以而使用**<code>count(*)</code>**，而忽略所以列直接统计所有的行数，所以真的要统计行数时，不用在里面指定某个列</p>
</li>
<li><p><strong>关联查询优化</strong></p>
<ul>
<li><p>确保On或者Using子句中的列上有索引，确保关联顺序后面的表上有索引</p>
</li>
<li><p>确保分组或者排序中的表达式只涉及到一个表中的列，才有可能用索引了优化这个过程</p>
</li>
</ul>
</li>
<li><p><strong>优化limit分页</strong></p>
<p>分页操作经常用到limit加偏移量的方法实现，同时加上合适的order by 语句</p>
<p>但是偏移量大大时，最好是使用索引覆盖扫描，再根据需求做一次关联操作再返回需要的列</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring MVC</title>
    <url>/2021/03/16/Spring-MVC/</url>
    <content><![CDATA[<p>学习Spring MVC框架</p>
<a id="more"></a>

<h1 id="Spring-MVC原理"><a href="#Spring-MVC原理" class="headerlink" title="Spring MVC原理"></a>Spring MVC原理</h1><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>MVC是一种架构方式，其中：</p>
<p>M是模型，代表一个存取数据的对象</p>
<p>V是视图，负责页面的显示，与用户的交互，包含各种表单。 实现视图用到的技术有html/css/jsp/js等前端技术。</p>
<p>C是控制器，控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开。</p>
<p>MVC通过分离模型、视图以及控制器在应用程序中的角色将业务逻辑从界面中解耦，模型通过封装应用程序数据在视图层展示，视图仅仅只是展示这些数据，不包含任何业务逻辑。控制器负责接收用户请求，并调用后台服务（service、dao）来处理业务逻辑。<strong>其核心在于将业务逻辑从视图中分离出来</strong>，允许其单独改变而不会相互影响。</p>
<p>具体到Spring MVC，其是基于Java实现了Web MVC设计思想的请求驱动类型的轻量级web框架。其以请求为驱动，围绕Servlet设计，将请求发给控制器，然后通过模型对象，分派器来展示请求结果视图。其中核心类是DispatcherServlet，它是一个Servlet，顶层是实现的Servlet接口。</p>
<h2 id="Spring-MVC-原理"><a href="#Spring-MVC-原理" class="headerlink" title="Spring MVC 原理"></a>Spring MVC 原理</h2><p>Spring MVC 的请求流程主要如下图所示：</p>
<p><img src="/images/image-20210322100338290.png" alt="image-20210322100338290"></p>
<p><strong>服务器运行准备</strong></p>
<ul>
<li><p>tomcat启动SpringMVC项目，加载该项目的web.xml文件（其中listener监听器可以监听到一些请求进行分配）</p>
</li>
<li><p>通过web.xml文件加载其中配置的SpringMVC配置文件</p>
</li>
<li><p>java文件扫描SpringMVC配置文件中设置的扫描路径</p>
</li>
<li><p>配置了@Controller注解的类可以接受相应的数据，检索所有的Controller下的@RequestMapping，每个@Controller下的@RequestMapping对应一个map，其中整个@RequestMapping的全路径为key，（类路径+方法签名）为value。所有的Map放入一个map结构中。</p>
</li>
</ul>
<p><strong>MVC工作流程</strong></p>
<ul>
<li><p>服务器接受到http格式的请求信息，将其中所需要的信息提取出来，并将请求发送至前端控制器DispatcherServlet</p>
</li>
<li><p>DispatcherServlet收到请求调用HandlerMapping处理器映射器，通过key找到实际访问的方法路径</p>
</li>
<li><p>处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，通过反射生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。</p>
</li>
<li><p>DispatcherServlet调用HandlerAdapter处理器适配器。</p>
</li>
<li><p>HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)，其实就是代理执行相应的方法</p>
</li>
<li><p>Controller执行完成返回ModelAndView。</p>
</li>
<li><p>HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。</p>
</li>
<li><p>DispatcherServlet将ModelAndView传给ViewReslover视图解析器。</p>
</li>
<li><p>ViewReslover解析后返回具体View。</p>
</li>
<li><p>DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。</p>
</li>
<li><p>DispatcherServlet响应用户。</p>
</li>
</ul>
<p><strong>组件说明</strong></p>
<ul>
<li><p>前端控制器DispatcherServlet,由框架提供<br>作用：接收请求，响应结果，相当于转发器，中央处理器。有了dispatcherServlet减少了其它组件之间的耦合度。<br>用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性。</p>
</li>
<li><p>处理器映射器HandlerMapping(不需要工程师开发),由框架提供<br>作用：根据请求的url查找Handler<br>HandlerMapping负责根据用户请求找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。</p>
</li>
<li><p>处理器适配器HandlerAdapter<br>作用：按照特定规则（HandlerAdapter要求的规则）去执行Handler<br>通过HandlerAdapter执行处理器，这是适配器模式的应用，会把处理器包装成适配器，这样就可以支持多种类型的处理器，类比笔记本的适配器（适配器模式的应用）</p>
</li>
<li><p><strong>处理器Handler</strong>(需要工程师开发)<br>注意：编写Handler时按照HandlerAdapter的要求去做，这样适配器才可以去正确执行Handler<br>Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。<br>由于Handler涉及到具体的用户业务请求，所以一般情况需要工程师根据业务需求开发Handler。</p>
</li>
<li><p>视图解析器View resolver,由框架提供<br>作用：进行视图解析，根据逻辑视图名解析成真正的视图（view）<br>View Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。 springmvc框架提供了很多的View视图类型，包括：jstlView、freemarkerView、pdfView等。<br>一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由工程师根据业务需求开发具体的页面。</p>
</li>
<li><p><strong>视图View</strong>(需要工程师开发)<br>View是一个接口，实现类支持不同的View类型（jsp、freemarker、pdf…）</p>
</li>
</ul>
<h1 id="Spring-MVC-环境搭建"><a href="#Spring-MVC-环境搭建" class="headerlink" title="Spring MVC 环境搭建"></a>Spring MVC 环境搭建</h1><p><strong>开发环境</strong></p>
<p>IDEA + Maven + Jdk1.8 + Tomcat</p>
<h1 id="基于IDEA新建一个Spring-MVC项目"><a href="#基于IDEA新建一个Spring-MVC项目" class="headerlink" title="基于IDEA新建一个Spring MVC项目"></a>基于IDEA新建一个Spring MVC项目</h1><p>这里主要基于Maven配置</p>
<ul>
<li><p><strong>首先创建一个Maven项目</strong></p>
<p>注意图中勾选</p>
<p><img src="/images/image-20210316151825513.png" alt="image-20210316151825513"></p>
<p>之后命名，一路next</p>
</li>
<li><p><strong>在pom.xml文件中导入相关依赖</strong></p>
<p>主要是导入Spring，Servlet，Spring MVC 等相关依赖</p>
<p>这里是我在网上导入的一锅端</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--J2EE--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--mysql驱动包--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.35<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--springframework--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.stefanbirkner<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>system-rules<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--其他需要的包--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p><strong>导入依赖后，添加Spring MVC 框架支持</strong></p>
<p>点击项目右键添加框架支持</p>
<p><img src="/images/image-20210316153142758.png" alt="image-20210316153142758"></p>
<p><strong>注意：</strong>如果没有上诉界面，说明该项目有一定的Spring项目，但是不一定齐全，我们可以在<code>File-&gt;project structure -&gt;facets</code>里面把Spring删除掉，再继续上一步步骤</p>
<p>这一步成功，会添加两个xml配置文件，MVC的配置主要在这里进行</p>
<p><img src="/images/image-20210316153652673.png" alt="image-20210316153652673"></p>
</li>
<li><p><strong>部署到Tomcat服务器上</strong></p>
<p>点击右上角<code>add configuration</code>,在点击左上角+号选择<code>TomCat Server  local</code></p>
<p>然后在<code>DeployMent</code>下点击+号<code>Artifact</code>添加本项目如下</p>
<p><img src="/images/image-20210316154055526.png" alt="image-20210316154055526"></p>
</li>
<li><p><strong>运行服务器</strong></p>
<p>运行服务器，打开网页说明配置成功</p>
</li>
</ul>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Spring MVC</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发基础</title>
    <url>/2021/03/19/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>介绍一下Java线程的基础知识，了解如何在多线程条件下保证线程安全</p>
<a id="more"></a>

<h1 id="一、使用线程"><a href="#一、使用线程" class="headerlink" title="一、使用线程"></a>一、使用线程</h1><h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><p>Runnable接口可以作为参数传入到Thread构造器中初始化生成一个线程，所以可以通过实现Runnable接口使用线程。</p>
<p>Runnable是函数式接口，只含一个声明方法run，当一个线程被调度时就会执行该线程的run方法，可以直接用lambda表达式实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> achieveThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseRunnable</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Runnable r1 = ()-&gt;&#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">&quot; begin:&quot;</span>+System.currentTimeMillis());</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">&quot; end:&quot;</span>+System.currentTimeMillis());</span><br><span class="line">		&#125;;</span><br><span class="line">		Thread t1 = <span class="keyword">new</span> Thread(r1);</span><br><span class="line">		t1.setName(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">		t1.start();</span><br><span class="line">		Thread t2 = <span class="keyword">new</span> Thread(r1);</span><br><span class="line">		t2.start();	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><p>Thread类也实现了Runnable接口，也需要重写run方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> achieveThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(Thread.currentThread().getName()+<span class="string">&quot; begin:&quot;</span>+System.currentTimeMillis());</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(Thread.currentThread().getName()+<span class="string">&quot; end:&quot;</span>+System.currentTimeMillis());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		UseThread t = <span class="keyword">new</span> UseThread();</span><br><span class="line">		t.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>实现接口和继承Thread类的对比</strong></p>
<ul>
<li><p>实现接口可以把并行任务和运行机制解耦</p>
</li>
<li><p>继承整个类可能开销要大</p>
</li>
<li><p>Java不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口</p>
</li>
</ul>
<h1 id="二、线程状态"><a href="#二、线程状态" class="headerlink" title="二、线程状态"></a>二、线程状态</h1><p>线程有下图六种状态、可以用getState方法确定当前状态</p>
<p><img src="/images/image-20210319094804228.png" alt="image-20210319094804228"></p>
<ul>
<li><p>new即新建状态：创建后尚未启动。</p>
</li>
<li><p>runnable即可运行状态：主要包含两种情况ready（就绪）和running(运行中)</p>
<ul>
<li>调用了start方法只是进入就绪状态</li>
<li>就绪状态的线程在获得CPU时间片后变为运行中状态</li>
</ul>
</li>
<li><p>blocked即阻塞状态：当一个线程试图获取内部的对象锁（synchronized），该锁被其他线程所占有，就会进入阻塞状态，直到允许持有这个锁时，才会回到可运行状态</p>
</li>
<li><p>waiting即等待状态：当线程等待另一个线程通知调度器出现一个条件时，该线程就会进入等待状态。比如Object.wait、Thread.join、或者等待Java.util.concurrent库中Lock、Condition时就会进入等待状态。</p>
<p>Object类的notify和notifyAll 方法, 会让线程从Waiting 转化为Runnable 状态，Thread.join方法会等待join的线程执行完毕, 才会把线程状态变成Runnable 状态.</p>
</li>
<li><p>timed waiting即计时等待状态：调用带有超时方法的方法。要么符合条件被唤醒，要么等待到设定时间被唤醒</p>
</li>
<li><p>teminated即终止状态：正常执行或者意外中断退出</p>
</li>
</ul>
<h1 id="三、多线程方案"><a href="#三、多线程方案" class="headerlink" title="三、多线程方案"></a>三、多线程方案</h1><p>大多数并发程序是围绕任务执行构建的，当有很多任务需要执行时，我们可能需要使用多线程</p>
<p>这时一般有两种方案</p>
<ul>
<li><p><strong>显式的为任务创建线程</strong></p>
<p>即为每一个任务分配一个线程，期待提高吞吐率</p>
<p>但是在一定范围内，增加线程可以提高系统吞吐率，但是超出这个范围后，过多的线程只会降低程序的执行速度。此外线程的生命周期开销非常高，过多的线程可能会导致资源耗竭。</p>
<p>这时，提出了另一种方案</p>
</li>
<li><p><strong>在线程池中执行任务</strong></p>
<p>线程池是管理一组同构工作线程的资源池，其关键在于重用线程池的工作线程而不是创建新线程，从而分摊了线程创建销毁过程中的巨大开销</p>
<p>除此之外，当任务到来时，通常工作线程已经存在，因此不会由于等待创建线程而延迟任务的执行，从而提高了响应性。</p>
<p>最后，通过适当调整线程池的大小，可以创建足够多的线程以便使处理器保持忙碌状态，又可以防止过多线程相互竞争资源而使应用程序耗竭内存、资源失败</p>
</li>
</ul>
<h1 id="四、线程池"><a href="#四、线程池" class="headerlink" title="四、线程池"></a>四、线程池</h1><h2 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h2><p>Java中线程池的创建主要有两种，都是基于Executor框架，首先了解一下Executor框架</p>
<p><img src="/images/image-20210319103302128.png" alt="image-20210319103302128"></p>
<p>其中Executor接口定义了execute()方法，可以接收Runnable任务</p>
<p><code>ExecutorService</code>接口继承了Executor接口，是一个比Executor使用更广泛的子类接口。其定义了submit()方法可以提交Runnable或者Callable任务，并且返回一个Future对象，从而可以利用这个Future对象描述任务。</p>
<p><code>ThreadPoolExecutor</code>类是我们生成线程池的主要方式之一,返回的线程池都实现了<code>ExecutorService</code>接口</p>
<p>最后还有一个工具类<code>Executors</code>类，其很多工厂方法可以生成线程池，其底层原理还是调用了<code>ThreadPoolExecutor</code>类的构造方法实现</p>
<p>综上了解线程池的产生，主要还是得了解<code>ThreadPoolExecutor</code>类</p>
<h3 id="利用ThreadPoolExecutor生成线程池"><a href="#利用ThreadPoolExecutor生成线程池" class="headerlink" title="利用ThreadPoolExecutor生成线程池"></a>利用ThreadPoolExecutor生成线程池</h3><ul>
<li><p><strong>生成</strong></p>
<p>下面是类<code>ThreadPoolExecutor</code>通用构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li>corePoolSize表示线程池大小，核心池大小，即基本大小</li>
<li>maximumPoolSize表示线程池最大线程数</li>
<li>keepAliveTime:当线程数量大于corePoolSize值，若空闲线程超过此时间单位则回收</li>
<li>unit：keepAliveTime的时间单位</li>
<li>workQueue：执行前用于保持任务的队列，有三种：无界队列、有界队列、同步移交</li>
<li>threadFactory：可以定义自己的Thread线程</li>
<li>handler：饱和策略</li>
</ul>
<p>当任务来临后，下图可以体现这些参数的作用</p>
<p><img src="/images/image-20210319105224288.png" alt="image-20210319105224288"></p>
</li>
</ul>
<p>下面讲具体讲解这些参数</p>
<ul>
<li><p><strong>核心池大小的选择</strong></p>
<p>我们需要对线程池的大小进行适当调整，当线程池中核心线程数量过大时，线程与线程之间会争取CPU资源，这样就会导致上下文切换。过多的上下文切换会增加线程的执行时间，影响了整体执行的效率；当线程池中的核心线程数量过少时，如果同一时间有大量任务需要处理，可能会导致大量任务在任务队列中排队等待执行，甚至会出现队列满了之后任务无法执行的情况，或者大量任务堆积在任务队列导致内存溢出（OOM）</p>
<ul>
<li><p>对于CPU密集型任务，由于CPU密集型任务的性质，导致CPU的使用率很高，如果线程池中的核心线程数量过多，会增加上下文切换的次数，带来额外的开销。因此，一般情况下线程池的核心线程数量等于CPU核心数+1。</p>
</li>
<li><p>对于I/O密集型任务，由于I/O密集型任务CPU使用率并不是很高，可以让CPU在等待I/O操作的时去处理别的任务，充分利用CPU。因此，一般情况下线程的核心线程数等于2*CPU核心数。</p>
</li>
</ul>
</li>
<li><p><strong>线程工厂</strong></p>
<p>线程工厂即是自己定义线程池中的Thread类，其主要靠实现ThreadFactory接口实现，而接口中，只声明了newThread(Runnable r)方法代表自己生成自定义的线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Thread <span class="title">newThread</span><span class="params">(Runnable r)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通常我们要自己定义一个Thread类，主要可以用来定制一些线程名、自己处理异常等</p>
</li>
<li><p><strong>拒绝策略</strong></p>
<p>当线程池中资源全部被占用时（工作队列满、线程池达最大容量），对新添加的Task任务有不同处理策略，也叫饱和策略</p>
<ul>
<li>AbortPolicy：任务 被拒绝时，抛出RejectExecutionException异常、为默认</li>
<li>CallerRunsPolicy：被拒绝时，会调用当前线程池的所在的线程去执行被拒绝的任务，即在主线程执行，阻塞主线程（优点后面提交的任务会等待，缺点也是阻塞）</li>
<li>DiscardOldestPolicy：被拒绝时，线程池放弃等待队列中最旧的任务添加它</li>
<li>DiscardPolicy：被拒绝时，丢弃它</li>
</ul>
</li>
</ul>
<h3 id="利用Executors工厂类生成线程池"><a href="#利用Executors工厂类生成线程池" class="headerlink" title="利用Executors工厂类生成线程池"></a>利用Executors工厂类生成线程池</h3><ul>
<li><p><strong>使用newCachedThreadPool创建可缓存线程</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span>    </span></span><br></pre></td></tr></table></figure>
<p>其自动回收空闲线程和添加新线程，规模不受限制</p>
<p>默认使用SynchronousQueue，避免直接排队，直接提交任务</p>
</li>
<li><p><strong>利用newFixedThreadPool创建有界线程池</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span></span></span><br></pre></td></tr></table></figure>
<p>int型参数代表线程池最大数量，每提交一个任务创建一个线程，直到达到最大数量，空闲线程保留</p>
<p>默认采用无界队列LinkedBlockingQueue</p>
</li>
<li><p><strong>利用newSingleThreadExecutor创建单一线程池</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span></span><br></pre></td></tr></table></figure>
<p>创建单一线程池，能保证按照任务在队列中的顺序串行执行</p>
<p>默认采用无界队列LinkedBlockingQueue</p>
</li>
<li><p><strong>利用newScheduledThreadPool创建可延时执行的有界线程池</strong></p>
<p>参数同newFixedThreadPool一致，可以延迟、定时执行</p>
</li>
</ul>
<h1 id="五、多线程如何保证线程安全"><a href="#五、多线程如何保证线程安全" class="headerlink" title="五、多线程如何保证线程安全"></a>五、多线程如何保证线程安全</h1><h2 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h2><p>线程安全：当多个线程访问一个类时，不管这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步和协同，这个类都能表现出正确的行为，那么称这个类是线程安全的。</p>
<p>但如果如果多个线程共享一个可变的状态变量没有使用合适的同步，程序就会出现错误，影响线程安全性。</p>
<p>比如常见的：</p>
<ul>
<li>竞态条件：某个计算的正确性取决于多个线程交替执行时序：常见有Check-Then-Act操作、读取-修改-写入操作</li>
<li>数据竞争：访问共享的非final域没有采用同步协同</li>
</ul>
<h2 id="1-不可变"><a href="#1-不可变" class="headerlink" title="1.不可变"></a>1.不可变</h2><p>多使用不可变对象，不可变对象一定是线程安全的。</p>
<p>常见不可变类型：</p>
<ul>
<li>String、Integer、Long等</li>
<li>枚举类型</li>
<li>final关键词修饰的基本数据类型</li>
<li>利用<code>Collections.unmodifiable...()</code>获取的不可变集合（视图）</li>
</ul>
<h2 id="2-互斥同步"><a href="#2-互斥同步" class="headerlink" title="2.互斥同步"></a>2.互斥同步</h2><p>利用一般用synchronized或ReentrantLock实现同步实现互斥同步，同步块在已进入时会阻塞其他线程。</p>
<h2 id="3-非阻塞同步"><a href="#3-非阻塞同步" class="headerlink" title="3.非阻塞同步"></a>3.非阻塞同步</h2><p>基于冲突检测的乐观并发策略：先操作，如果没有其他线程征用直接成功，有再进行补偿，这种实现常常不用将线程挂起，也叫非阻塞同步。</p>
<p>原理：CAS</p>
<p>许多原子类应用了这个方案</p>
<h2 id="4-线程封闭"><a href="#4-线程封闭" class="headerlink" title="4.线程封闭"></a>4.线程封闭</h2><p>当某个对象被封闭在一个线程中，将自动实现线程安全性</p>
<p><strong>1.栈封闭</strong></p>
<p>多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackClosedExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add100</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上诉代码中的count是局部变量，在在这个方法中无论多少个线程调用，输出总为100</p>
<p><strong>2.ThreadLocal类</strong></p>
<p>ThreadLocal类可以使得线程中的某个值和保存值的对象关联起来，并且为每个线程都有独立的一份值副本。通过get和set等访问接口或方法获取值。</p>
<p>显然，当某个频繁执行的操作需要某个对象，而同时又希望避免在每次执行时都重新分配临时变量，就可以使用这项技术</p>
<h1 id="六、互斥同步"><a href="#六、互斥同步" class="headerlink" title="六、互斥同步"></a>六、互斥同步</h1><h2 id="1-Synchronized"><a href="#1-Synchronized" class="headerlink" title="1.Synchronized"></a>1.Synchronized</h2><ul>
<li><p><strong>原理</strong></p>
<p>Jvm基于进入和退出Monitor对象来实现方法同步和代码块同步。</p>
<p>其中：</p>
<ul>
<li><p>方法级的同步是隐式，即无需通过字节码指令来控制的，它实现在方法调用和返回操作之中。JVM可以从方法常量池中的方法表结构 中的 <code>ACC_SYNCHRONIZED </code>访问标志区分一个方法是否同步方法。当方法调用时，调用指令将会 检查方法的<code>ACC_SYNCHRONIZED</code>访问标志是否被设置，如果设置了，执行线程将先持有monitor（虚拟机规范中用的是管程一词）， 然后再执行方法，最后再方法完成(无论是正常完成还是非正常完成)时释放monitor。</p>
</li>
<li><p>代码块的同步是利用<code>monitorenter</code>和<code>monitorexit</code>这两个字节码指令。它们分别位于同步代码块的开始和结束位置。当JVM执行到<code>monitorenter</code>指令时，当前线程试图获取monitor对象的所有权，如果未加锁或者已经被当前线程所持有，就把锁的计数器+1；当执行<code>monitorexit</code>指令时，锁计数器-1；当锁计数器为0时，该锁就被释放了。如果获取monitor对象失败，该线程则会进入阻塞状态，直到其他线程释放锁。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>使用</strong></p>
<ul>
<li>通常作用形式：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">  <span class="comment">// 代码块...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>synchronized只作用于一个对象，当一个线程持有这个对象的锁时，另一个线程再访问这个对象的同步代码块就会进入阻塞（JVM可以优化为自旋）</p>
<ul>
<li><p>同步一个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">func</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当同步一个方法时，实际是作用于持有这个方法的对象</p>
</li>
<li><p>同步一个类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (A.class) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当同步一个类时，实际是作用于这个类，即两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步</p>
</li>
<li><p>同步一个静态方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即同步了这个类</p>
</li>
</ul>
</li>
<li><p><strong>条件队列</strong></p>
<p>Java中线程之间的任务存在状态依赖，即在这些任务中有一些操作有着基于状态的前提条件，比如不能从空队列中删除一个元素、或获取一个尚未结束任务的结果，</p>
<p>依赖状态的操作可用一直堵塞到可以继续执行，在synchronized中可以通过内置条件队列实现这个操作。</p>
<p>条件队列是指可以使得一组线程能够通过某种方式来等待特定的条件为真，元素是线程的队列。如同一个对象可以作为一个锁一般，一个对象也可以作为一个条件队列。</p>
<p>在条件等待中，包括加锁、wait方法和一个条件谓语，在条件谓语中包含多个状态变量，这些状态由一个锁来保护，要求测试条件谓语时先持有这个锁，又要求锁对象和条件队列对象必须是同一个对象。</p>
<p>通常一个内置条件队列的使用包括等待与通知，通过一个条件谓语判断是否将一个线程放入这个对象的条件队列中，又通过另一个线程改变了状态将条件队列中的线程唤醒</p>
<ul>
<li><p><strong>等待</strong></p>
<p>下面是状态依赖方法的标准形式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stateDependentMethod</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    <span class="comment">// 必须通过锁来保护条件谓语</span></span><br><span class="line">    <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">        <span class="comment">// 等待</span></span><br><span class="line">        <span class="keyword">while</span>(!conditionPredicate())</span><br><span class="line">            lock.wait();</span><br><span class="line">        <span class="comment">// 合适状态操作</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，wait方法被while循环包裹是因为当wait返回时条件谓语并不为真时，可以让wait继续等待</p>
</li>
<li><p><strong>通知</strong></p>
<p>每当在等待一个条件时，就需要确保在条件谓语变成真时通过某种方式进行通知</p>
<p>在条件队列中可以通过notify和notifyAll，其中前者是通知条件队列中一个线程、后者是所有，但无论使用谁，都需要持有和条件队列对象相关联的锁</p>
<p>下面是条件通知的标准形式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line"><span class="comment">// 可能改变条件谓语状态的操作</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// 条件通知</span></span><br><span class="line"><span class="keyword">if</span>(状态切换)</span><br><span class="line">   lock.notifyAll(); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>一般情况下尽量使用notifyAll而不是notify，防止信号丢失，除非条件队列上的所有等待线程类型相同且符合单进单出（每次通知，最多唤醒一个线程执行）</p>
</li>
</ul>
</li>
</ul>
<h2 id="2-ReentrantLock"><a href="#2-ReentrantLock" class="headerlink" title="2.ReentrantLock"></a>2.ReentrantLock</h2>]]></content>
      <categories>
        <category>Java并发</category>
        <category>Java语法</category>
        <category>进阶</category>
      </categories>
      <tags>
        <tag>线程</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>sql实例</title>
    <url>/2021/03/21/sql%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<p>实际练习一些SQL语句的例子</p>
<a id="more"></a>

<h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h2 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* SELECT */</span> <span class="comment">------------------</span></span><br><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">ALL</span>|<span class="keyword">DISTINCT</span>] select_expr <span class="keyword">FROM</span> -&gt; <span class="keyword">WHERE</span> -&gt; <span class="keyword">GROUP</span> <span class="keyword">BY</span> [合计函数] -&gt; <span class="keyword">HAVING</span> -&gt; <span class="keyword">ORDER</span> <span class="keyword">BY</span> -&gt; <span class="keyword">LIMIT</span></span><br><span class="line">a. select_expr</span><br><span class="line">    <span class="comment">-- 可以用 * 表示所有字段。</span></span><br><span class="line">        <span class="keyword">select</span> * <span class="keyword">from</span> tb;</span><br><span class="line">    <span class="comment">-- 可以使用表达式（计算公式、函数调用、字段也是个表达式）</span></span><br><span class="line">        <span class="keyword">select</span> stu, <span class="number">29</span>+<span class="number">25</span>, <span class="keyword">now</span>() <span class="keyword">from</span> tb;</span><br><span class="line">    <span class="comment">-- 可以为每个列使用别名。适用于简化列标识，避免多个列标识符重复。</span></span><br><span class="line">        - 使用 as 关键字，也可省略 as.</span><br><span class="line">        <span class="keyword">select</span> stu+<span class="number">10</span> <span class="keyword">as</span> add10 <span class="keyword">from</span> tb;</span><br><span class="line">b. FROM 子句</span><br><span class="line">    用于标识查询来源。</span><br><span class="line">    <span class="comment">-- 可以为表起别名。使用as关键字。</span></span><br><span class="line">        <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tb1 <span class="keyword">AS</span> tt, tb2 <span class="keyword">AS</span> bb;</span><br><span class="line">    <span class="comment">-- from子句后，可以同时出现多个表。</span></span><br><span class="line">        <span class="comment">-- 多个表会横向叠加到一起，而数据会形成一个笛卡尔积。</span></span><br><span class="line">        <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tb1, tb2;</span><br><span class="line">    <span class="comment">-- 向优化符提示如何选择索引</span></span><br><span class="line">        <span class="keyword">USE</span> <span class="keyword">INDEX</span>、<span class="keyword">IGNORE</span> <span class="keyword">INDEX</span>、<span class="keyword">FORCE</span> <span class="keyword">INDEX</span></span><br><span class="line">        <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table1 <span class="keyword">USE</span> <span class="keyword">INDEX</span> (key1,key2) <span class="keyword">WHERE</span> key1=<span class="number">1</span> <span class="keyword">AND</span> key2=<span class="number">2</span> <span class="keyword">AND</span> key3=<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table1 <span class="keyword">IGNORE</span> <span class="keyword">INDEX</span> (key3) <span class="keyword">WHERE</span> key1=<span class="number">1</span> <span class="keyword">AND</span> key2=<span class="number">2</span> <span class="keyword">AND</span> key3=<span class="number">3</span>;</span><br><span class="line">c. WHERE 子句</span><br><span class="line">    <span class="comment">-- 从from获得的数据源中进行筛选。</span></span><br><span class="line">    <span class="comment">-- 整型1表示真，0表示假。</span></span><br><span class="line">    <span class="comment">-- 表达式由运算符和运算数组成。</span></span><br><span class="line">        <span class="comment">-- 运算数：变量（字段）、值、函数返回值</span></span><br><span class="line">        <span class="comment">-- 运算符：</span></span><br><span class="line">            =, &lt;=&gt;, &lt;&gt;, !=, &lt;=, &lt;, &gt;=, &gt;, !, &amp;&amp;, ||,</span><br><span class="line">            in (not) null, (not) like, (not) in, (not) between and, is (not), and, or, not, xor</span><br><span class="line">            is/is not 加上ture/false/unknown，检验某个值的真假</span><br><span class="line">            &lt;=&gt;与&lt;&gt;功能相同，&lt;=&gt;可用于null比较</span><br><span class="line">d. GROUP BY 子句, 分组子句</span><br><span class="line">    GROUP BY 字段/别名 [排序方式]</span><br><span class="line">    分组后会进行排序。升序：ASC，降序：DESC</span><br><span class="line">    以下[合计函数]需配合 GROUP BY 使用：</span><br><span class="line">    count 返回不同的非NULL值数目  count(*)、count(字段)</span><br><span class="line">    sum 求和</span><br><span class="line">    max 求最大值</span><br><span class="line">    min 求最小值</span><br><span class="line">    avg 求平均值</span><br><span class="line">    group_concat 返回带有来自一个组的连接的非NULL值的字符串结果。组内字符串连接。</span><br><span class="line">e. HAVING 子句，条件子句</span><br><span class="line">    与 where 功能、用法相同，执行时机不同。</span><br><span class="line">    where 在开始时执行检测数据，对原数据进行过滤。</span><br><span class="line">    having 对筛选出的结果再次进行过滤。</span><br><span class="line">    having 字段必须是查询出来的，where 字段必须是数据表存在的。</span><br><span class="line">    where 不可以使用字段的别名，having 可以。因为执行WHERE代码时，可能尚未确定列值。</span><br><span class="line">    where 不可以使用合计函数。一般需用合计函数才会用 having</span><br><span class="line">    SQL标准要求HAVING必须引用GROUP BY子句中的列或用于合计函数中的列。</span><br><span class="line">f. ORDER BY 子句，排序子句</span><br><span class="line">    order by 排序字段/别名 排序方式 [,排序字段/别名 排序方式]...</span><br><span class="line">    升序：ASC，降序：DESC</span><br><span class="line">    支持多个字段的排序。</span><br><span class="line">g. LIMIT 子句，限制结果数量子句</span><br><span class="line">    仅对处理好的结果进行数量限制。将处理好的结果的看作是一个集合，按照记录出现的顺序，索引从0开始。</span><br><span class="line">    limit 起始位置, 获取条数</span><br><span class="line">    省略第一个参数，表示从索引0开始。limit 获取条数</span><br><span class="line">h. DISTINCT, ALL 选项</span><br><span class="line">    distinct 去除重复记录</span><br><span class="line">    默认为 all, 全部记录</span><br></pre></td></tr></table></figure>
<h2 id="UNION"><a href="#UNION" class="headerlink" title="UNION"></a>UNION</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* UNION */</span> <span class="comment">------------------</span></span><br><span class="line">    将多个<span class="keyword">select</span>查询的结果组合成一个结果集合。</span><br><span class="line">    <span class="keyword">SELECT</span> ... <span class="keyword">UNION</span> [<span class="keyword">ALL</span>|<span class="keyword">DISTINCT</span>] <span class="keyword">SELECT</span> ...</span><br><span class="line">    默认 <span class="keyword">DISTINCT</span> 方式，即所有返回的行都是唯一的</span><br><span class="line">    建议，对每个<span class="keyword">SELECT</span>查询加上小括号包裹。</span><br><span class="line">    <span class="keyword">ORDER</span> <span class="keyword">BY</span> 排序时，需加上 <span class="keyword">LIMIT</span> 进行结合。</span><br><span class="line">    需要各<span class="keyword">select</span>查询的字段数量一样。</span><br><span class="line">    每个<span class="keyword">select</span>查询的字段列表(数量、类型)应一致，因为结果中的字段名以第一条<span class="keyword">select</span>语句为准。</span><br></pre></td></tr></table></figure>
<h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 子查询 */</span> <span class="comment">------------------</span></span><br><span class="line">    - 子查询需用括号包裹。</span><br><span class="line"><span class="comment">-- from型</span></span><br><span class="line">    from后要求是一个表，必须给子查询结果取个别名。</span><br><span class="line">    - 简化每个查询内的条件。</span><br><span class="line">    - from型需将结果生成一个临时表格，可用以原表的锁定的释放。</span><br><span class="line">    - 子查询返回一个表，表型子查询。</span><br><span class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> (<span class="keyword">select</span> * <span class="keyword">from</span> tb <span class="keyword">where</span> <span class="keyword">id</span>&gt;<span class="number">0</span>) <span class="keyword">as</span> subfrom <span class="keyword">where</span> <span class="keyword">id</span>&gt;<span class="number">1</span>;</span><br><span class="line"><span class="comment">-- where型</span></span><br><span class="line">    - 子查询返回一个值，标量子查询。</span><br><span class="line">    - 不需要给子查询取别名。</span><br><span class="line">    - where子查询内的表，不能直接用以更新。</span><br><span class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> tb <span class="keyword">where</span> money = (<span class="keyword">select</span> <span class="keyword">max</span>(money) <span class="keyword">from</span> tb);</span><br><span class="line">    <span class="comment">-- 列子查询</span></span><br><span class="line">        如果子查询结果返回的是一列。</span><br><span class="line">        使用 in 或 not in 完成查询</span><br><span class="line">        exists 和 not exists 条件</span><br><span class="line">            如果子查询返回数据，则返回1或0。常用于判断条件。</span><br><span class="line">            <span class="keyword">select</span> column1 <span class="keyword">from</span> t1 <span class="keyword">where</span> <span class="keyword">exists</span> (<span class="keyword">select</span> * <span class="keyword">from</span> t2);</span><br><span class="line">    <span class="comment">-- 行子查询</span></span><br><span class="line">        查询条件是一个行。</span><br><span class="line">        <span class="keyword">select</span> * <span class="keyword">from</span> t1 <span class="keyword">where</span> (<span class="keyword">id</span>, gender) <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">id</span>, gender <span class="keyword">from</span> t2);</span><br><span class="line">        行构造符：(col1, col2, ...) 或 ROW(col1, col2, ...)</span><br><span class="line">        行构造符通常用于与对能返回两个或两个以上列的子查询进行比较。</span><br><span class="line">    <span class="comment">-- 特殊运算符</span></span><br><span class="line">    != all()    相当于 not in</span><br><span class="line">    = some()    相当于 in。any 是 some 的别名</span><br><span class="line">    != some()   不等同于 not in，不等于其中某一个。</span><br><span class="line">    all, some 可以配合其他运算符一起使用。</span><br></pre></td></tr></table></figure>
<h2 id="连接查询-join"><a href="#连接查询-join" class="headerlink" title="连接查询(join)"></a>连接查询(join)</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 连接查询(join) */</span> <span class="comment">------------------</span></span><br><span class="line">    将多个表的字段进行连接，可以指定连接条件。</span><br><span class="line"><span class="comment">-- 内连接(inner join)</span></span><br><span class="line">    - 默认就是内连接，可省略inner。</span><br><span class="line">    - 只有数据存在时才能发送连接。即连接结果不能出现空行。</span><br><span class="line">    on 表示连接条件。其条件表达式与where类似。也可以省略条件（表示条件永远为真）</span><br><span class="line">    也可用where表示连接条件。</span><br><span class="line">    还有 using, 但需字段名相同。 using(字段名)</span><br><span class="line">    <span class="comment">-- 交叉连接 cross join</span></span><br><span class="line">        即，没有条件的内连接。</span><br><span class="line">        <span class="keyword">select</span> * <span class="keyword">from</span> tb1 <span class="keyword">cross</span> <span class="keyword">join</span> tb2;</span><br><span class="line"><span class="comment">-- 外连接(outer join)</span></span><br><span class="line">    - 如果数据不存在，也会出现在连接结果中。</span><br><span class="line">    <span class="comment">-- 左外连接 left join</span></span><br><span class="line">        如果数据不存在，左表记录会出现，而右表为null填充</span><br><span class="line">    <span class="comment">-- 右外连接 right join</span></span><br><span class="line">        如果数据不存在，右表记录会出现，而左表为null填充</span><br><span class="line"><span class="comment">-- 自然连接(natural join)</span></span><br><span class="line">    自动判断连接条件完成连接。</span><br><span class="line">    相当于省略了using，会自动查找相同字段名。</span><br><span class="line">    natural join</span><br><span class="line">    natural left join</span><br><span class="line">    natural right join</span><br><span class="line"><span class="keyword">select</span> info.id, info.name, info.stu_num, extra_info.hobby, extra_info.sex <span class="keyword">from</span> info, extra_info <span class="keyword">where</span> info.stu_num = extra_info.stu_id;</span><br></pre></td></tr></table></figure>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis</title>
    <url>/2021/03/23/Mybatis/</url>
    <content><![CDATA[<p>学会使用MyBatis来简化JDBC开发</p>
<a id="more"></a>

<h1 id="MyBatis简介"><a href="#MyBatis简介" class="headerlink" title="MyBatis简介"></a>MyBatis简介</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）访问修改数据库中的记录。</p>
<p>其简单原理在于其内部封装了JDBC。Mybatis是通过xml或注解的方式将需要执行的各种statement配置起来。通过Java对象和statement中的sql动态参数映射生成最终执行的sql语句，最终由Mabtais框架执行sql并将结果映射为Java对象并返回。MyBatis 支持定制化 SQL、存储过程以及高级映射。MyBatis 是可以双向映射的，可以将数据集映射为Java对象，也可以将Java对象映射为数据库中的记录。</p>
<p>总的来说，MyBatis有以下优点：</p>
<ul>
<li>简单便捷</li>
<li>消除了JDBC大量冗余的代码，不需要手动开关连接</li>
<li>能够与Spring很好的集成；</li>
<li>解除sql与程序代码的耦合，便于统一管理和优化，并可重用。</li>
<li>提供映射标签，支持对象与数据库的ORM字段关系映射。</li>
</ul>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>MyBatis工作原理或者说是工作流程如下所示</p>
<p><img src="/images/image-20210323095338627.png" alt="image-20210323095338627"></p>
<p>Mybatis应用程序通过<strong>SqlSessionFactoryBuilder</strong>从<strong>mybatis-config.xml</strong>配置文件（也可以用Java注解方式配置）来构建<strong>SqlSessionFactory</strong>（一般设置为单例模式）。然后<strong>SqlSessionFactory</strong>实例一般在一个工具类里面，可以返回一个<strong>SqlSession</strong>，再通过<strong>SqlSession</strong>实例获得<code>Mapper</code>对象并运行<code>Mapper</code>映射的SQL语句，完成对数据库的CRUD和事务提交，之后<strong>关闭SqlSession</strong>。<br>综上，<code>SqlSessionFactoryBuilder</code>的作用在于生成一个<code>SqlSessionFactory</code>工厂实例，而<code>SqlSessionFactory</code>作用在于产生<code>SqlSession</code>对象，这里的<code>SqlSession</code>相当于JDBC中的<code>Connection</code>,底层就封装了JDBC连接,是个持久化对象。</p>
<h1 id="简单MyBatis实例"><a href="#简单MyBatis实例" class="headerlink" title="简单MyBatis实例"></a>简单MyBatis实例</h1><p>开发环境</p>
<ul>
<li>IDEA 2021</li>
<li>Maven 3.6.3</li>
<li>Mysql 8.2.3</li>
<li>MyBatis</li>
<li>Junit</li>
</ul>
<p>个人最终文件目录如下，下文生成的文件、类均在对应目录下生成</p>
<p><img src="/images/image-20210323144235237.png" alt="image-20210323144235237"></p>
<p><strong>1.数据库准备</strong></p>
<p>利用<code>Mysql  WorkBench</code>,创建一个学生表，并且插入几条数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> mybatis;</span><br><span class="line"><span class="keyword">use</span> mybatis;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span> (</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">8</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"><span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">default</span> <span class="literal">null</span>,</span><br><span class="line">psd <span class="built_in">varchar</span>(<span class="number">30</span>) <span class="keyword">default</span> <span class="literal">null</span>,</span><br><span class="line">sex <span class="built_in">char</span>(<span class="number">2</span>),</span><br><span class="line">primary <span class="keyword">key</span>(<span class="keyword">id</span>)</span><br><span class="line">)<span class="keyword">engine</span>=<span class="keyword">InnoDB</span> <span class="keyword">default</span> <span class="keyword">charset</span>=utf8;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;123456&#x27;</span>,<span class="string">&#x27;女&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="string">&#x27;23456&#x27;</span>,<span class="string">&#x27;男&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;王五&#x27;</span>,<span class="string">&#x27;3456&#x27;</span>,<span class="string">&#x27;女&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>2.导入依赖</strong></p>
<p>创建Maven工程文件，在<a href="https://mvnrepository.com/">Maven查询</a>中找到最新的MyBatis依赖,再加上之前的mysql驱动的依赖和Junit进行测试</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--mybatis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--mysql driver--&gt;</span>	</span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.23<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- junit --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>3.配置mybatis-config.xml文件</strong></p>
<p>在resources文件中添加以下mybatis-config.xml配置文件,并把以下内容复制进去</p>
<p>XML 配置文件中包含了对 MyBatis 系统的核心设置，包括获取数据库连接实例的数据源（DataSource）以及决定事务作用域和控制方式的事务管理器（TransactionManager）。后面会再探讨 XML 配置文件的详细内容，这里先给出一个简单的示例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">  <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里主要修改以下driver，自己mysql数据库的url和登陆账号密码即可,注意mysql 8 以上有时区问题</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis?serverTimezone=GMT%2B8<span class="symbol">&amp;amp;</span>useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=UTF-8&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>以上信息可以确保在MyBatis可以和mysql中我们新建的数据库建立连接</p>
<p><strong>4.编写MyBatis工具类</strong></p>
<p>主要是通过通过<code>SqlSessionFactoryBuilder</code>从<code>mybatis-config.xml</code>配置文件来构建<code>SqlSessionFactory</code>，之后里getter方法可以生成一个<code>SqlSession</code>对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxx.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.io.Resources;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String resource = <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">            InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">            sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">getSqlSession</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory.openSession();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>5.编写User类</strong></p>
<p>User类是一个POJO对象，其与数据库中的user表属性对应，即ORM</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxx.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String psd;</span><br><span class="line">    <span class="keyword">private</span>  String sex;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> id, String name, String psd, String sex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.psd = psd;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, psd=&#x27;&quot;</span> + psd + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, sex=&#x27;&quot;</span> + sex + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 后面getter、setter方法自动生成，这里省略不写了</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>6.建立User类的dao接口和其对应的Mapper.xml实现</strong></p>
<p>建立User类的Dao接口，但是在MyBatis里面，一般命名为Mapper,这个接口中包含了一些对数据库操作的封装方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxx.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.xxx.pojo.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取用户列表</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般来说，使用JDBC是需要实现 UserMapper接口，在MyBatis中，只要用一个xml文件与该接口绑定即可，就可以xml文件在写对应方法的sql语句,下面的Mapper接口对应的xml绑定文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- namespece=和对应Mapper绑定--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.xxx.dao.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- id和方法绑定，type指定返回类型--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.xxx.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        select * from mybatis.user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>7.注意把一组Mapper放到最开始的<code>mybatis-config.xml</code></strong></p>
<p>这里通过资源注册</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/xxx/dao/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这时基本所有配置完毕</p>
<p><strong>8.Maven引发的异常</strong></p>
<p>这时尝试运行会传来以下错误</p>
<p><img src="/images/image-20210323150442996.png" alt="image-20210323150442996"></p>
<p>主要是因为maven项目中有一个目录标准，<strong>其中src/main/java下的xml文件构建时不会被输出到<code>target/classes</code>目录下</strong>.所以运行时找不到下面来解决它，只需在pom.xml中配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>将java下的xml文件也能作为资源文件导出</p>
<p>再运行</p>
<p><img src="/images/image-20210323151723651.png" alt="image-20210323151723651"></p>
<p>成功，第一个案例简单完成</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>中间件</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot</title>
    <url>/2021/03/22/Spring-Boot/</url>
    <content><![CDATA[<p>学习Spring Boot，对Spring、Spring MVC进行简单开发</p>
<a id="more"></a>

<p>Spring 框架从5.x版本</p>
<h1 id="Spring-5-x零配置开发"><a href="#Spring-5-x零配置开发" class="headerlink" title="Spring 5.x零配置开发"></a>Spring 5.x零配置开发</h1><h1 id="Spring-MVC零配置创建和部署"><a href="#Spring-MVC零配置创建和部署" class="headerlink" title="Spring MVC零配置创建和部署"></a>Spring MVC零配置创建和部署</h1>]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Jmeter压力测试</title>
    <url>/2021/03/29/Jmeter/</url>
    <content><![CDATA[<p>对秒杀系统进行压力测试</p>
<a id="more"></a>

<h1 id="1-安装Jmeter"><a href="#1-安装Jmeter" class="headerlink" title="1.安装Jmeter"></a>1.安装Jmeter</h1><ul>
<li><p><strong>下载压缩包</strong></p>
<p><a href="https://jmeter.apache.org/download_jmeter.cgi">下载地址</a></p>
</li>
<li><p><strong>解压到安装目录</strong></p>
<p>解压目录即安装目录，<code>D:\Program\apache-jmeter-5.4.1</code></p>
</li>
<li><p><strong>配置系统环境变量</strong></p>
<ul>
<li>首先保证自己之前已经建立好Java环境，然后在打开系统属性，选择高级-&gt;环境变量中新建一个JMETER_Home系统变量，值为其安装目录bin上一级，我的是<code>D:\Program\apache-jmeter-5.4.1</code>,</li>
<li>最后在在编辑CLASSPATH对象，加上<code>%JMETER_HOME%\lib\ext\ApacheJMeter_core.jar;%JMETER_HOME%\lib\jorphan.jar;%JMETER_HOME%\lib\logkit-2.0.jar;</code>即可</li>
</ul>
</li>
<li><p><strong>打开Jmeter</strong></p>
<p>在安装目录下打开bin文件夹，找到<code>jmeter.bat</code>打开即可启用</p>
</li>
</ul>
<h1 id="2-简单使用Jmeter进行压测"><a href="#2-简单使用Jmeter进行压测" class="headerlink" title="2.简单使用Jmeter进行压测"></a>2.简单使用Jmeter进行压测</h1><p>首先打开Jmeter后，可以在<code>Options</code>-&gt;<code>choose language</code>里面将语言改为中文</p>
<p><strong>1.添加线程组</strong></p>
<p>右键测试计划，添加线程里面选择线程组</p>
<p><img src="/images/image-20210329185400986.png" alt="image-20210329185400986"></p>
<p>关键参数是线程数、Ramp-up time和循环次数</p>
<p>Ramp-up time是规定所有线程在时间段内把请求执行完（指一次循环），而且请求的时间间隔是固定的=Ramp-Up time/线程数。所以设置为0可以用压测服务器最大的能力持续发送请求</p>
<p>循环次数和线程数的参数不难理解</p>
<p>添加完线程组之后，应该需要对HTTP请求进行管理，下面几步就是管理步骤</p>
<p><strong>2.添加默认请求头信息</strong></p>
<p>点击线程组右键添加配置元件，添加HTTP请求默认值</p>
<p><img src="/images/image-20210329190855888.png" alt="image-20210329190855888"></p>
<p>这里我填写web站点的基础信息</p>
<p>下面设置具体的HTTP请求参数</p>
<p><strong>3.具体HTTP请求参数</strong></p>
<p>首先声明，我这次压测是模拟所有用户对一个商品的秒杀，这里需要不同的userId作为请求报文的参数，需要对所有请求配置不同的userId参数，而商品id的参数可以固定</p>
<ul>
<li><p><strong>设置不同用户Id</strong></p>
<ul>
<li>从数据库在将userId导出为CSV文件（txt）也可以，每个ID一行，我保存在桌面data中</li>
</ul>
<p><img src="/images/image-20210329191532991.png" alt="image-20210329191532991"></p>
<ul>
<li><p>点击线程组，右键添加配置文件，添加<code>CSV数据文件设置</code></p>
<p><img src="/images/image-20210329191913682.png" alt="image-20210329191913682"></p>
<p>在文件名中导入文件，并设置变量名为userId，其他默认</p>
</li>
</ul>
</li>
<li><p><strong>确定具体HTTP请求参数</strong></p>
<p>点击线程组，右键取件器，添加HTTP请求</p>
<p>设置请求具体路径，并且点击添加添加两个参数，一个是userId，用<code>$&#123;userId&#125;</code>取值，其会每一个请求从data文件中读一行取值作为userId值</p>
<p>另一个参数goodsId设置为固定值</p>
<p><img src="/images/image-20210329192644097.png" alt="image-20210329192644097"></p>
</li>
</ul>
<p><strong>4.添加监听器</strong></p>
<p>点击线程组，右键选择监听器，可以添加查看结果树、汇总报告等记录测试信息</p>
<p><strong>5.运行结果</strong></p>
<p>点击上方绿三角运行，第一次压测结束</p>
<p><img src="/images/image-20210329193330908.png" alt="image-20210329193330908"></p>
]]></content>
      <categories>
        <category>项目</category>
        <category>秒杀系统</category>
      </categories>
      <tags>
        <tag>Jmeter</tag>
        <tag>压力测试</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 基础学习</title>
    <url>/2021/03/31/Linux-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>主要认识一些常见的Linux语法</p>
<a id="more"></a>

<h1 id="系统目录结构"><a href="#系统目录结构" class="headerlink" title="系统目录结构"></a><strong>系统目录结构</strong></h1><p>该学习主要基于阿里云服务器下的CentOS系统，我选择的是7.9版本</p>
<p><strong>关机</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">sync #将数据同步到磁盘</span><br><span class="line">shutdown - h now #立即关机</span><br><span class="line">shutdown -h 10 #10分钟后关机</span><br><span class="line">shutdown -r #是重启的意思同上可接参数，同reboot</span><br></pre></td></tr></table></figure>
<p>Linux一切皆文件</p>
<p>根目录是/,根目录下面有一些目录</p>
<p>以下是对这些目录的解释：</p>
<ul>
<li><p><strong>/bin</strong>：<br>bin 是 Binaries (二进制文件) 的缩写, 这个目录存放着最经常使用的命令。</p>
</li>
<li><p><strong>/boot：</strong><br>这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。(不动)</p>
</li>
<li><p><strong>/dev ：</strong><br>dev 是 Device(设备) 的缩写, 该目录下存放的是 Linux 的外部设备，比如磁盘</p>
</li>
<li><p><strong>/etc：</strong><br><strong>这个目录用来存放所有的系统管理所需要的配置文件和子目录。</strong></p>
</li>
<li><p><strong>/home</strong>：<br><strong>用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的</strong></p>
</li>
<li><p><strong>/lib</strong>：<br>lib 是 Library(库) 的缩写这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。（不动）</p>
</li>
<li><p><strong>/lost+found</strong>：<br>这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。（存放突然关机的文件）</p>
</li>
<li><p><strong>/media</strong>：<br>linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。</p>
</li>
<li><p><strong>/mnt</strong>：<br>系统提供该目录是为了让用户临时挂载别的文件系统的，可以挂载本地文件</p>
</li>
<li><p><strong>/opt</strong>：<br><strong>opt 是 optional(可选) 的缩写，这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</strong></p>
</li>
<li><p><strong>/proc</strong>：<br>proc 是 Processes(进程) 的缩写，/proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。<br>这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器：</p>
</li>
<li><p><strong>/root</strong>：<br><strong>该目录为系统管理员，也称作超级权限者的用户主目录。</strong></p>
</li>
<li><p><strong>/sbin</strong>：<br>s 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。</p>
</li>
<li><p><strong>/selinux</strong>：<br>这个目录是 Redhat/CentOS 所特有的目录，Selinux 是一个安全机制，类似于 windows 的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。</p>
</li>
<li><p><strong>/srv</strong>：<br>该目录存放一些服务启动之后需要提取的数据。</p>
</li>
<li><p><strong>/sys</strong>：</p>
<p>这是 Linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs 。</p>
<p>sysfs 文件系统集成了下面3种文件系统的信息：针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端的 devpts 文件系统。</p>
<p>该文件系统是内核设备树的一个直观反映。</p>
<p>当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。</p>
</li>
<li><p><strong>/tmp</strong>：<br><strong>tmp 是 temporary(临时) 的缩写这个目录是用来存放一些临时文件的。</strong></p>
</li>
<li><p><strong>/usr</strong>：<br><strong>usr 是 unix shared resources(共享资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录</strong>。</p>
</li>
<li><p><strong>/usr/bin：</strong><br>系统用户使用的应用程序。</p>
</li>
<li><p><strong>/usr/sbin：</strong><br>超级用户使用的比较高级的管理程序和系统守护程序。</p>
</li>
<li><p><strong>/usr/src：</strong><br>内核源代码默认的放置目录。</p>
</li>
<li><p><strong>/var</strong>：<br>var 是 variable(变量) 的缩写，这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</p>
</li>
<li><p><strong>/run</strong>：<br>是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。</p>
</li>
</ul>
<h1 id="常用基本命令"><a href="#常用基本命令" class="headerlink" title="常用基本命令"></a><strong>常用基本命令</strong></h1><h2 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a><strong>目录管理</strong></h2><p>ls</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls 列出目录</span><br><span class="line">ls -a 列出所有文件，</span><br><span class="line">ls -l包含文件属性和权限</span><br></pre></td></tr></table></figure>
<p>cd</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd 切换目录，绝对目录&#x2F;开头 相对路径..&#x2F;上一级</span><br></pre></td></tr></table></figure>
<p>pwd</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwd 显示当前用户所在目录</span><br></pre></td></tr></table></figure>
<p>mkdir</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir 创建一个目录</span><br><span class="line">mkdir -p 递归创建目录</span><br></pre></td></tr></table></figure>
<p>rmdir</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rmdir 移除目录文件，仅仅是空的</span><br><span class="line">redir -p</span><br></pre></td></tr></table></figure>
<p>cp</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp 复制文件或目录</span><br><span class="line">cp 原来的地方 新的地方</span><br></pre></td></tr></table></figure>
<p>rm</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm 移除文件或目录</span><br><span class="line">rm -f 忽略不存在的目录</span><br><span class="line">rm -r 递归删除</span><br><span class="line">rm -a 可以删除隐藏文件</span><br></pre></td></tr></table></figure>
<p>mv</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mv 移动文件或目录</span><br><span class="line">mv -f 强制</span><br><span class="line">mv -u 只是覆盖已经更新过的文件</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a><em>文件管理</em></h2><p><strong>文件权限</strong></p>
<p>文件权限是9个，3个一组，对应 属主、属组、其他用户权限的，每三位代表读写执行</p>
<p>chmod</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod 修改文件权限</span><br><span class="line">chmod 777 文件名 可读可写可执行</span><br></pre></td></tr></table></figure>
<p><strong>文件内容查看</strong></p>
<p>cat</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat 从第一行显示文件内容</span><br><span class="line">nl 还显示行号</span><br><span class="line">head -n 参数 行数 从头</span><br><span class="line">tail -n 参数 从尾看多少行</span><br><span class="line">less 一页一页读</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a><strong>链接</strong></h2><p>硬链接：A–B，如果B是A的硬链接，则A，B指向同一个文件，则允许一个文件有多个路径，可以防止误删</p>
<p>软链接：类似Windows下的快捷方式删除源文件，快捷键访问不了</p>
<p>ln</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ln a b 硬链接</span><br><span class="line">ln -s a b 软链接</span><br></pre></td></tr></table></figure>


<h2 id="Vim编辑器"><a href="#Vim编辑器" class="headerlink" title="Vim编辑器"></a><strong>Vim编辑器</strong></h2><p>Vim有三个模式命令模式、Insert模式、底线命令模式</p>
<p>一进入是命令模式，按<code>i</code>进入Insert模式，可以编辑文本</p>
<p>在Insert模式中。按<code>ESC</code>退出到命令模式</p>
<p>在命令模式中，按<code>：</code>进入底线命令模式，主要使用wq可以保存退出</p>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-软件安装</title>
    <url>/2021/03/31/Linux-%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>主要是在Linux下安装Java开发环境</p>
<a id="more"></a>

<p>安装软件一般有三种方式</p>
<ul>
<li><p>rpm</p>
</li>
<li><p>解压缩</p>
</li>
<li><p>yum在线安装</p>
</li>
</ul>
<h1 id="JDK安装"><a href="#JDK安装" class="headerlink" title="JDK安装"></a>JDK安装</h1><p><strong>这里采用rpm安装</strong></p>
<p>首先可以在自己的机子上安装XFTP和Xshell方便上传文件和远程连接服务器</p>
<ul>
<li><p><strong>本机下载Linux下相应rpm安装包</strong></p>
<p><a href="https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html">下载地址</a></p>
<p>我下载的是<code>jdk-8u281-linux-x64.rpm</code>版本</p>
</li>
<li><p><strong>放置目录</strong></p>
<p>我打算放在在Opt目录下，新建一个文件夹Java文件夹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir &#x2F;opt&#x2F;java</span><br></pre></td></tr></table></figure>
<p>然后在XFTP中直接将下载文件上传到服务器的<code>/opt/java</code>目录下</p>
</li>
<li><p><strong>设置文件权限</strong></p>
<p><img src="/images/image-20210331104854873.png" alt="image-20210331104854873"></p>
<p>上传后可以发现其没有运行权限，所以利用</p>
<p><code>chmod 777 jdk-8u281-linux-x64.rpm </code></p>
<p>设置其有运行权限</p>
</li>
<li><p><strong>rpm命令安装</strong></p>
<p>先判断是否有jdk环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -qa|grep jdk #检测jdk版本信息</span><br><span class="line">rpm -e --nodeps 查询到的信息  #卸载</span><br></pre></td></tr></table></figure>
<p>安装命令</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">rpm -ivk 安装包</span><br></pre></td></tr></table></figure>
<p>安装完毕后，可以<code>java -version</code>查看是否成功</p>
<p>rpm安装方式，通过RPM方式安装时，是严格遵照Linux对环境变量的路径的要求,不需配置环境，不需安装相关依赖（依赖自动安装）</p>
</li>
<li><p><strong>运行项目</strong></p>
<p>一般需要将项目打包成jar包</p>
<p>直接用<code>java -jar jar包</code>名执行</p>
</li>
</ul>
<h1 id="Tomcat安装"><a href="#Tomcat安装" class="headerlink" title="Tomcat安装"></a>Tomcat安装</h1><p>这里采用<strong>解压缩方式安装</strong></p>
<p>这里是针对如果Web项目不是Spring Boot ,比如SSM war包就需要放在Tomcat中运行</p>
<ul>
<li><p><strong>下载压缩包并上传到Linux上</strong></p>
<p><a href="https://tomcat.apache.org/download-10.cgi">下载地址</a></p>
<p>我下载的是<code>apache-tomcat-10.0.4.tar.gz</code></p>
</li>
<li><p><strong>解压</strong></p>
<p>在放置目录，tar命令解压</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar-zxvf apache-tomcat-10.0.4.tar.gz</span><br></pre></td></tr></table></figure></li>
<li><p><strong>启动停止</strong></p>
<p>在bin目录下<code>./startup.sh</code> 启动Tomcat</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;startup.sh 启动</span><br><span class="line">.&#x2F;shutdown.sh 关闭</span><br></pre></td></tr></table></figure></li>
<li><p><strong>对Tomcat8080端口防火墙进行管理</strong></p>
<p>主要看下面后三步，看8080端口是否打开，没有则打开重启生效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl status firewalld #防火墙状态</span><br><span class="line">firewall-cmd --zone&#x3D;public --list-ports #查看端口</span><br><span class="line">firewall-cmd --zone&#x3D;public --add-port&#x3D;8080&#x2F;tcp --permanent #打开指定端口</span><br><span class="line">firewall-cmd --reload 更新修改</span><br></pre></td></tr></table></figure>
<p>做完上诉流程，则可以通过服务器地址8080端口访问Tomcat</p>
</li>
</ul>
<h1 id="Redis安装"><a href="#Redis安装" class="headerlink" title="Redis安装"></a><strong>Redis安装</strong></h1><p>这里采用<strong>yum</strong>进行在线安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">yum -y inatall 包名</span><br></pre></td></tr></table></figure>
<p>我们安装redis</p>
<p>即</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install redis 即可</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对redis的基本操作：启动、查看状态、停止、重启</span><br><span class="line">systemctl start redis</span><br><span class="line">systemctl status redis</span><br><span class="line">systemctl stop redis </span><br><span class="line">systemctl restart redis</span><br><span class="line"></span><br><span class="line">ps -ef |grep redis          查看redis进程</span><br><span class="line">systemctl enable redis      设置开机自启动</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>防火墙设置</p>
<p>Redis需要对6379防火墙进行设置</p>
<p>就是上面的老操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl status firewalld #防火墙状态</span><br><span class="line">firewall-cmd --zone&#x3D;public --list-ports #查看端口</span><br><span class="line">firewall-cmd --zone&#x3D;public --add-port&#x3D;8080&#x2F;tcp --permanent #打开指定端口</span><br><span class="line">firewall-cmd --reload 更新修改</span><br></pre></td></tr></table></figure>


<p><strong>Redis配置修改</strong></p>
<p>进入编辑配置文科</p>
<p><code>vim /etc/redis.conf</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bind 127.0.0.1 注释掉 #bind 127.0.0.1 否则只能本机访问</span><br><span class="line">daemonize no 改为 daemonize yes 可以后台运行</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>操作系统</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis</title>
    <url>/2021/03/30/Redis/</url>
    <content><![CDATA[<p>学习Redis，了解其常见数据结构及应用场景</p>
<a id="more"></a>



<h1 id="一、缓存"><a href="#一、缓存" class="headerlink" title="一、缓存"></a>一、缓存</h1><p>缓存的本质思想就是空间换时间，CPU Cache 缓存的是内存数据用于解决 CPU 处理速度和内存不匹配的问题，内存缓存的是硬盘数据用于解决硬盘访问速度过慢的问题。</p>
<p>回到我们对数据库的访问来说，我们为了避免用户在请求数据的时候获取速度过于缓慢，所以我们在数据库之上增加了缓存这一层来弥补</p>
<h2 id="常见缓存方案"><a href="#常见缓存方案" class="headerlink" title="常见缓存方案"></a>常见缓存方案</h2><p>缓存的类型分为：<strong>本地缓存</strong>、<strong>分布式缓存</strong>和<strong>多级缓存</strong></p>
<ul>
<li><p><strong>本地缓存</strong></p>
<p>直接在进程的内存中进行缓存，比如我们的 JVM 堆中，我的秒杀系统1.0版就是应用了一个<code>HashMap</code>作为本地缓存。Java中本地缓存使用 <code>Ehcache</code>这样的工具来实现,主要增加了过期机制。</p>
<p>由于本地缓存是内存访问，没有远程交互开销，性能最好，但是受限于单机容量，一般缓存较小且无法扩展。</p>
</li>
<li><p><strong>分布式缓存</strong></p>
<p>本地缓存对分布式架构支持不友好，并且明显受服务部署所在的机器限制，分布式缓存可以很好得解决这个问题。</p>
<p>分布式缓存一般都具有良好的水平扩展能力，对较大数据量的场景也能应付自如。缺点就是需要进行远程请求，性能不如本地缓存</p>
</li>
<li><p><strong>多级缓存</strong></p>
<p>多级缓存可以用来平衡上诉两种情况，在本地缓存只保存访问频率最高的部分热点数据，其他的热点数据放在分布式缓存中。（这时候就应该想到操作系统中的快表、LRU这些东西了）</p>
<p>这也是最常用的缓存方案，单考单一的缓存方案往往难以撑住很多高并发的场景</p>
</li>
</ul>
<h2 id="缓存读写策略"><a href="#缓存读写策略" class="headerlink" title="缓存读写策略"></a>缓存读写策略</h2><p>但使用缓存后，就得考虑如何将数据更新回数据库，下面是几种方案</p>
<h1 id="二、Redis"><a href="#二、Redis" class="headerlink" title="二、Redis"></a>二、Redis</h1><h2 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h2><h2 id="Redis常见数据结构及应用场景"><a href="#Redis常见数据结构及应用场景" class="headerlink" title="Redis常见数据结构及应用场景"></a>Redis常见数据结构及应用场景</h2><p>在学习这里时，可以先在Linux上安装Redis，安装过程可以见我博客<code>操作系统—&gt;Linux—&gt;Linux软件安装</code>博客</p>
<p>下面开始介绍Redis常用的数据结构</p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>Redis 是用 C 语言写的，但是 Redis 并没有使用 C 的字符串表示，而是自己构建了一种 <strong>简单动态字符串</strong>（simple dynamic string，<strong>SDS</strong>）这意味着使用者可以修改，它的底层实现有点类似于 Java 中的 ArrayList。此外，Redis 还对内存做极致的优化，不同长度的字符串使用不同的结构体来表示。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span></span><br><span class="line">    unsignedchar flags; <span class="comment">/* 3 lsb of type, and 5 msb of string length */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    unsignedchar flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    unsignedchar flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    unsignedchar flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    unsignedchar flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>C 语言使用了一个长度为 N+1 的字符数组来表示长度为 N 的字符串，并且字符数组最后一个元素总是 <code>&#39;\0&#39;</code>,但是其没有存储字符串的长度，所以其获取长度的时间复杂度是<strong>O(N)</strong>,在Redis的SDS中，只需要<strong>O(1)</strong>,此外Redis 的 SDS API 是安全的，不会造成缓冲区溢出。</p>
<p>下面是进入Redis中对String的简单使用，我是在阿里云的服务器上进行操作</p>
<p><strong>前置步骤</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start redis 启动Redis</span><br><span class="line">redis-cli -h 127.0.0.1 -p 6379 进入Redis</span><br></pre></td></tr></table></figure>
<p><strong>基本操作</strong></p>
<p>Redis的数据库数量是16个，进入默认是第0个，可以用<code> select index</code>切换</p>
<p><img src="/images/image-20210331185213397.png" alt="image-20210331185213397"></p>
<p>上诉是对普通字符串的基本操作，主要是<code>set、get、exists、strlen、del</code></p>
<p><strong>批量操作</strong></p>
<p>使用<code>mset 、mget</code>进行批量设置，当然<code>del</code>本身就可以批量删除</p>
<p><img src="/images/image-20210331185541332.png" alt="image-20210331185541332"></p>
<p><strong>计数加减</strong></p>
<p>在<strong>value字符串</strong>为整数时，使用<code>incr、decr</code>可以操作<code>key</code>对其进行加减</p>
<p>值得注意，可以这个操作是 <strong>原子性</strong>的，多个客户端操作一个key也不会导致竞争</p>
<p><img src="/images/image-20210331190202747.png" alt="image-20210331190202747"></p>
<p>对字符串，还有一个 <code>GETSET</code> ，它的功能跟它名字一样：为 key 设置一个值并返回原值，结合计数操作，这可以对于某一些需要隔一段时间就统计的 key 很方便的设置和查看，例如：系统每当由用户进入的时候你就是用 <code>INCR</code> 命令操作一个 key，当需要统计时候你就把这个 key 使用 <code>GETSET</code> 命令重新赋值为 0，这样就达到了统计的目的。</p>
<p><strong>过期时间设置</strong></p>
<p>使用<code>expire、setex</code>可以设置过期时间，<code>ttl</code>用来查询多久过期</p>
<p><img src="/images/image-20210331190543996.png" alt="image-20210331190543996"></p>
<p>可以对 key 设置过期时间，到时间会被自动删除，这个功能常用来<strong>控制缓存的失效时间</strong></p>
<p><strong>后置处理</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flushdb 清空当前数据库</span><br><span class="line">flushall 清空所有数据库</span><br><span class="line">dbsize 查看当前数据库大小</span><br></pre></td></tr></table></figure>


<p>一般String常用在需要计数的场景，比如用户的访问次数、热点文章的点赞转发数量等等。</p>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>C 语言并没有实现链表，所以 Redis 实现了自己的链表数据结构。Redis 的 list 的实现为一个 <strong>双向链表</strong>。Redis 的列表相当于 Java 语言中的 <strong>LinkedList</strong>，注意它是链表而不是数组。这意味着 list 的插入和删除操作非常快，时间复杂度为 O(1)，但是索引定位很慢，时间复杂度为 O(n)。</p>
<p>list可以用于发布与订阅或者说消息队列、慢查询</p>
<p><strong>基本操作</strong></p>
<ul>
<li><code>LPUSH</code> 和 <code>RPUSH</code> 分别可以向 list 的左边（头部）和右边（尾部）添加一个新元素；</li>
<li><code>LRANGE</code> 命令可以从 list 中取出一定范围的元素；</li>
<li><code>LINDEX</code> 命令可以从 list 中取出指定下表的元素，相当于 Java 链表操作中的 <code>get(int index)</code> 操作；</li>
</ul>
<p><img src="/images/image-20210331192136776.png" alt="image-20210331192136776"></p>
<p>list可以用来实现栈或者队列</p>
<p><strong>进阶操作</strong></p>
<p><code>rpoplpush</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpoplpush source  destination</span><br></pre></td></tr></table></figure>
<p>该命令原子性地返回并移除 source 列表的最后一个元素， 并把该元素放入 destination 列表的头部。使用这个命令就可以实现<strong>安全队列</strong>。</p>
<p>前面的rpop命令的特性：会移除list的队尾元素(消息)，并将这个元素(消息)返回给客户端。这意味着该元素就只存在于客户端的上下文中，redis服务器中没有这个元素了，如果客户端在处理这个返回元素的过程崩溃了，那么这个元素就永远丢失了。这种情况导致：客户端虽然成功收到了消息，但是却没有处理它。是不安全的</p>
<p>因为使用 RPOPLPUSH 获取消息时，RPOPLPUSH 会把消息返给客户端，同时把该消息放入一个备份消息列表，并且这个过程是原子的，可以保证消息的安全。当客户端成功的处理了消息后，就可以把此消息从备份列表中移除了。如果客户端因为崩溃的原因没有处理某个消息，那么就可以从备份列表destination中重新获取并处理这个消息。</p>
<h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a><strong>hash</strong></h3><p>ash 类似于 JDK1.8 前的 HashMap，内部实现也差不多(数组 + 链表)。不过，Redis 的 hash 做了更多优化。另外，hash 是一个 string 类型的 field 和 value 的映射表，<strong>特别适合用于存储对象</strong>，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。 比如我们可以 hash 数据结构来存储用户信息，商品信息等等。</p>
<p><strong>基本操作</strong></p>
<p><code>hset,hmset,hexists,hget,hgetall,hkeys,hvals</code> </p>
<p>下面是一个基本操作过程</p>
<p><img src="/images/image-20210331195518979.png" alt="image-20210331195518979"></p>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>set 类似于 Java 中的 <code>HashSet</code> 。Redis 中的 set 类型是一种无序集合，集合中的元素没有先后顺序。当你需要存储一个列表数据，又不希望出现重复数据时，set 是一个很好的选择，并且 set 提供了判断某个成员是否在一个 set 集合内的重要接口，这个也是 list 所不能提供的。</p>
<p>可以基于 set 轻易实现交集、并集、差集的操作。比如：你可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis 可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程。</p>
<p><strong>基本操作</strong></p>
<p> <code>sadd,spop,</code>添加删除</p>
<p><code>smembers</code>查看所有set中元素</p>
<p><code>sismember</code>检查是否包含</p>
<p><code>scard</code>长度</p>
<p><code>sinterstore</code>求交集，注意是三个参数，求后两者交集放在第一个集合中</p>
<p><code>sunion</code> 求并集</p>
<h3 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h3><p>有序列表</p>
<p>和 set 相比，sorted set 增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列，还可以通过 score 的范围来获取元素的列表。有点像是 Java 中 HashMap 和 TreeSet 的结合体。</p>
<p>有序列表可以用于需要对数据根据某个权重进行排序的场景。比如在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息。</p>
<p><strong>常见操作</strong></p>
<p><code>zadd,zcard,zscore,zrange,zrevrange,zrem</code> 等。</p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p><code>multi</code></p>
<p><code>exec</code></p>
<p><code>discard</code></p>
<h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p><code>watch</code></p>
<p>详见该分类下的<code>Redis-锁相关</code>文章</p>
<h1 id="Java操纵Redis"><a href="#Java操纵Redis" class="headerlink" title="Java操纵Redis"></a>Java操纵Redis</h1><p>同对MySQL进行增删查改需要进行连接一样，在Java中使用Redis也要导入驱动，使用时进行连接</p>
<h2 id="1、利用Jedis"><a href="#1、利用Jedis" class="headerlink" title="1、利用Jedis"></a>1、利用Jedis</h2><p>在pom文件中导入Jedis依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用时同JDBC类似，建立连接即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisJava</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//连接本地的 Redis 服务</span></span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        <span class="comment">// 如果 Redis 服务设置来密码，需要下面这行，没有就不需要</span></span><br><span class="line">        <span class="comment">// jedis.auth(&quot;123456&quot;); </span></span><br><span class="line">        System.out.println(<span class="string">&quot;连接成功&quot;</span>);</span><br><span class="line">        <span class="comment">//查看服务是否运行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;服务正在运行: &quot;</span>+jedis.ping());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其使用的语法基本同Redis客户端在操作一致</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisListJava</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//连接本地的 Redis 服务</span></span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;连接成功&quot;</span>);</span><br><span class="line">        <span class="comment">//存储数据到列表中</span></span><br><span class="line">        jedis.lpush(<span class="string">&quot;site-list&quot;</span>, <span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">        jedis.lpush(<span class="string">&quot;site-list&quot;</span>, <span class="string">&quot;Google&quot;</span>);</span><br><span class="line">        jedis.lpush(<span class="string">&quot;site-list&quot;</span>, <span class="string">&quot;Taobao&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取存储的数据并输出</span></span><br><span class="line">        List&lt;String&gt; list = jedis.lrange(<span class="string">&quot;site-list&quot;</span>, <span class="number">0</span> ,<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;list.size(); i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;列表项为: &quot;</span>+list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-在Spring-Boot-中集成"><a href="#2-在Spring-Boot-中集成" class="headerlink" title="2.在Spring Boot 中集成"></a>2.在Spring Boot 中集成</h2><p>在Spring Boot中集成也需要导入相关依赖包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>主要</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Seckill 1.登陆验证功能</title>
    <url>/2021/03/26/Seckill-1-%E7%99%BB%E9%99%86%E9%AA%8C%E8%AF%81%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<p>秒杀系统第一步，创建搭建环境和编写第一个demo，增加登陆验证功能</p>
<p>这里我主要学习后端，前段的界面是在<code>github</code>的仓库找的，会在末尾添上链接</p>
<a id="more"></a>

<h1 id="一、环境搭建"><a href="#一、环境搭建" class="headerlink" title="一、环境搭建"></a>一、环境搭建</h1><p>基础环境</p>
<ul>
<li>IDEA 2021</li>
<li>Spring Boot 2.4.4</li>
<li>thymeleaf</li>
<li>Mysql 8.0.23</li>
<li>MyBatis  2.1.4</li>
<li>jdk 1.8</li>
<li>maven 3.6.3</li>
</ul>
<h2 id="1-数据库搭建"><a href="#1-数据库搭建" class="headerlink" title="1.数据库搭建"></a>1.数据库搭建</h2><p>登陆功能涉及到用户类，在mysql数据库中新建一个seckil数据库，并且新建一个User表</p>
<p>下图是我建表包含的具体列</p>
<p><img src="/images/image-20210329200837037.png" alt="image-20210329200837037"></p>
<h2 id="2-新建Spring-Boot-项目"><a href="#2-新建Spring-Boot-项目" class="headerlink" title="2.新建Spring Boot 项目"></a>2.新建Spring Boot 项目</h2><ul>
<li><p><strong>利用Spring Initializer 搭建项目</strong></p>
<p>新建一个<code>Spring Initializer</code>项目，导入依赖时导入<code>Spring web</code>、<code>Thymeleaf</code>、<code>mysql driver</code>、<code>MyBatis</code>等依赖</p>
</li>
<li><p><strong>pom.xml文件中再导入MD5相关的jar包</strong></p>
<p>登陆功能涉及到两次MD5加密，先导入相关依赖包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-codec<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-codec<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>对web应用进行基础配置</strong></p>
<p>在resource文件下对application文件进行配置，这里我把原来的文件删除了，而是新建了<code>application.yml</code>进行配置，比较清晰</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">thymeleaf:</span></span><br><span class="line">    <span class="attr">cache:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/seckill?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=GMT%2B8</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">hikari:</span></span><br><span class="line">      <span class="attr">pool-name:</span> <span class="string">DateHikar</span></span><br><span class="line">      <span class="attr">minimum-idle:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">idle-timeout:</span> <span class="number">1800000</span></span><br><span class="line">      <span class="attr">maximum-pool-size:</span> <span class="number">9</span></span><br><span class="line">      <span class="attr">auto-commit:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">max-lifetime:</span> <span class="number">1800000</span></span><br><span class="line">      <span class="attr">connection-timeout:</span> <span class="number">30000</span></span><br><span class="line">      <span class="attr">connection-test-query:</span> <span class="string">SELECT</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mapper/*Mapper.xml</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.zhu.seckill.pojo</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">map-underscore-to-camel-case:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">com.zhu.seckill.mapper:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure>
<p>里面包含了对数据库、MyBatis、thymeleaf等配置</p>
</li>
<li><p><strong>建立完整目录结构</strong></p>
<p>下面是我的目录结构，后面可能会有补充，大概了解一些每个类应处的层次</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">├── pom.xml  -- 项目依赖</span><br><span class="line">└── src</span><br><span class="line">    ├── main</span><br><span class="line">    │   ├── java</span><br><span class="line">    │   │   └── com.zhu.seckill</span><br><span class="line">    │   │       </span><br><span class="line">    │   │           ├── SeckillApplication.java  -- SpringBoot启动器</span><br><span class="line">    │   │           ├── controller  -- 控制层，MVC中的处理器</span><br><span class="line">    │   │           ├── dto  -- 统一封装的一些结果属性，和pojo类似</span><br><span class="line">    │   │           ├── pojo  -- 普通Java类，存放数据库对应实体</span><br><span class="line">    │   │           ├──  vo  -- 与视图层传输数据的实体</span><br><span class="line">    │   │           ├── exception  -- 统一的异常结果</span><br><span class="line">    │   │           ├── mapper  -- Mybatis-Mapper层映射接口，即DAO层</span><br><span class="line">    │   │           ├── utils  -- 一些工具类的编写</span><br><span class="line">    │   │           └── service  -- 业务层</span><br><span class="line">    │   └── resources</span><br><span class="line">    │       ├── application.yml  -- SpringBoot核心配置文件</span><br><span class="line">    │       ├── mapper  -- Mybatis-Mapper层XML映射文件</span><br><span class="line">    │       ├── static  -- 存放页面静态资源，可通过浏览器直接访问</span><br><span class="line">    │       │   ├── css</span><br><span class="line">    │       │   ├── js</span><br><span class="line">    │       │   └── lib</span><br><span class="line">    │       └── templates  -- 存放Thymeleaf模板引擎所需的HTML，不能在浏览器直接访问</span><br><span class="line">    └── test  -- 测试文件</span><br></pre></td></tr></table></figure>
<p>到此一个基本的Spring Boot 项目基本搭建完成，下面是具体业务的编写</p>
</li>
</ul>
<h1 id="二、基本原理"><a href="#二、基本原理" class="headerlink" title="二、基本原理"></a>二、基本原理</h1><p>这里我们主要设计的是登陆验证功能，其原理主要使用了常见的MD5</p>
<p>MD5是一种数据摘要算法，可以用于数据的加密，文件快传，文件校验，数据压缩等方面，其用哈希函数把任意长度的报文信息转换为固定长度的哈希，其特点是: </p>
<ul>
<li>经过MD5转化后的数据，是不能被破解的，无法得到原有的明文内容</li>
<li>经过加密的数据，都是128位2进制数据组成。通常会把它书写成32位16进制数据</li>
<li>同一份数据经过md5加密之后，一定会得到同一个结果</li>
</ul>
<p>注意前面说的破解是通过算法倒推出原文，但是存在人可以用暴露枚举的方式用一个字典挨个生成MD5加密后的密文，再用输入的密文反查询</p>
<p>首先，当前端明文密码传到服务器时，需要<strong>一次MD5加密</strong>，这里主要是<strong>避免明文密码被抓包获取</strong>。</p>
<p>如果这里就将该密文存储在数据库，这里有一个问题,攻击成本问题，如果被人有了整个数据库的密文，只要代价足够，其可以通过构建彩虹表即前文说的暴露枚举破解密文得到明文密码，因为他建立彩虹表是针对所以用户的</p>
<p>这里解决方案是<strong>加盐</strong>，可以给每一个用户的密文插入随机值的字符串，再次进行MD5加密，每个用户都有不同的盐（字符串），别人的攻击成本就会上升，其再想建立彩虹表，也只是针对一个用户的，破解代价很大</p>
<p>所以最后，当服务器加密码保存到数据库中是时，需要<strong>第二次MD5+随机盐值加密</strong>，这时是为了<strong>增加彩虹表反查的难度</strong></p>
<p>当然第一次MD5加密也可以加盐值，但是必须是固定的，因为MD5不能破解，那就不能每次传递过来的密码不一致</p>
<h1 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h1><ul>
<li><p><strong>MD5加密的工具类编写</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhu.seckill.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.codec.digest.DigestUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MD5Utils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 固定salt值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String salt = <span class="string">&quot;2z5b864m&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单纯获取MD5值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getMD5</span><span class="params">(String src)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DigestUtils.md5Hex(src);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一次加密的MD5值，实际是在前端做的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">inputPassToFormPass</span><span class="params">(String inputPass)</span></span>&#123;</span><br><span class="line">        String base =<span class="string">&quot;&quot;</span> + salt.charAt(<span class="number">3</span>)+salt.charAt(<span class="number">6</span>)+inputPass+salt.charAt(<span class="number">0</span>)+salt.charAt(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">return</span> DigestUtils.md5Hex(base);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二次加密的MD5值,这里的salt应该是每个用户随机生成的一个，这也是真正验证和写入数据库时调用的主要方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">formPassToDBPass</span><span class="params">(String formPass,String salt)</span></span>&#123;</span><br><span class="line">        String base = <span class="string">&quot;&quot;</span>+ salt.charAt(<span class="number">3</span>)+salt.charAt(<span class="number">6</span>)+formPass+salt.charAt(<span class="number">0</span>)+salt.charAt(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">return</span> DigestUtils.md5Hex(base);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  String <span class="title">inputPassToDBPass</span><span class="params">(String inputPass,String databasesalt)</span></span>&#123;</span><br><span class="line">        String formpass = inputPassToFormPass(inputPass);</span><br><span class="line">        <span class="keyword">return</span> formPassToDBPass(formpass,databasesalt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>验证逻辑</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RespBean <span class="title">doLogin</span><span class="params">(LoginVO loginVO)</span> </span>&#123;</span><br><span class="line">    String mobile = loginVO.getMobile();</span><br><span class="line">    String password = loginVO.getPassword();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>(mobile == <span class="keyword">null</span> || password == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> RespBean.error(RespBeanEnum.LOGIN_ERROR);</span><br><span class="line">    <span class="keyword">if</span>(!VoliationUtils.isMoblie(mobile))</span><br><span class="line">        <span class="keyword">return</span> RespBean.error(RespBeanEnum.MOBILE_ERROR);</span><br><span class="line">    <span class="comment">// 查询数据库存储的密文和盐值</span></span><br><span class="line">    User user = userMapper.getUserById(Long.valueOf(mobile));</span><br><span class="line">    <span class="keyword">if</span>(user == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> RespBean.error(RespBeanEnum.SIGNIN_ERROR);</span><br><span class="line">    <span class="comment">// 将第一次密文转化成第二次密文后比较</span></span><br><span class="line">    <span class="keyword">if</span>(!Objects.equals(MD5Utils.formPassToDBPass(password,user.getSalt()),user.getPsd()))</span><br><span class="line">        <span class="keyword">return</span> RespBean.error(RespBeanEnum.PSSSWARD_ERROR);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> RespBean.success(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>查询逻辑</strong></p>
<p>验证逻辑中需要查询用户数据，下面是查询的sql语句,主要在UserMapper中实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;select * from seckill.user where id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function">User <span class="title">getUserById</span><span class="params">(<span class="keyword">long</span> id)</span></span>;</span><br><span class="line">    <span class="meta">@Insert(&quot;insert  into user(id,nickname,psd,salt) values(#&#123;id&#125;,#&#123;name&#125;,#&#123;psd&#125;,#&#123;salt&#125;)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span>  <span class="title">InsertUser</span><span class="params">(Long id ,String name,String psd,String salt)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h1 id="四、前端的一些东西的连接"><a href="#四、前端的一些东西的连接" class="headerlink" title="四、前端的一些东西的连接"></a>四、前端的一些东西的连接</h1><p><a href="https://github.com/hfbin/Seckill">hfbin的github仓库</a></p>
<p>我前端的页面和资源如要参照这个大佬的仓库，再自己对其中一些接口进行了修改</p>
<p>代项目完毕后，也可以看我的仓库</p>
]]></content>
      <categories>
        <category>项目</category>
        <category>秒杀系统</category>
      </categories>
      <tags>
        <tag>Seckill</tag>
      </tags>
  </entry>
  <entry>
    <title>Seckill 2.单机秒杀实现</title>
    <url>/2021/04/09/Seckill-2-%E5%8D%95%E6%9C%BA%E7%A7%92%E6%9D%80%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>秒杀系统实现第二步，用户登录后可以考虑秒杀功能的实现，这里首先思考如何在单机上实现</p>
<a id="more"></a>

<h1 id="一、思路递进过程"><a href="#一、思路递进过程" class="headerlink" title="一、思路递进过程"></a>一、思路递进过程</h1><h1 id="二、核心代码"><a href="#二、核心代码" class="headerlink" title="二、核心代码"></a>二、核心代码</h1>]]></content>
      <categories>
        <category>项目</category>
        <category>秒杀系统</category>
      </categories>
      <tags>
        <tag>Seckill</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis-锁相关</title>
    <url>/2021/04/13/Redis-%E9%94%81%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<p>了解一些Redis常见的锁实现以及应用场景</p>
<a id="more"></a>

<h1 id="一、乐观锁"><a href="#一、乐观锁" class="headerlink" title="一、乐观锁"></a>一、乐观锁</h1><p>Redis的乐观锁主要基于<code>watch</code>和<code>事务</code>实现</p>
<p>其中<code>watch</code>可以用来检测一个key或多个key是否被修改，如果被修改执行的事务将会被打断，即大概是如下一个工作流程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">watch key</span><br><span class="line">multi</span><br><span class="line">	对key进行一系列非原子的操作</span><br><span class="line">exec</span><br></pre></td></tr></table></figure>
<p>下面是Redis集成在Spring Boot中的一个乐观锁实例，主要功能1是实现对Redis中商品名称为key的库存的扣减</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">updateCacheByWatch</span><span class="params">(String key)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    String count = (String) get(key);</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">null</span> == count || count == <span class="string">&quot;0&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span> ; i++)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        redisTemplate.watch(key);</span><br><span class="line"></span><br><span class="line">        redisTemplate.multi();</span><br><span class="line">        String oldvalue = (String) get(key);</span><br><span class="line">        <span class="keyword">if</span>(oldvalue != <span class="keyword">null</span> &amp;&amp; Integer.valueOf(oldvalue) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(oldvalue);</span><br><span class="line">            redisTemplate.opsForValue().decrement(key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Object&gt; exec = redisTemplate.exec();</span><br><span class="line">        <span class="keyword">if</span>(!exec.isEmpty())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//出现异常撤销</span></span><br><span class="line">        redisTemplate.discard();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        redisTemplate.unwatch();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里当修改失败时会再尝试重复五次，每次间隔100ms</p>
<h1 id="二、分布式锁（悲观锁）"><a href="#二、分布式锁（悲观锁）" class="headerlink" title="二、分布式锁（悲观锁）"></a>二、分布式锁（悲观锁）</h1><p>乐观锁是基于watch的重试机制，其只会在数据被其他客户端抢先修改了的情况下通知执行了这个命令的客户端，而不能阻止其他客户端对数据进行修改</p>
<p>而当使用了Redis实现悲观锁锁后又有一个显而易见的好处，在多机环境中Redis的范围是对所有服务器可见的，Redis的悲观锁是分布式的悲观锁，可以很好的适用于分布式系统，这时基于JVM的锁只能作用于本机，将不再适用。</p>
<p><img src="/images/image-20210413161557941.png" alt="image-20210413161557941"></p>
<p>实现分布式锁主要有主要几个要求</p>
<ul>
<li>排他性，只有一个进程可以获取锁</li>
<li>安全性，防止一个锁的持有者挂了锁无法释放</li>
<li>一致性，解锁和释放锁锁的是一个人</li>
</ul>
<p>基于上述要求，自己用Redis实现分布式锁的时候主要考虑用<code>setnx</code>、<code>setex</code>结合的原子指令实现加锁操作，并且设置过期时间防止锁一直无法释放。并且每个进程加锁时设置一个唯一标识token，防止解锁时锁被其他进程释放</p>
<p>大概逻辑如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">trylock:</span><br><span class="line">setnx key:lockname value:token timeout</span><br><span class="line"></span><br><span class="line">unlock:</span><br><span class="line">检查进程传入token和lockname对应value是否一致,一致则解锁</span><br><span class="line">(由于上诉操作不是原子的，要么使用watch监控，要么使用lua实现原子操作，防止并发条件下释放了其他进程的锁)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下面是我的逻辑的具体实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span>  DefaultRedisScript&lt;Long&gt; defaultRedisScript = <span class="keyword">new</span> DefaultRedisScript&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        defaultRedisScript.setResultType(Long.class);</span><br><span class="line">        defaultRedisScript.setScriptText(<span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == KEYS[2] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(String lockName,String value,<span class="keyword">long</span> tryTime)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Long beginTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(beginTime + tryTime  &gt;= System.currentTimeMillis())&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">true</span> == redisTemplate.opsForValue().setIfAbsent(lockName,value,<span class="number">30</span>,TimeUnit.SECONDS))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">unlock</span><span class="params">(String lockName,String value)</span></span>&#123;</span><br><span class="line">        Long result = redisTemplate.execute(defaultRedisScript, Arrays.asList(lockName, value));</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(<span class="number">1L</span>,result);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>以上实现在 Redis 正常运行情况下是没问题的，但如果存储锁对应key的那个节点挂了的话，就可能存在丢失锁的风险，导致出现多个客户端持有锁的情况，这样就不能实现资源的独享了，只是由于Redis的主从同步结构是异步的。</p>
<h1 id="三、RedissonLock"><a href="#三、RedissonLock" class="headerlink" title="三、RedissonLock"></a>三、RedissonLock</h1><p>Redisson中的RedissonLock是实现好了的Redis锁</p>
<p>相较于我自己实现的分布式锁，其主要增加了以下功能</p>
<ul>
<li>可重入：增加一个数据记录锁的进入次数，实现可重入功能</li>
<li>看门狗机制：Redisson内部提供了一个监控锁的看门狗，它的作用是在Redisson实例被关闭前，不断的延长锁的有效期</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基本类型和包装类型的坑</title>
    <url>/2021/04/14/Java%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<p>了解一下Java基本类型和包装类和一些常见的坑</p>
<a id="more"></a>

<h1 id="一、基本类型和包装类"><a href="#一、基本类型和包装类" class="headerlink" title="一、基本类型和包装类"></a>一、基本类型和包装类</h1><h2 id="1-基础"><a href="#1-基础" class="headerlink" title="1.基础"></a>1.<strong>基础</strong></h2><p>Java基本类型有<code>boolean、byte、short、char、int、long、float、double</code>八大类，对应也有包装类型<code>Boolean,Byte,Short,Character,Integer,Long,Float,Double</code></p>
<p>Java一切皆对象，但是八大基本类型不是对象，包装类的产生解决基本数据类型没有属性，方法，不能对象化交互的问题，但是也带来了性能消耗</p>
<p>基本类型和包装类型主要有以下区别：</p>
<ul>
<li><strong>包装类型是对象，可以为空</strong></li>
<li><strong>两者在JVM上内存分配位置不一致</strong></li>
<li><strong>两者通常判断值是否相等的方式不一致</strong>，一个用<code>==</code>，另一个最好用<code>equals</code></li>
<li><strong>包装类可以用于泛型，而基本类型不能</strong></li>
</ul>
<p>在上诉差异，最好利用包装类型的特性，仅在需要的时候使用包装类型，包装类型主要有以下应用场景</p>
<ul>
<li><strong>泛型或者泛型参数</strong></li>
<li><strong>POJO类属性必须使用包装数据类型</strong>，主要为了防止<strong>NPE</strong></li>
<li><strong>RPC 方法的返回值和参数必须使用包装数据类型</strong>，包装类返回的null能有额外信息</li>
</ul>
<h2 id="2-自动装箱拆箱过程"><a href="#2-自动装箱拆箱过程" class="headerlink" title="2.自动装箱拆箱过程"></a><strong>2.自动装箱拆箱过程</strong></h2><p>Java为了优化基本类型和包装类型转化，有自动装箱和拆箱机制，<strong>自动装箱时编译器调用valueOf将原始类型值转换成对象，同时自动拆箱时，编译器通过调用类似intValue(),doubleValue()这类的方法将对象转换成原始类型值。</strong>而这些调用都不用我们显式调用</p>
<p>下面以Integer为例看着两个方法</p>
<p>装箱时</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">           <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>拆箱时</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">intValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h2 id="3-缓存机制"><a href="#3-缓存机制" class="headerlink" title="3.缓存机制"></a>3.缓存机制</h2><p>注意到前面<code>Integer</code>的<code>valueOf</code>中，对int的值有条件判断，在一定范围内，返回的是<code>IntegerCache.cache[i + (-IntegerCache.low)];</code>,否则才会新建一个对象</p>
<p>再查看<code>IntegerCache</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">static</span> &#123;</span><br><span class="line">          <span class="comment">// high value may be configured by property</span></span><br><span class="line">          <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">          String integerCacheHighPropValue =</span><br><span class="line">              sun.misc.VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                  i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                  <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                  h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">              &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                  <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          high = h;</span><br><span class="line"></span><br><span class="line">          cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">          <span class="keyword">int</span> j = low;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">              cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">          <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><strong>IntegerCache内部实现了一个Integer的静态常量数组，在类加载的时候，执行static静态代码块进行初始化-128到127之间的Integer对象.</strong></p>
<p><strong>如果缓存的这些对象都是经常使用到的，使用缓存防止每次自动装箱都创建一次对象的实例。</strong></p>
<p><strong>除了Float和Double，其他包装类都有缓存机制</strong></p>
<h1 id="二、踩坑集合"><a href="#二、踩坑集合" class="headerlink" title="二、踩坑集合"></a>二、踩坑集合</h1><h2 id="1-泛型和泛型参数相关"><a href="#1-泛型和泛型参数相关" class="headerlink" title="1.泛型和泛型参数相关"></a>1.泛型和泛型参数相关</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// error</span></span><br><span class="line"><span class="keyword">int</span>[] arr =  &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>&#125;;</span><br><span class="line">Arrays.sort(arr,( a, b)-&gt;&#123; <span class="keyword">return</span>  b - a;&#125;);</span><br></pre></td></tr></table></figure>
<p>该方法接口如下</p>
<p><code>public static &lt;T&gt; void sort(T[] a, Comparator&lt;? super T&gt; c)</code></p>
<p>在使用泛型参数的时候使用了基本类型，错误</p>
<h2 id="2-缓存机制相关"><a href="#2-缓存机制相关" class="headerlink" title="2.缓存机制相关"></a>2.缓存机制相关</h2><p>所有的相同类型的包装类对象之间值的比较，全部使用 equals 方法比较,不然可能会因为缓存机制带来出乎意料的结果。包装类重写了equals方法，都是值比较，甚至，Java的值类型的equals方法都是值比较</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Integer) &#123;</span><br><span class="line">          <span class="keyword">return</span> value == ((Integer)obj).intValue();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>此外最好使用Objects的比较方法，避免<code>a.equals(b)</code>中a为空</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object a, Object b)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> (a == b) || (a != <span class="keyword">null</span> &amp;&amp; a.equals(b));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java语法</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Java语法</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础操作</title>
    <url>/2021/04/14/Java%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>了解一些Java的常见操作符和程序流程控制手段</p>
<a id="more"></a>

<h1 id="一、操作符"><a href="#一、操作符" class="headerlink" title="一、操作符"></a>一、操作符</h1><p>前言，Java建立于C++基础之上的，大多操作符与其一致，这里主要讲解一些不常用的操作符</p>
<h2 id="算术操作符"><a href="#算术操作符" class="headerlink" title="算术操作符"></a>算术操作符</h2><p>有<code>+</code>,<code>-</code>,<code>/</code>,<code>*</code>,<code>%</code>等，注意这些操作符除<code>+</code>外只能作用于<strong>基本类型</strong></p>
<p><code>+</code>还可以用于<strong>String</strong>拼接</p>
<p>注意<code>-</code>和<code>+</code>可以用作一元操作符，前者改变符号，后者可能将较小类型的操作数<strong>提升为int</strong>。</p>
<h2 id="按位和移位操作符"><a href="#按位和移位操作符" class="headerlink" title="按位和移位操作符"></a>按位和移位操作符</h2><p><strong>按位</strong></p>
<p>常见的有</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&amp; 与</span><br><span class="line">| 或</span><br><span class="line">^ 异或</span><br><span class="line">~ (一元操作符)</span><br></pre></td></tr></table></figure>
<p>有一个趣味小问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a^b &#x3D; (a|b)&amp;(~(a&amp;b))</span><br></pre></td></tr></table></figure>
<p><strong>移位</strong></p>
<p><code>&lt;&lt;</code>左移，低补零</p>
<p><code>&gt;&gt;</code>有符号右移，高位最后插入符号位</p>
<p><code>&gt;&gt;&gt;</code>无符号右移，高位最后插入0</p>
<h2 id="类型转化操作符"><a href="#类型转化操作符" class="headerlink" title="类型转化操作符"></a>类型转化操作符</h2><p><code>(cast)</code></p>
<p>注意窄化转换可能面临信息丢失的危险，必须需要强制类型转化，对于扩展转化，不必显式进行转化</p>
<p>注意：<strong>类型比int小的基本数据类型进行算术运算时，运算前会自动转换成int</strong></p>
<h1 id="二、控制执行流程"><a href="#二、控制执行流程" class="headerlink" title="二、控制执行流程"></a>二、控制执行流程</h1><p>常见控制流程主要有</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if - else</span><br><span class="line">while</span><br><span class="line">do - while 至少执行一次</span><br><span class="line">for</span><br><span class="line">foreach语法</span><br><span class="line">switch</span><br></pre></td></tr></table></figure>
<p><strong>流程控制</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">return 可以直接退出方法</span><br><span class="line">break 退出循环</span><br><span class="line">continue 停止执行当前迭代，到下一次迭代</span><br></pre></td></tr></table></figure>
<p>Java可以使用<strong>标签实现goto跳转</strong>，格式为<code>name:</code></p>
<p>Java的标签唯一作用的地方是循环语句之前，break等只能跳出一层循环，利用标签可以达到跳出多重循环的效果</p>
<p><strong>switch</strong></p>
<p>switch是一种选择语句，值得注意的是，Java7之前其只能接受选择因子是<strong>int或char</strong>，之后加入了<strong>String</strong>，当然可以利用枚举摆脱这个限制。</p>
]]></content>
      <categories>
        <category>Java语法</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Java语法</tag>
      </tags>
  </entry>
  <entry>
    <title>Java对象通用方法</title>
    <url>/2021/04/16/Java%E5%AF%B9%E8%B1%A1%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>清除Java通用方法的作用、重写及编程规范</p>
<a id="more"></a>

<p>Java所有的对象都有一个超类Object，其有以下通用方法</p>
<p><img src="/images/image-20210416152247341.png" alt="image-20210416152247341"></p>
<p>后面的方法几个方法是final的，也是本地的，不能被重写</p>
<p>前面所有的非final方法<code>（equals,hashCode,toString,clone）</code>都有一些通用约定，当覆盖这些方法时，需要遵循这些约定。</p>
<h1 id="一、equals方法"><a href="#一、equals方法" class="headerlink" title="一、equals方法"></a>一、equals方法</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>显然超类中的equals方法是判断<strong>引用是否相当</strong>，如果我们需要编写自己的相等逻辑，比如是值相等，我们就需要重写<code>equals</code>方法</p>
<p>重写equals方法时需要注意下面几个规范</p>
<ul>
<li><p>自反性：<code>x.equals(x) == true</code></p>
</li>
<li><p>对称性：<code>x.equals(y) == y.equals(x)</code></p>
</li>
<li><p>传递性：<code>x.equals(y) == true; y.equals(z) == true; 则x.equals(z) == true</code></p>
</li>
<li><p>一致性：x，y指向对象未修改，则多次比较结果不变</p>
</li>
<li><p><code>x.equals(null)</code>必须返回false</p>
</li>
</ul>
<p>一般编码过程中需要注意<strong>对称性和传递性</strong>，这两个规定容易被违反，一般主要出现在子类和父类之间</p>
<p>在这之前，首先得清楚两个方法</p>
<ul>
<li><p><strong>getClass：</strong>getClass得到该类的实际类型，即<strong>运行时类型</strong></p>
</li>
<li><p><strong>instanceof：</strong>判断该类是否属于<strong>该类或者该类派生类</strong></p>
</li>
</ul>
<p>我们在重写equals方法中，首先就得判断两个对象是否可以比较，这时可以选择上诉两种方法来判断两个类是否属于同一类型，针对两种方法也有两种重写equals的手段</p>
<p><strong>1.利用getClass</strong></p>
<p>显然，使用了<code>b.getClass() == xxx</code>,既是严格判断是否一致，可以保证对称性和传递性</p>
<p>这里有一个问题，有人认为这样违反了<strong>里氏替换原则（子类对象必须能够替换掉所有父类对象）</strong>，比如HashSet和TreeSet，你可能希望比较两个任意的集合</p>
<p><strong>2.利用instanceof</strong></p>
<p>如果利用instanceof就可以规避这个问题，这时由于instanceof关键字的作用决定的，子类、父类、甚至不同子类之间可以比较，体现了LSP原则</p>
<p>这里又有另外一个问题，如果子类增加了<strong>值组件</strong>，子类想有自己的比较方法，又会带来<strong>传递性或者一致性</strong>的问题</p>
<p>比如子类重写equals没有考虑父类违反传递性、考虑了父类减少值组件比较又会违反传递性</p>
<p><strong>决策</strong></p>
<p>由上诉两个，即<strong>在扩展可实例化的类的同时，不能即增加新的值组件，又同时保留equals约定，除非放弃抽象优势</strong></p>
<ul>
<li>如果子类有自己的相对性概念，强制用getClass比较</li>
<li>如果超类决定相对性概念，可以使用instanceof检测，这样可以在不同子类的对象之间进行相等性比较，这时最好将比较方法定为final</li>
</ul>
<p>最后有一个重写equals的高效的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 性能优化，比较昂贵时很有用</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> == obj)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 检查正确参数类型，这里也可以用getClass</span></span><br><span class="line">		<span class="keyword">if</span>(!(obj <span class="keyword">instanceof</span> 正确参数类型))</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		<span class="comment">// 类型转换</span></span><br><span class="line">        正确类型 other = (正确类型) obj;</span><br><span class="line">		<span class="comment">// 比较操作</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 返回比较结果，一般最可能不一致的域先比较</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h1 id="二、重写equals需覆盖hashCode方法"><a href="#二、重写equals需覆盖hashCode方法" class="headerlink" title="二、重写equals需覆盖hashCode方法"></a>二、重写equals需覆盖hashCode方法</h1><p>如标题，当你重写了equals方法就需要覆hashCode方法，主要因为在Set或者Map判断元素是否存在首先是利用<code>hashCode</code>方法</p>
<p>hashCode方法方法也有一些通用约定，这是其在基于散列的集合中正常运行的基础：</p>
<ul>
<li>一致性：一个对象equals用到的比较信息没有修改，则多次调用hashCode方法返回值一致</li>
<li><strong>如果两个对象根据equals方法比较相等，调用hashCode方法必须产生相同的整数结果</strong></li>
<li>如果两个对象根据equals方法比较不相等，对hashCode结果不要求，但是，<strong>不同对象不同结果有助于提高散列表性能</strong></li>
</ul>
<p>如何重写一个合适的hashCode函数</p>
<p>对于不同关键域的散列码int c：</p>
<ul>
<li>基本类型：Type.hashCode(f)，可以减少对象的创建</li>
<li>对象引用：为这个域递归调用hashCode方法得到c，null返回0</li>
<li>数组：每个元素就是一个域对只对重要元素处理，或者是Array.hashCode方法对所有元素处理</li>
</ul>
<p>确定好每个域c之后，可以得到hashCode标准流程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">result &#x3D; c1;</span><br><span class="line">迭代，对每个域有result &#x3D; 31*result + c;</span><br><span class="line">返回result</span><br></pre></td></tr></table></figure>
<p>其中关键域应该仅仅是equals中的比较信息</p>
<h1 id="三、toString方法"><a href="#三、toString方法" class="headerlink" title="三、toString方法"></a>三、toString方法</h1><p>始终要覆盖toString方法，因为好的toString方法可以便于使用和调试。</p>
<p>好的toString方法一般应该返回对象中包含的所有值得关注的信息</p>
<p>需要决定返回值是否要指定格式，无论指定与否需要在文档中明确的表明自己的意图</p>
<p>Java的开发手册也有一条提到<strong>POJO 类必须写 toString 方法</strong>。在方法执行抛出异常时，可以直接调用 POJO 的 toString()方法打印其属性值，便于排查问题。</p>
<h1 id="四、clone方法"><a href="#四、clone方法" class="headerlink" title="四、clone方法"></a>四、clone方法</h1><p>一般要覆盖超类中的clone方法需要实现Cloneable接口，不然就会出现CloneNotSupportException。但是Cloneable中并没有clone方法，只是一个标记，标记这个对象可以克隆。</p>
<p>实现Cloneable接口后，重写clone方法时，就可以利用super.clone()实现对对象的浅拷贝，而这个<strong>浅拷贝实际是Object.clone() 实现的</strong>，Object.clone()有特殊的语义，它就是能把当前对象的整个结构完全浅拷贝一份出来：可以把JVM原生实现的 Object.clone() 的语义想像为拿到 this 引用之后通过反射去找到该对象实例的所有字段，然后逐一字段拷贝，这个过程没有调用构造器</p>
<p>根据上诉原理：<strong>一般需要谨慎的覆盖clone</strong>，主要原因有几点：</p>
<ul>
<li>浅拷贝和深拷贝的的问题：当对象内部域含可变域时，clone会比较复杂</li>
<li>Cloneable接口没有clone方法，只是一个标记，也无法执行多态clone操作</li>
<li>cloneable框架和可变对象的final域不兼容</li>
</ul>
<p>一般只是</p>
]]></content>
      <categories>
        <category>Java语法</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Java语法</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx</title>
    <url>/2021/04/21/Nginx/</url>
    <content><![CDATA[<p>了解Nginx的安装、使用、以及一些常用功能</p>
<a id="more"></a>

<h1 id="一、Nginx安装"><a href="#一、Nginx安装" class="headerlink" title="一、Nginx安装"></a>一、Nginx安装</h1><p>Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。</p>
<p>其主要功能是<strong>反向代理、负载均衡</strong></p>
<p>特点是占有内存少，并发能力强，并且配置也比较简单</p>
<p>下面是其在window环境下的安装：</p>
<ul>
<li><p><strong>1.下载安装包</strong></p>
<p>Nginx安装通过解压zip压缩包到指定目录即可</p>
<p> <a href="http://nginx.org/en/download.html">下载地址</a></p>
</li>
<li><p><strong>2.启动</strong></p>
<p>可以点击压缩文件下的exe程序直接打开</p>
<p>也可以打开cmd命令窗口，切换到nginx解压目录下，输入命令 <code>start nginx</code> ，回车即可</p>
<p>最后点击<a href="http://localhost/">http://localhost:80</a>   </p>
<p>出现如下界面即成功</p>
<p><img src="/images/image-20210506155920084.png" alt="image-20210506155920084"></p>
</li>
<li><p><strong>3.关闭</strong></p>
<p>最后可以用任务管理器或者在命令行输入<code>nginx -s stop</code>关闭</p>
</li>
<li><p><strong>4.修改配置</strong></p>
<p>Nginx可以在conf文件中修改配置，并且是热部署方式，可以通过以下指令不需要stop Nginx，不需要中断请求，就能让配置文件生效</p>
<p><code>nginx -s reload </code></p>
</li>
</ul>
<h1 id="二、反向代理"><a href="#二、反向代理" class="headerlink" title="二、反向代理"></a>二、反向代理</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>首先在本机上运行一个web项目</p>
<p>然后在<code>nginx.conf</code>文件中的<code>server</code>块中修改<code>location</code>中内容如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">server</span> &#123;</span><br><span class="line">    <span class="string">listen</span>       <span class="number">80</span><span class="string">;</span></span><br><span class="line">    <span class="string">server_name</span>  <span class="string">localhost;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#charset koi8-r;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#access_log  logs/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">location</span> <span class="string">/</span> &#123;</span><br><span class="line">        <span class="string">proxy_pass</span> <span class="string">http://211.67.16.199:8080/seckill;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="string">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  <span class="string">/50x.html;</span></span><br><span class="line">    <span class="string">location</span> <span class="string">=</span> <span class="string">/50x.html</span> &#123;</span><br><span class="line">        <span class="string">root</span>   <span class="string">html;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，监听本地服务器的80端口</p>
<p><strong>location /：</strong> 表示处理所有请求<br><strong>proxy_pass <a href="http://211.67.16.199:8080/seckill%EF%BC%9A">http://211.67.16.199:8080/seckill：</a></strong> 表示把请求都交给该网站来处理</p>
<p>修改后<code>nginx -s reload </code>让配置生效</p>
<p>这时再访问本机的80端口就会反向代理到web项目部署的网站</p>
<h1 id="三、负载均衡"><a href="#三、负载均衡" class="headerlink" title="三、负载均衡"></a>三、负载均衡</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><p>启动两台机子上的web项目</p>
<p>添加一个增加一个upstream，用来指向不同的服务器</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">upstream</span> <span class="string">mysever</span> &#123;</span><br><span class="line">     <span class="comment">#weigth参数表示权值，权值越高被分配到的几率越大</span></span><br><span class="line">     <span class="string">server</span> <span class="number">211.67</span><span class="number">.16</span><span class="number">.199</span><span class="string">:8080</span> <span class="string">weight=3;</span></span><br><span class="line">     <span class="string">server</span> <span class="number">119.23</span><span class="number">.65</span><span class="number">.18</span><span class="string">:8080</span> <span class="string">weight=1;</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>最后还是修改location好反向代理请求</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">location</span> <span class="string">/</span> &#123;</span><br><span class="line">        <span class="string">root</span>   <span class="string">html;</span></span><br><span class="line">        <span class="string">index</span>  <span class="string">index.html</span> <span class="string">index.htm;</span></span><br><span class="line">        <span class="string">proxy_pass</span> <span class="string">http://myserver/seckill;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里注意不能直接在upstream中直接添加项目名seckill,否则会报错</p>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指38-字符串的排列</title>
    <url>/2021/04/21/%E5%89%91%E6%8C%8738-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<p><strong>剑指 Offer 38. 字符串的排列</strong></p>
<p><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/">力扣链接</a></p>
<a id="more"></a>

<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个字符串，打印出该字符串中字符的所有排列。</p>
<p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;abc&quot;</span><br><span class="line">输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]</span><br></pre></td></tr></table></figure>
<p><strong>限制：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;&#x3D; s 的长度 &lt;&#x3D; 8</span><br></pre></td></tr></table></figure>
<h1 id="思路一：利用排序去重"><a href="#思路一：利用排序去重" class="headerlink" title="思路一：利用排序去重"></a>思路一：利用排序去重</h1><p>字符串排列实际上就是全排列问题的变种，我们知道可以用<strong>回溯</strong>解决。</p>
<p>这道题的难点在于<strong>去重</strong></p>
<p>重复的情况在于，递归到了同一层中，一个元素作为全排列固定位置后，另一个相同的元素也被用在该位置上，那后面生成的排列就是重复的</p>
<p>如果我们在最后生成结果后去重，就没有<strong>剪枝</strong>，多走路不必要的路径</p>
<p>这里我们知道数组排序后重复的元素必定相邻，那<strong>只要和前一位元素判断是否相同，如果相同判断其是否在这一层被使用过就可以去重</strong></p>
<p>下面是我的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">public</span> String[] permutation(String s) &#123;</span><br><span class="line">        <span class="keyword">char</span>[] c = s.toCharArray();</span><br><span class="line">        Arrays.sort(c);</span><br><span class="line">        permutation(c,<span class="number">0</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ans.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);  </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">permutation</span><span class="params">(<span class="keyword">char</span>[] c,<span class="keyword">int</span> index ,String sb)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == c.length)&#123;</span><br><span class="line">            ans.add(sb);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">                <span class="comment">// 关键剪枝去重步骤，其中!visited[i - 1]作用在于判断是否在同一层</span></span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> || c[i - <span class="number">1</span>] != c[i] || !visited[i - <span class="number">1</span>])&#123;</span><br><span class="line">                    visited[i] = <span class="keyword">true</span>;</span><br><span class="line">                    permutation(c,index+<span class="number">1</span>, sb + c[i]);</span><br><span class="line">                    visited[i] = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意理解当<code>c[i - 1] == c[i]</code>时，<code>visited[i - 1] ==false </code>即代表在同一层</p>
<h2 id="思路二：利用集合去重"><a href="#思路二：利用集合去重" class="headerlink" title="思路二：利用集合去重"></a>思路二：利用集合去重</h2><p>另外一种直观的思路就是利用每一层利用HashSet去重，我参考了别人的代码后，代码如下,</p>
<p>当不需要排序去重后，可以将用过或者没有用过的元素放在char数组两边，省去了visited数组，更加的高效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;String&gt; ans &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    char[] c;</span><br><span class="line">    public String[] permutation(String s) &#123;</span><br><span class="line">        c &#x3D; s.toCharArray();</span><br><span class="line">        dfs(0);</span><br><span class="line">        return ans.toArray(new String[0]);</span><br><span class="line">    &#125;</span><br><span class="line">    void dfs(int x) &#123;</span><br><span class="line">        if(x &#x3D;&#x3D; c.length - 1) &#123;</span><br><span class="line">            ans.add(String.valueOf(c));      </span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        HashSet&lt;Character&gt; set &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">        for(int i &#x3D; x; i &lt; c.length; i++) &#123;</span><br><span class="line">            if(set.contains(c[i])) continue; </span><br><span class="line">            set.add(c[i]);</span><br><span class="line">            swap(i, x);                      </span><br><span class="line">            dfs(x + 1);                      </span><br><span class="line">            swap(i, x);                     </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void swap(int a, int b) &#123;</span><br><span class="line">        char temp &#x3D; c[a];</span><br><span class="line">        c[a] &#x3D; c[b];</span><br><span class="line">        c[b] &#x3D; temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>剑指Offer</category>
        <category>算法</category>
        <category>递归</category>
        <category>排列问题</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>多态</title>
    <url>/2021/04/19/%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>封装</title>
    <url>/2021/04/19/%E5%B0%81%E8%A3%85/</url>
    <content><![CDATA[<p>了解封装的意义，以及如何实现封装</p>
<a id="more"></a>

<h1 id="一、简要"><a href="#一、简要" class="headerlink" title="一、简要"></a>一、简要</h1><p><strong>封装</strong>是Java面对对象三大基本特征之一，其作用在于：</p>
<ul>
<li>使用户不要接触他们不该接触的部分，这部分对于类内部、包内部来说是必要的，但是不属于客户端程序员所需接口的一部分。</li>
<li>让类库设计者更改类内部的工作方式，而不用担心会影响到客户端程序员，这也是最重要的原因。</li>
</ul>
<p>封装实现了信息隐藏，<strong>实现了解耦，降低构建大型系统的风险，也方便修改重构</strong></p>
<p>在Java中，主要通过<strong>访问控制</strong>来实现信息隐藏</p>
<p>首先在一个内，包内包含一组类，这些类之间也有访问权限，即<strong>类访问权限</strong></p>
<ul>
<li>公有：public，确定类库中的哪些类对于类库的使用者是可用的</li>
<li>包级私有：默认，仅在该包内可以访问</li>
</ul>
<p>其次对于一个内的成员，也有四个级别的访问控制权限：</p>
<ul>
<li><p>私有的（private）：只有声明该成员的顶层类内部可以访问该成员</p>
</li>
<li><p>包级私有的（缺省）：声明该成员的包的顶层类内部可以访问该成员</p>
</li>
<li><p>受保护的（protected）：不仅包内该成员可以被访问，该类的子类也可以访问该成员</p>
</li>
<li><p>公有的（public）:任何地方都可以访问</p>
</li>
</ul>
<p>对于这些访问控制权限的使用要求有一个总体原则：<strong>使类和成员的访问最小化</strong></p>
<p>下面是针对这个原则作出的一些具体要求</p>
<h1 id="二、类封装规范"><a href="#二、类封装规范" class="headerlink" title="二、类封装规范"></a>二、类封装规范</h1><h2 id="1、类间访问"><a href="#1、类间访问" class="headerlink" title="1、类间访问"></a>1、类间访问</h2><p><strong>能包级私有就做成包级私有，特别如果只在一个类内部使用这个顶层类，应该把其做为私有嵌套类</strong></p>
<p>当你创建了一个包访问权限的类，把类中的属性声明为 <strong>private</strong> 仍然是有意义的——应该尽可能将所有属性都声明为 <strong>private</strong>，但是通常把方法声明成与类（包访问权限）相同的访问权限也是合理的。</p>
<h2 id="2、成员访问"><a href="#2、成员访问" class="headerlink" title="2、成员访问"></a>2、成员访问</h2><ul>
<li><p><strong>尽量使用私有成员变量</strong></p>
</li>
<li><p><strong>包级私有只有当一个包的另一个类真正需要访问一个成员时，才使用，特别的，当一个类这样的成员过多，考虑是否可以将这部分分解成包级私有类，解耦。</strong></p>
</li>
<li><p><strong>受保护的成员变量是类导出API的一部分，是某个实现细节的公开承诺，要保证支持；尽量减少使用。</strong></p>
</li>
<li><p><strong>公有类域绝不能是公有的（放弃不可变，线程安全，灵活性），除非是一些静态final域的常量</strong>,这时可以考虑私有域+公有getter的解决方案，如果类可变，还需要加上公有setter方法</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java语法</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Java语法</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis设计实现</title>
    <url>/2021/04/24/Redis%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>简单了解Redis各个功能的设计和实现</p>
<a id="more"></a>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>滑动窗口模板</title>
    <url>/2021/04/24/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<p>个人认为，滑动窗口问题也是双指针问题的一种，但类似于二分算法，一般都有迹可循，常用来解决字符串问题，这里主要</p>
<p>讲解其模板，并且尝试解决几个例题</p>
<a id="more"></a>

<h1 id="一、通用模板"><a href="#一、通用模板" class="headerlink" title="一、通用模板"></a>一、通用模板</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slidingWindow</span><span class="params">(String t,String p)</span></span>&#123;</span><br><span class="line">	Map&lt;Character,Integer&gt; need = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Map&lt;Character,Integer&gt; window = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 存储p的信息</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> key : p.toCharArray())</span><br><span class="line">           need.put(key,need.getOrDefault(key,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 标准滑动三件套</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 可能有其他变量辅助求最优解</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(right &lt; t.length())&#123;</span><br><span class="line">        <span class="comment">// right 右移扩大窗口，操作window，更新valid值</span></span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断是否需要收缩，一般可以用valid判断  </span></span><br><span class="line">         <span class="keyword">while</span>(valid == need.size())&#123;</span><br><span class="line">             <span class="keyword">if</span>(更新答案的条件)&#123;</span><br><span class="line">                 ...</span><br><span class="line">             &#125;</span><br><span class="line">             </span><br><span class="line">             <span class="comment">// left++,收缩窗口，更新valid、window状态</span></span><br><span class="line">             </span><br><span class="line">         &#125;  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二、一些例题"><a href="#二、一些例题" class="headerlink" title="二、一些例题"></a>二、一些例题</h1><h2 id="1-最小覆盖子串"><a href="#1-最小覆盖子串" class="headerlink" title="1.最小覆盖子串"></a><strong>1.最小覆盖子串</strong></h2><p><a href="https://leetcode-cn.com/problems/minimum-window-substring/">力扣链接</a></p>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h3><p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p>
<p><strong>注意：</strong>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;ADOBECODEBANC&quot;, t &#x3D; &quot;ABC&quot;</span><br><span class="line">输出：&quot;BANC&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;a&quot;, t &#x3D; &quot;a&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length, t.length &lt;= 105</code></li>
<li><code>s</code> 和 <code>t</code> 由英文字母组成</li>
</ul>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a><strong>思路</strong></h3><p>首先移动right扩大窗口，直到刚好可以覆盖子串，这是可行解</p>
<p>然后移动left收缩窗口，希望使得满足覆盖条件下的窗口更小，这是寻找最优解</p>
<p>最后代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        HashMap&lt;Character, Integer&gt; tMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        HashMap&lt;Character, Integer&gt; windowMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c :  t.toCharArray()) &#123; <span class="comment">// 记录 t 中所有字符出现的次数</span></span><br><span class="line"></span><br><span class="line">            tMap.put(c, tMap.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 记录窗口中满足条件的字符个数</span></span><br><span class="line">        <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录最小覆盖字串的起始索引及长度</span></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, minLength = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (right &lt; n) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(right);</span><br><span class="line">            <span class="comment">// 判断取出的字符是否在 t 中</span></span><br><span class="line">            <span class="keyword">if</span> (tMap.containsKey(c)) &#123;</span><br><span class="line"></span><br><span class="line">                windowMap.put(c, windowMap.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 判断取出的字符在窗口中的出现次数是否与 t 中该字符的出现次数相同</span></span><br><span class="line">                <span class="keyword">if</span> (windowMap.get(c).equals(tMap.get(c))) &#123; </span><br><span class="line"></span><br><span class="line">                    valid++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断是否需要缩小窗口(已经找到符合条件的子串)</span></span><br><span class="line">            <span class="keyword">while</span> (valid == tMap.size()) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (right - left + <span class="number">1</span> &lt; minLength) &#123;</span><br><span class="line"></span><br><span class="line">                    start = left;</span><br><span class="line">                    minLength = right - left + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">char</span> c1 = s.charAt(left);</span><br><span class="line">                left++;</span><br><span class="line">                <span class="keyword">if</span> (tMap.containsKey(c1)) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (windowMap.get(c1).equals(tMap.get(c1))) &#123;</span><br><span class="line"></span><br><span class="line">                        valid--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    windowMap.put(c1, windowMap.getOrDefault(c1, <span class="number">0</span>) - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minLength == Integer.MAX_VALUE ? <span class="string">&quot;&quot;</span> : s.substring(start, start + minLength);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-字符串的排列"><a href="#2-字符串的排列" class="headerlink" title="2.字符串的排列"></a>2.字符串的排列</h2><p><a href="https://leetcode-cn.com/problems/permutation-in-string/">力扣链接</a></p>
<h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定两个字符串 <code>s1</code> 和 <code>s2</code>，写一个函数来判断 <code>s2</code> 是否包含 <code>s1</code> 的排列。</p>
<p>换句话说，第一个字符串的排列之一是第二个字符串的 <strong>子串</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s1 &#x3D; &quot;ab&quot; s2 &#x3D; &quot;eidbaooo&quot;</span><br><span class="line">输出: True</span><br><span class="line">解释: s2 包含 s1 的排列之一 (&quot;ba&quot;).</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s1&#x3D; &quot;ab&quot; s2 &#x3D; &quot;eidboaoo&quot;</span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>输入的字符串只包含小写字母</li>
<li>两个字符串的长度都在 <code>[1, 10,000]</code> 之间</li>
</ul>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>这道题和上道题目很像，我们带入上题的思路，唯一不同但是，这次我们尝试用数组来做hash表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] need = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">255</span>];</span><br><span class="line">        <span class="keyword">int</span>[] window = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">255</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : s1.toCharArray())</span><br><span class="line">            need[c]++;</span><br><span class="line">        <span class="keyword">char</span>[] str = s2.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : need)</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span>)</span><br><span class="line">                count++;</span><br><span class="line">        <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; str.length)&#123;</span><br><span class="line">            <span class="keyword">while</span>(right &lt; str.length &amp;&amp; valid &lt; count)&#123;</span><br><span class="line">                <span class="comment">// &gt;0</span></span><br><span class="line">                window[str[right]]++;</span><br><span class="line">                <span class="keyword">if</span>(window[str[right]] == need[str[right++]])</span><br><span class="line">                    valid++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(valid == count)&#123;</span><br><span class="line">                <span class="keyword">if</span>((right - left) == s1.length())</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(need[str[left]] &gt; <span class="number">0</span> &amp;&amp; need[str[left]] &gt; --window[str[left]])</span><br><span class="line">                    valid--;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大体逻辑不变</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>双指针</category>
      </categories>
      <tags>
        <tag>双指针</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>网络IO</title>
    <url>/2021/04/24/%E7%BD%91%E7%BB%9CIO/</url>
    <content><![CDATA[<p>对网络IO的知识进行简单了解</p>
<a id="more"></a>

<h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h1><h2 id="1-同步、异步；阻塞、非阻塞"><a href="#1-同步、异步；阻塞、非阻塞" class="headerlink" title="1.同步、异步；阻塞、非阻塞"></a>1.同步、异步；阻塞、非阻塞</h2><p>对于<strong>IO上面的理解</strong></p>
<p>同步异步描述的是<strong>用户线程</strong>同<strong>内核</strong>的两个方面的交互状态</p>
<ul>
<li><strong>同步</strong>指用户线程发起IO请求后，需要<strong>等待或者轮询内核IO操作完成</strong>后，才能继续执行</li>
<li><strong>异步</strong>是指用户线程向内核发起IO请求后，依旧可以继续执行，而<strong>内核的IO操作完成后，会通知用户线程或者执行用户线程注册的回调函数</strong></li>
</ul>
<p>阻塞和非阻塞描述的是<strong>用户线程</strong>调用IO操作的方式</p>
<ul>
<li><p><strong>阻塞</strong>指<strong>IO操作彻底完成后</strong>才返回用户空间</p>
</li>
<li><p><strong>非阻塞</strong>指IO操作被调用时立即返回一个<strong>状态值</strong>，不需要IO操作彻底完成</p>
</li>
</ul>
<p>在更高层面上理解的话，<strong>同步、异步是两个对象之间的关系，而阻塞、非阻塞是一个对象的状态</strong>。</p>
<p>比如对于通信，同步和异步是指：发送方和接收方是否协调步调一致；对于线程，是指两个线程的运行是否相关，会被阻塞</p>
<p>而阻塞和同步、异步的关系，<strong>阻塞可以是实现同步的一种手段</strong>。例如两个东西需要同步，一旦出现不同步情况，我就阻塞快的一方，使双方达到同步</p>
<p>一篇转载文章理解</p>
<p><a href="https://www.zhihu.com/question/19732473/answer/117012135">转载至灵剑</a></p>
<p>一个网络包从应用程序A发到另一台电脑上的应用程序B，需要经历：</p>
<ol>
<li>从A的业务代码到A的软件框架</li>
<li>从A的软件框架到计算机的操作系统内核</li>
<li>从A所在计算机的内核到网卡</li>
<li>从网卡经过网线发到交换机等设备，层层转发，到达B所在计算机的网卡</li>
<li>从B所在计算机的网卡到B所在计算机的内核</li>
<li>从B所在计算机的内核到B的程序的用户空间</li>
<li>从B的软件框架到B的业务代码</li>
</ol>
<p>这个层级关系就像是过程调用一样，前一级调用后一级的功能，后一级返回一个结果给前一级（比如：成功，或者失败）。只有在单独一级的调用上，可以说同步还是异步的问题。所谓同步，是指调用协议中结果在调用完成时返回，这样调用的过程中参与双方都处于一个状态同步的过程。而异步，是指调用方发出请求就立即返回，请求甚至可能还没到达接收方，比如说放到了某个缓冲区中，等待对方取走或者第三方转交；而结果，则通过接收方主动推送，或调用方轮询来得到。</p>
<p>从这个定义中，我们看，首先1和7，这取决于软件框架的设计，如果软件框架可以beginXXX，然后立即返回，这就是一种异步调用，再比如javascript当中的异步HTTP调用，传入参数时提供一个回调函数，回调函数在完成时调用，再比如协程模型，调用接口后马上切换到其他协程继续执行，在完成时由框架切换回到协程中，这都是典型的异步接口设计。</p>
<p><strong>而2和6，其实都需要调用方自己把数据在内核和用户空间里搬来搬去，其实都是同步接口，除非是IOCP这样的专门的异步传输接口，所以这一级其实是同步的，阻塞与非阻塞的区别其实是影响调用接口的结果（在特定条件下是否提前返回结果），而不是调用方式。</strong></p>
<p>3和5，内核一般通过缓冲区，使用DMI来传输数据，所以这一步又是异步的。</p>
<p>4，以太网是个同步时序逻辑，随信号传输时钟，必须两边设备同时就绪了才能开始传输数据，这又是同步的。</p>
<p>总结来说，讨论究竟是异步还是同步，一定要严格说明说的是哪一部分。其他答主说非阻塞是同步而不是异步，这毫无疑问是正确的，然而说某个框架是异步IO的框架，这也是正确的，因为说的其实是框架提供给业务代码的接口是异步的，不管是回调还是协程，比如说我们可以说某个库是异步的HTTPClient，并没有什么问题，因为说的是给业务代码的接口。由于通常异步的框架都需要在2中使用非阻塞的接口，的确会有很多人把非阻塞和异步混为一谈。</p>
<h2 id="2-一个网络通信过程"><a href="#2-一个网络通信过程" class="headerlink" title="2.一个网络通信过程"></a>2.一个网络通信过程</h2><p><strong>一个服务端处理请求的过程</strong></p>
<p><img src="/images/image-20210424170224633.png" alt="image-20210424170224633"></p>
<p>所以关于网络中的数据输入操作主要包含两个过程</p>
<ul>
<li>等待数据准备好，从网卡复制到内存缓冲区</li>
<li>从内核向进程的用户空间复制数据</li>
</ul>
<h1 id="二、常见IO模型"><a href="#二、常见IO模型" class="headerlink" title="二、常见IO模型"></a>二、常见IO模型</h1><h2 id="同步阻塞IO"><a href="#同步阻塞IO" class="headerlink" title="同步阻塞IO"></a>同步阻塞IO</h2><p>通过阻塞实现同步，用户在内核进行IO操作时阻塞</p>
<p><img src="/images/image-20210507153854260.png" alt="image-20210507153854260"></p>
<p>用户线程通过系统调用read发起IO读操作，由用户空间转到内核空间。内核等到数据包到达后，然后将接收的数据拷贝到用户空间，完成read操作。</p>
<p>由于用户需要等待read将socket中的数据读取到buffer后，才继续处理接收的数据。整个IO请求的过程中，用户线程是被阻塞的，这导致用户在发起IO请求时，不能做任何事情，对CPU的资源利用率不够。</p>
<p>这个时候要实现高并发就是我们常见的多线程模型</p>
<h2 id="同步非阻塞IO"><a href="#同步非阻塞IO" class="headerlink" title="同步非阻塞IO"></a>同步非阻塞IO</h2><p>此时用户线程在发起IO请求后立即返回，为了实现同步，用户线程执行轮询操作直到IO操作完成</p>
<p><img src="/images/image-20210507154448923.png" alt="image-20210507154448923"></p>
<p>这里socket是非阻塞的方式，因此用户线程发起IO请求时立即返回。但并未读取到任何数据，用户线程需要不断地发起IO请求，直到数据到达后，才真正读取到数据，继续执行。</p>
<p>可见该方法避免了用户线程阻塞，但是不断的轮询会消耗大量的CPU资源，一般很少使用。如果在线程轮询消耗远小于线程阻塞、唤醒、切换的消耗，可以考虑使用，类似于Java synchronized用自旋锁优化的过程</p>
<p>在高并发情况下，存在C10K问题，每次循环遍历所有客户端，会花费时间不断反复执行read系统调用，特别在不是所有客户端都ready的情况下，消耗大量CPU时间，即每循环内O(n)的系统调用</p>
<h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><h3 id="select"><a href="#select" class="headerlink" title="select"></a><strong>select</strong></h3><p>select是内核提供的多路分离函数，可以使用其实现IO端口的复用</p>
<p>下面是Linux中的select设计</p>
<p>关键有两个结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fd_set</span><br><span class="line">timeval</span><br></pre></td></tr></table></figure>
<p>其中<strong>fd_set</strong>可以认为是一个位图，每一位标志相应大小文件描述符（每一个文件描述符同一个socket对应），fd_set主要有三种类型：readfds、writefds、errorfds，对应可读、可写、异常等情况</p>
<p><strong>timeval</strong>主要记录时间</p>
<p>调用select函数时，参数如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfdp,fd_set *readfds,fd_set *writefds,fd_set *errorfds,struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中maxdp是所有文件描述符的范围，为fd_set中所有文件描述符的最大值加1</p>
<p>中间三个fds分别代表监控读、写、错误异常文件，可以传null值表示不关心</p>
<p>最后的timeout是select的超时时间：</p>
<ul>
<li>为NULL：将select置于阻塞状态，一定等到监视文件描述符集合中某个文件描述符发生变化为止</li>
<li>为0，就变成一个纯粹的非阻塞函数，不管文件描述符是否有变化，都立刻返回继续执行，文件无变化返回0，有变化返回一个正值</li>
<li>正值，是等待的超时时间，即 select在timeout时间内阻塞，超时时间之内有事件到来就返回了，否则在超时后不管怎样一定返回，返回值同上述。</li>
</ul>
<p>最后就可以对select的工作流程进行概述：</p>
<p>select将有多个文件描述符传递给内核，内核监控这些文件描述符直到一个或多个文件描述符变成可用状态，在返回这些可用的状态，程序再对这些可用状态进行读写操作，是同步的。</p>
<p>select也是一个系统调用，在高并发情况下，利用select可用大幅度减少系统调用的次数，对比上面的同步非阻塞模型，每次循环执行一个select，内核主动遍历这些文件描述符O（n），注意区别在于这里O（n）的遍历<strong>不是系统调用</strong>，进而比之前的模型更优化了</p>
<p>但是该方法也有一些问题：</p>
<ul>
<li>每次select传递大量的文件描述符</li>
<li>内核主动遍历这些文件描述符时间复杂度高，cpu浪费</li>
</ul>
<p>采用epoll正是对这两方面的优化</p>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p><strong>优化原理</strong></p>
<p>epoll在内核开辟一片空间，添加的文件描述符就放在这片空间，避免了select重复传递大量文件描述符的问题</p>
<p>此外epoll内核和用户共用一片内存，将状态改变的文件描述符放置在这片区域，程序再从这片区域中读取这些可读可写的文件描述符，发生同步读写</p>
<p>此时内核通过<strong>事件驱动</strong>将内核空间内的状态ready的文件描述符放置到共享的内存区域供程序读写，这个时间复杂度是<strong>O(1)</strong></p>
<p>这个事件驱动原理和前面的网络通信过程有关：</p>
<p>当客户端的数据发送到硬件网卡的缓存上，网卡收到数据后放置到内核缓存区，这时网卡会通过硬中断中断CPU，CPU通过回调知道是哪个文件描述符状态改变，再移动到共享区域。这个时候CPU不需要主动遍历这些文件描述符，而是通过中断知道哪些文件描述符准备完毕，更少的浪费了CPU</p>
<p><strong>Linux实现</strong></p>
<p>epoll在Linux上的实现主要和几个函数有关</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">epoll_create 开辟添加文件描述符的空间，记fd1</span><br><span class="line">epoll_ctl 对文件描述符进行增加、删除、修改监听事件 在fd1上操作</span><br><span class="line">epoll_wait 阻塞进程，等待事件的产生</span><br></pre></td></tr></table></figure>
<p>这些方法都是系统调用方法</p>
<p>方法使用步骤如下</p>
<ul>
<li><p>当某个进程调用epoll_create方法时，内核会创建一个eventpoll对象，其内维护一个等待队列（为了便于插入删除，采用的是双向队列，同时采用红黑树做索引）</p>
</li>
<li><p>创建一个eventpoll对象，可以用epoll_ctl添加或删除所要监听的socket</p>
</li>
<li><p>进程执行执行了epoll_wait，就绪列表没有数据进程阻塞；当socket收到数据后，中断程序会给eventpoll的“就绪列表”添加socket引用，同时也会唤醒对对应的进程（执行了epoll_wait）</p>
</li>
</ul>
<h3 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式"></a>Reactor模式</h3><p>Reactor模式需要底层的同步事件分离器，比如上文的select或者epoll。或者说，该模式是采用了select或者是epoll编程的一种应用方式，具体工作原理如下图</p>
<p><img src="/images/image-20210511164127269.png" alt="image-20210511164127269"></p>
<p>Reactor基于事件驱动的，它有一个或多个并发输入源，有一个Reactor，其管理连接的socket的注册、删除与转发，让socket和一个对应event handler关联；然后Reactor再调用select或者epoll对对应的socket进行处理，等待相应的事件发生，事件发生后会通知Reactor，对发生事件的socket调用特定的event handler响应事件</p>
<p>下图是基于select的Reactor实现</p>
<p><img src="/images/image-20210509155140363.png" alt="image-20210509155140363"></p>
<h2 id="信号驱动-I-O"><a href="#信号驱动-I-O" class="headerlink" title="信号驱动 I/O"></a>信号驱动 I/O</h2><p>应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。</p>
<p>相比于非阻塞式 I/O 的轮询方式，信号驱动 I/O 的 CPU 利用率更高。</p>
<h2 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h2><p>用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。</p>
<p>“真正”的异步IO需要操作系统更强的支持，需要操作系统实现异步读API。在IO多路复用模型中，事件循环将文件句柄的状态事件通知给用户线程，由用户线程自行读取数据、处理数据。而在异步IO模型中，当用户线程收到通知时，数据已经被内核读取完毕，并放在了用户线程指定的缓冲区内，内核在IO完成后通知用户线程直接使用即可。</p>
<h2 id="IO模型比较"><a href="#IO模型比较" class="headerlink" title="IO模型比较"></a>IO模型比较</h2><p>体会了几个网络IO模型的概念后，再整体了解同步异步IO以及几大模型之间的区别</p>
<ul>
<li>同步 I/O：将数据从内核缓冲区复制到应用进程缓冲区的阶段（第二阶段），应用进程会阻塞。</li>
<li>异步 I/O：第二阶段应用进程不会阻塞。</li>
</ul>
<p>同步 I/O 包括阻塞式 I/O、非阻塞式 I/O、I/O 复用 ，它们的主要区别在第一个阶段。</p>
<p>非阻塞式 I/O 、和异步 I/O 在第一阶段不会阻塞。</p>
<p>只有异步IO第二个阶段不会阻塞</p>
]]></content>
      <categories>
        <category>网络通信</category>
        <category>网络IO</category>
      </categories>
      <tags>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>反射</title>
    <url>/2021/04/26/%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<p>介绍Java反射并且了解其优缺点，应用场景</p>
<a id="more"></a>

<h1 id="一、反射原理"><a href="#一、反射原理" class="headerlink" title="一、反射原理"></a>一、反射原理</h1><p>一个Java项目中，我们的<code>.java</code>文件会被编译成<code>.class</code>文件，<code>.class</code>文件会在程序运行时会被类加载器加载到虚拟机中，并且在方法区自动生成<strong>Class对象</strong>，这些Class对象承载了这个类的所有信息，包括父类、接口、构造函数、方法、属性等，<strong>反射的本质在于获取这个Class对象后，反向修改这个类的信息。</strong></p>
<p>观察Class对象的一些方法声明</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Constructor&lt;T&gt; <span class="title">getConstructor</span><span class="params">(Class&lt;?&gt;... parameterTypes)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> NoSuchMethodException, SecurityException </span>&#123;</span><br><span class="line">        checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> getConstructor0(parameterTypes, Member.PUBLIC);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="meta">@CallerSensitive</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Method <span class="title">getMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> NoSuchMethodException, SecurityException </span>&#123;</span><br><span class="line">        checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), <span class="keyword">true</span>);</span><br><span class="line">        Method method = getMethod0(name, parameterTypes, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (method == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodException(getName() + <span class="string">&quot;.&quot;</span> + name + argumentTypesToString(parameterTypes));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> method;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@CallerSensitive</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Field <span class="title">getField</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> NoSuchFieldException, SecurityException </span>&#123;</span><br><span class="line">        checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), <span class="keyword">true</span>);</span><br><span class="line">        Field field = getField0(name);</span><br><span class="line">        <span class="keyword">if</span> (field == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchFieldException(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> field;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在这些方法中我们发现。可以通过<code>Class对象</code>来生成一个类的实例，或者是其构造器、方法、域对象</p>
<p>所以反射的工作原理也可以说就是借助<code>Class.java、Constructor.java、Method.java、Field.java</code>这四个类在程序运行时动态访问和修改任何类的行为和状态。</p>
<p><strong>其中对应Class对象是反射的入口！</strong></p>
<p>一般有以下获取方式</p>
<ul>
<li><p>通过<code>Class.forName(&quot;全类名&quot;)</code>获取</p>
</li>
<li><p><code>类名.class</code>获取</p>
</li>
<li><p><code>对象.getClass()</code>获取</p>
</li>
</ul>
<h1 id="二、反射缺点"><a href="#二、反射缺点" class="headerlink" title="二、反射缺点"></a>二、反射缺点</h1><p>反射的缺点主要有以下几点</p>
<ul>
<li>性能问题，反射比正常调用速度慢</li>
<li>反射破坏了类的封装性、可以通过反射修改类的私有属性、调用、私有方法、甚至是私有构造器</li>
</ul>
<p>关于反射性能慢这个点，我们首先查看<code>Method.invoke</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException,</span></span><br><span class="line"><span class="function">          InvocationTargetException</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!override) &#123;</span><br><span class="line">           <span class="keyword">if</span> (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;</span><br><span class="line">               Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">               checkAccess(caller, clazz, obj, modifiers);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       MethodAccessor ma = methodAccessor;             <span class="comment">// read volatile</span></span><br><span class="line">       <span class="keyword">if</span> (ma == <span class="keyword">null</span>) &#123;</span><br><span class="line">           ma = acquireMethodAccessor();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ma.invoke(obj, args);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>在其里面有用到<code>MethodAccessor</code>,可见具体的反射调用逻辑是委托给<code>MethodAccessor</code>的，而<code>accessor</code>对象会在第一次<code>invoke</code>的时候才创建，是一种<code>lazy init</code>方式。而且默认<code>Class</code>类会缓存method对象。</p>
<p><code>MethodAccessor</code>实际会委托给<code>DelegatingMethodAccessorImpl</code>对象，其就是一个代理对象，负责调用被代理对象<code>delegate</code>的<code>invoke</code>方法，<code>delegate</code>的实现有两种，一个<code>native</code>方式（本地方法），一种生成<code>java bytecode</code>方式（生成字节码，创建对应的class对象）。</p>
<p><code>native</code>方式启动快，但运行时间长了不如<code>java</code>方式，主要问题在于**<code>jit compiler</code>**可以对字节码进行优化。所以在native方式中，有一个计数器，当调用次数达到阀值，就会转为使用j<code>java bytecode</code>方式。默认值是15。</p>
<p><strong>补充知识</strong></p>
<p>ASM 是一个 Java 字节码操控框架。它能被用来动态生成类或者增强既有类的功能。ASM 可以直接产生二进制 class 文件，也可以在类被加载入 Java 虚拟机之前动态改变类行为。说白了asm是直接通过字节码来修改class文件。</p>
<p>该技术在AOP时会再次提到</p>
<h1 id="三、反射优势及应用"><a href="#三、反射优势及应用" class="headerlink" title="三、反射优势及应用"></a>三、反射优势及应用</h1><p>反射提高了Java程序的灵活性和扩展性，降低耦合性，提高自适应能力。它允许程序创建和控制任何类的对象</p>
<p>我在学习<strong>简单工厂模式</strong>的时候，可以使用反射进行解耦，避免ifelse语句以及增加类时对代码的修改</p>
<p>在学习代理模式的时候，JDK的反射可以用于<strong>动态代理</strong>，用来增强类的功能</p>
<p>后面学习Spring的时候，发现工厂模式加反射被用到了<strong>IoC</strong>，动态代理在<strong>AOP</strong>中也有体现</p>
]]></content>
      <categories>
        <category>Java语法</category>
        <category>进阶</category>
      </categories>
      <tags>
        <tag>Java语法</tag>
      </tags>
  </entry>
  <entry>
    <title>注解</title>
    <url>/2021/04/28/%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<p>了解Java注解相关基础知识</p>
<a id="more"></a>

<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><p>注解是 Java 引入的一项非常受欢迎的补充，它提供了一种结构化，并且具有类型检查能力的新途径，从而使得你能够为代码中加入元数据，而且不会导致代码杂乱并难以阅读。</p>
<p>注解为我们在代码中添加信息提供了一种形式化的方式，使我们可以在稍后的某个时刻更容易的使用这些数据。</p>
<p>注解在一定程度上是把元数据和源代码文件结合在一起的趋势所激发的，而不是保存在外部文档。</p>
<p>比如我们在学习Java Spring的时候，最开始是使用XML文件为Bean配置一下信息，我们还需要学习一下XML的操作，采用注解后就可以将相关数据放在注解处、源代码处。</p>
<p>又比如在搭建项目时使用一些注解可以用于代码的自动生成</p>
<p>总的来说，注解可能主要可能有以下用法：</p>
<ul>
<li><strong>附属文件的自动生成</strong></li>
<li><strong>测试、日志、事务语义等代码的自动生成</strong></li>
</ul>
<p>Java</p>
]]></content>
      <categories>
        <category>Java语法</category>
        <category>进阶</category>
      </categories>
      <tags>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring详解</title>
    <url>/2021/04/27/Spring%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>主要了解Spring IoC和AOP的底层原理，以及事务的一些知识</p>
<a id="more"></a>

<h1 id="一、IoC"><a href="#一、IoC" class="headerlink" title="一、IoC"></a>一、IoC</h1><h2 id="容器介绍"><a href="#容器介绍" class="headerlink" title="容器介绍"></a>容器介绍</h2><p>IoC即控制反转，控制反转就是把创建和管理 bean 的过程转移给了第三方。而这个第三方，就是 <strong>Spring IoC 容器</strong>。</p>
<p>IoC容器负责创建、配置和管理 bean，它管理着 bean 的生命，控制着 bean 的依赖注入。</p>
<p>在Spring类库的 <code>org.springframework.beans</code> 和<code>org.springframework.context</code> 的两个包下包含了IoC容器的基础。</p>
<p>首先，<code>org.springframework.beans</code>下有一个<code>BeanFactory</code>接口，其类似于一个HashMap：</p>
<ul>
<li>Key - bean name</li>
<li>Value - bean object</li>
</ul>
<p>我们可以通过<code>getBean</code>方法获取bean，但它一般只有 get, put 两个功能，所以称之为“低级容器”。</p>
<p>此外，<code>org.springframework.context</code> 包下有另外一个接口<code>ApplicationContext</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContext</span> <span class="keyword">extends</span> <span class="title">EnvironmentCapable</span>, <span class="title">ListableBeanFactory</span>, <span class="title">HierarchicalBeanFactory</span>, <span class="title">MessageSource</span>, <span class="title">ApplicationEventPublisher</span>, <span class="title">ResourcePatternResolver</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getApplicationName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getDisplayName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getStartupDate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ApplicationContext <span class="title">getParent</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">AutowireCapableBeanFactory <span class="title">getAutowireCapableBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到其继承了<code>ListableBeanFactory</code>接口，实际上该接口继承了<code>BeanFactory</code>接口，所以可以说<code>ApplicationContext</code>是<code>BeanFactory</code>接口的一个子接口，但是其有实现了其他接口，具有更多的功能，我们称之为<strong>高级容器</strong>，对此，我们最有可能遇到下列两种应用上下文：</p>
<p><code>AnnotationConfigApplicationContext</code>:基于Java配置类加载Spring应用上下文</p>
<p><code>ClassPathXmlApplicationContext</code>：从类路径下的XML配置文件中加载上下文定义</p>
<h2 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h2><p>正常Java中的对象的生命周期由GC垃圾回收控制</p>
<p>Spring bean的生命周期通常意义是指默认的单例模式，如果是原型模式，容器在初始化、配置、装饰或者是装配完一个prototype实例后，将它交给客户端，随后就不再管理该实例，具体如下图所示：</p>
<p><img src="/_posts/Spring%E8%AF%A6%E8%A7%A3.assets/image-20210303162631404.png" alt="image-20210303162631404"></p>
<p>我们把握住几个最关键的步骤</p>
<ul>
<li><p><strong>实例化</strong>：调用构造函数进行实例化，<strong>Spring默认调用无参构造函数</strong></p>
</li>
<li><p><strong>属性填充：</strong>依赖注入bean的值和引用</p>
</li>
<li><p><strong>初始化：</strong>如果bean实现了**<code>InitializingBean</code><strong>接口，spring将调用它的<code>afterPropertiesSet</code>接口方法，如果Bean在Spring配置文件中配置了</strong><code>init-method</code>属性**会自动调用其配置的初始化方法</p>
</li>
<li><p><strong>销毁：</strong>在容器关闭时销毁，若bean实现了<strong>DisposableBean</strong>接口，spring将调用它的distroy()接口方法。同样的，如果bean使用了<strong>destroy-method属性</strong>声明了销毁方法，则该方法被调用；</p>
</li>
</ul>
<p>再了解其他过程，如果该bean实现了**<code>XXXAware</code>接口<strong>，就会在属性填充到初始化之间调用该接口对应的<code>setXXX</code>方法，让该bean</strong>持有ID、BeanFactory、ApplicationContext等一些Spring容器的资源**，注意这些方法是实现了接口的bean才会调用</p>
<p>最后注意一个特殊的**<code>BeanPostProcessor</code>接口<strong>，其有两个方法，<code>postProcessBeforeInitialization()方法</code>和<code>postProcessAfterInitialization()方法</code>，作用于</strong>初始化**阶段的前后</p>
<p><strong>bean的作用域：</strong></p>
<p><img src="/_posts/Spring%E8%AF%A6%E8%A7%A3.assets/image-20200924104801025.png" alt="image-20200924104801025"></p>
<ul>
<li>request、session和global session三种作用域仅在基于web的应用中使用，只能用在基于web的Spring ApplicationContext环境。</li>
<li>singleton是单列模式，是bean作用域的默认形式，创建起容器时就自动创建了一个bean对象，之后每次返回都是这个对象</li>
<li>prototype表示一个bean对象可以创建多个对象实例，仅在需要获取对象的时候才创建实例</li>
<li>singleton和prototype区别：能对一个prototype bean的整个生命周期负责：容器在初始化、配置、装饰或者是装配完一个prototype实例后，将它交给客户端，随后就不再管理该实例</li>
</ul>
<h2 id="Bean的诞生"><a href="#Bean的诞生" class="headerlink" title="Bean的诞生"></a>Bean的诞生</h2><p>在单例模式下，一个Bean的产生和容器的创建息息相关</p>
<p>由于Spring 推荐使用注解，我的容器入口是 <code>AnnotationConfigApplicationContext</code> ，如果是使用 xml 分析，那么入口即为 <code>ClassPathXmlApplicationContext</code> ，它们俩的共同特征便是都继承了 <code>AbstractApplicationContext</code> 类</p>
<p>首先查看 <code>AnnotationConfigApplicationContext</code>常用的构造器方法，主要是调用第一个</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 常用构造方法</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">(Class&lt;?&gt;... componentClasses)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 容器初始化</span></span><br><span class="line">       <span class="keyword">this</span>();</span><br><span class="line">       <span class="comment">// 注册配置类信息</span></span><br><span class="line">       <span class="keyword">this</span>.register(componentClasses);</span><br><span class="line">     	<span class="comment">// 容器刷新</span></span><br><span class="line">       <span class="keyword">this</span>.refresh();</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 无参构造器</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 首先调用父类默认构造器</span></span><br><span class="line">       StartupStep createAnnotatedBeanDefReader = <span class="keyword">this</span>.getApplicationStartup().start(<span class="string">&quot;spring.context.annotated-bean-reader.create&quot;</span>);</span><br><span class="line">       <span class="comment">// 得到AnnotatedBeanDefinitionReader</span></span><br><span class="line">       <span class="keyword">this</span>.reader = <span class="keyword">new</span> AnnotatedBeanDefinitionReader(<span class="keyword">this</span>);</span><br><span class="line">       createAnnotatedBeanDefReader.end();</span><br><span class="line">       <span class="comment">// 得到ClassPathBeanDefinitionScanner</span></span><br><span class="line">       <span class="keyword">this</span>.scanner = <span class="keyword">new</span> ClassPathBeanDefinitionScanner(<span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>我们的bean产生经历了什么，可以大概从第一个构造器的三个步骤来分析</p>
<p><strong>1.this（）</strong></p>
<p>调用了自己的无参构造器，而在无参构造器中，又有几步：</p>
<ul>
<li><p>调用了父类构造器，生成了一个<strong>beanFactory 工厂</strong>（<code>DefaultListableBeanFactory</code>）；</p>
</li>
<li><p>生成一个<strong>AnnotatedBeanDefinitionReader</strong>，可以将对加了特定注解（如 <code>@Service</code>、<code>@Repository</code>）的类进行读取转化成 <code>BeanDefinition</code> 对象</p>
</li>
<li><p>生成一个<strong>ClassPathBeanDefinitionScanner</strong>，可以对用户指定的包目录进行扫描查找 bean 对象</p>
</li>
</ul>
<p>上面有提到一个<strong>BeanDefinition对象：</strong>spring当中的BeanDefinition就是java当中的Class，Class可以用来描述一个类的属性和方法等等其他信息。BeanDefintion可以描述springbean当中的scope、lazy，bean的注入模型、以及属性和方法等等其他信息，而这些信息是Class无法抽象出来的</p>
<p><strong>2.this.register(componentClasses)</strong></p>
<p>注册配置类信息，利用生成的reader将Appconfig类解析成为一个beanDefintion对象，然后给解析出来的beanDefinition对象设置一些默认属性，继而put到beanDefintionMap当中</p>
<p><strong>3.refresh（）</strong></p>
<p>在refresh中主要有两步：</p>
<ul>
<li>扫描出要放入容器的 bean，将其包装成 <code>BeanDefinition</code> 对象</li>
<li>然后通过反射创建 bean，并完成赋值操作</li>
</ul>
<p>但是这个只是IoC容器最简单的功能，实际上在这个过程中，我们可以用<code>BeanFactoryPostProcessor</code> 后置处理器，在扫描完 bean 之后做一些自定义的操作</p>
<p>也可以用前文提到的<code>BeanPostProcessor</code> 后置处理器在 bean 的初始化前后做一些操作</p>
<p>这些更细致的操作，应该会在之后再次仔细阅读Spring源码后更新，这里只是为了理清楚时间线罢了，相当于是阅读源码前的一个辅助</p>
<p>最后该部分以一图收尾，下图转载自<a href="https://blog.csdn.net/java_lyvee">路神</a>，其对博客的文章Spring 这一块的讲解比较深入</p>
<p><img src="/images/20191018151632339.jpg" alt="img"></p>
<p>总的来说，走完这一次流程后，可以了解IoC底层原理主要靠<strong>注解解析（xml）、工厂模式、反射</strong>实现</p>
<h1 id="二、AOP原理"><a href="#二、AOP原理" class="headerlink" title="二、AOP原理"></a>二、AOP原理</h1><p>即面向切面编程，可以对业务逻辑的各个部分进行隔离从而使业务的耦合度降低，提高程序可重用性和开发效率</p>
<p>我们如果把把功能分为<strong>核心业务功能</strong>，和<strong>周边功能</strong>。<br>所谓的核心业务，比如登陆，增加数据，删除数据都叫核心业务<br>所谓的周边功能，比如性能统计，日志，事务管理等等</p>
<p>周边功能在Spring的面向切面编程AOP思想里，即被定义为<strong>切面</strong></p>
<p>在面向切面编程AOP的思想里面，核心业务功能和切面功能分别<strong>独立进行开发</strong><br>然后把切面功能和核心业务功能 <strong>“编织”</strong> 在一起，这就叫AOP</p>
<p>其实和代理模式比较像，就是在不修改核心业务代码的前提下，增加其功能。</p>
<p>而其实，Spring的默认实现就采用的是<strong>动态代理</strong>。</p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>类似于在设计模式中的动态代理，使用<code>InvocationHandler</code>接口和<code>Proxy</code>类实现接口类，增强接口的功能</p>
<p>实例：</p>
<p>在电影院看电影除了电影，本身还会在电影放映前后插入广告。</p>
<p>希望用<strong>动态代理模式</strong>对电影的代理，并增加广告功能</p>
<ul>
<li><p>首先建立Movie抽象类，再建立其一个子类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Movie</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealMovie</span> <span class="keyword">implements</span> <span class="title">Movie</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RealMovie</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;正在播放&quot;</span>+name);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>InvocationHandler</code>实现类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Object proxied;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ProxyHandler</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">		proxied = obj;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;放映前插入广告&quot;</span>);</span><br><span class="line">		Object obj = method.invoke(proxied, args);</span><br><span class="line">		System.out.println(<span class="string">&quot;放映后插入广告&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> obj;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>客户端利用Proxy类生成实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Movie proxied = <span class="keyword">new</span> RealMovie(<span class="string">&quot;白蛇缘起&quot;</span>);</span><br><span class="line">		ProxyHandler handler = <span class="keyword">new</span> ProxyHandler(proxied);</span><br><span class="line">		Movie proxy =(Movie) Proxy.newProxyInstance(Movie.class.getClassLoader(),<span class="keyword">new</span> Class[] &#123;Movie.class&#125;, handler);</span><br><span class="line">		proxy.play();</span><br><span class="line">		System.out.println(proxy.getClass());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<p><img src="/images/image-20201010111924276.png" alt="image-20201010111924276"></p>
</li>
</ul>
<p>观察上诉案例，发现一个要求，要求增强的目标类是一个接口</p>
<p>实际上<strong>Spring默认的策略是如果需要增强目标类是接口，则使用JDK动态代理技术，否则使用Cglib来生成代理</strong></p>
<h2 id="Cglib"><a href="#Cglib" class="headerlink" title="Cglib"></a>Cglib</h2><p>CGLIB是一个强大的、高性能的代码生成库。其被广泛应用于AOP框架（Spring、dynaop）中，用以提供方法拦截操作。CGLIB相比于JDK动态代理更加强大，JDK动态代理虽然简单易用，但是其有一个致命缺陷是，只能对接口进行代理。如果要代理的类为一个普通类、没有接口，那么Java动态代理就没法使用了。</p>
<p>所以当Spring要代理的对象不是接口时，就采用Cglib进行代理，创建当前类子类的代理对象增强功能但是得注意，该类需要可以继承</p>
<p>CGLIB底层使用了ASM来操作字节码生成新的类，是一种字节码生成技术。</p>
<h1 id="三、Spring事务"><a href="#三、Spring事务" class="headerlink" title="三、Spring事务"></a>三、Spring事务</h1><h2 id="事务原理"><a href="#事务原理" class="headerlink" title="事务原理"></a>事务原理</h2><p>Spring的事务实际上和AOP和数据库有关，又可以说Spring事务是Spring AOP的最佳实践之一</p>
<p>一般来说，我们用JDBC使用事务时，有以下操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、获取连接 Connection con &#x3D; DriverManager.getConnection()</span><br><span class="line"></span><br><span class="line">2、开启事务con.setAutoCommit(true&#x2F;false);</span><br><span class="line"></span><br><span class="line">3、执行CRUD</span><br><span class="line"></span><br><span class="line">4、提交事务&#x2F;回滚事务 con.commit() &#x2F; con.rollback();</span><br><span class="line"></span><br><span class="line">5、关闭连接 conn.close();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>采用Spring 事务后，只需要关注第3步的实现，其他的步骤都是Spring 完成（准确的是事务切入的是2、4步）。</p>
<p>Spring事务的本质  其实就是 <strong>AOP和数据库对事务的支持</strong>，<strong>Spring 将数据库的事务操作提取为切面，通过AOP的方式增强事务方法。</strong></p>
<p>当一个方法被使用<code>@Transactional</code>注解后就会生成相应的代理类，增强该方法</p>
<p>最后注意一下Spring事务的回滚机制：<strong>当所拦截的方法有指定异常（不受检查的异常）抛出，事务才会自动进行回滚</strong>，当具体编码时，如果事务结果未满足具体业务需求，可以手动抛出异常回滚</p>
<h2 id="Spring事务隔离级别"><a href="#Spring事务隔离级别" class="headerlink" title="Spring事务隔离级别"></a>Spring事务隔离级别</h2><p>Spring的事务隔离级别和数据库的隔离级别是一回事，就是那四个</p>
<p><strong>READ_UNCOMMITTED （读未提交）</strong><br>这是事务最低的隔离级别，它允许另外一个事务可以看到这个事务未提交的数据。这种隔离级别会产生脏读，不可重复读和幻像读。</p>
<p><strong>READ_COMMITTED （读已提交）</strong><br>保证一个事务修改的数据提交后才能被另外一个事务读取，另外一个事务不能读取该事务未提交的数据。这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻像读。</p>
<p><strong>REPEATABLE_READ （可重复读）</strong><br>这种事务隔离级别可以防止脏读、不可重复读，但是可能出现幻读。它除了保证一个事务不能读取另一个事务未提交的数据外，还保证了不可重复读。</p>
<p><strong>SERIALIZABLE（串行化）</strong><br>这是花费最高代价但是最可靠的事务隔离级别，事务被处理为顺序执行。除了防止脏读、不可重复读外，还避免了幻读。</p>
<p>spring只是在此基础上抽象出一种隔离级别为<strong>default</strong>，表示以数据库默认配置的为主。例如，mysql默认的事务隔离级别为repeatable-read。而Oracle 默认隔离级别为读已提交。</p>
<p>并且如果数据库设置的隔离级别和Spring设置的隔离级别有冲突，将以Spring的为主，但如果spring设置的隔离级别数据库不支持，效果取决于数据库。</p>
<h2 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h2><p>事务的传播行为主要是指多个使用了<code>@Transactional</code>注解的方法互相调用时，Spring对事务的处理。</p>
<p>Spring 对事务传播有七个行为类型</p>
<p><strong>1.required</strong></p>
<p><code>如果当前有事务，则当前事务加入到当前层事务，一块提交，一块回滚。如果外层没有事务，新建一个事务执行</code></p>
<p>Spring的默认事务传播行为，也是最常见的事务传播行为</p>
<p>下面用字母代表方法、大写代表是事务方法、小写不是,B、C方法是在DAO层，事务传播行为为<code>required</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class XXXService&#123;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 1</span><br><span class="line">	A()&#123;</span><br><span class="line">	B();</span><br><span class="line">	C();</span><br><span class="line">	...</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F; 2</span><br><span class="line">	a()&#123;</span><br><span class="line">	B();</span><br><span class="line">	C();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>对1，BC方法加入到A的事务中，但凡BC中或者A中出现异常，所有事务将回滚</li>
<li>对2，B，C将各自新建一个事务，两者独立不影响</li>
</ul>
<p><strong>2.nested</strong></p>
<p><code>如果当前存在事务，支持嵌套事务，否则同required一致</code></p>
<p>嵌套事务一个非常重要的概念就是<strong>内层事务依赖于外层事务</strong>。外层事务失败时，会回滚内层事务所做的动作。而内层事务操作失败并不会引起外层事务的回滚。</p>
<p>即在上诉1案例中，BC异常不影响A，A异常会影响BC</p>
<p><strong>3.requires_new</strong><br><code>新建事务，如果当前存在事务，把当前事务挂起。</code></p>
<p>ABC相互独立</p>
<p><strong>即是外围事务和内部事务之间均独立</strong></p>
<p><strong>4.supports</strong></p>
<p><code>支持当前事务，如果当前没有事务，就以非事务方式执行（没有事务）</code></p>
<p>根据调用它的方法来决定是否有事务</p>
<p><strong>5.mandatory</strong></p>
<p><code>使用当前的事务，如果当前没有事务，就抛出异常</code></p>
<p>和4基本一致，但是没有事务即2中会抛出异常</p>
<p><strong>6.never</strong></p>
<p><code>以非事务方式运行，如果当前存在事务，抛出异常</code></p>
<p>1中抛出异常</p>
<p>2中没有事务</p>
<p><strong>7.not_supported</strong></p>
<p><code>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起</code></p>
<p>1中BC不是事务</p>
<p>2中没有事务</p>
<h2 id="事务同步器"><a href="#事务同步器" class="headerlink" title="事务同步器"></a>事务同步器</h2><p>Spring把JDBC 的 <code>Connection</code>或者<code>Hibernate</code>的<code>Session</code>等访问数据库的链接（会话）都统一称为资源，显然我们知道<code>Connection</code>这种是线程不安全的，同一时刻是不能被多个线程共享的。</p>
<p>我们需要同一时刻我们每个线程持有的Connection应该是独立的，且都是互不干扰和互不相同的</p>
<p>Spring里面有一个事务同步管理类<code>org.springframework.transaction.support.TransactionSynchronizationManager</code>来解决这个问题。它的做法是<strong>内部使用了很多的ThreadLocal为不同的事务线程提供了独立的资源副本，并同时维护这些事务的配置属性和运行状态信息</strong> （比如强大的事务嵌套、传播属性和这个强相关）。</p>
]]></content>
      <categories>
        <category>框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程</title>
    <url>/2021/05/07/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>了解Java网络编程基础知识，更适和同网络IO对照着看</p>
<a id="more"></a>

<h1 id="一、简单应用"><a href="#一、简单应用" class="headerlink" title="一、简单应用"></a>一、简单应用</h1><p>这里建立一个简单的服务端和客户端连接发送消息的程序</p>
<p><strong>Server</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>(ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8189</span>))&#123;</span><br><span class="line">            <span class="comment">// 该方法会阻塞直到有连接建立</span></span><br><span class="line">            Socket socket = serverSocket.accept();</span><br><span class="line">            InputStream inputStream = socket.getInputStream();</span><br><span class="line">            OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">            <span class="keyword">try</span> (Scanner in = <span class="keyword">new</span> Scanner(inputStream, String.valueOf(StandardCharsets.UTF_8))) &#123;</span><br><span class="line">                PrintWriter out = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> OutputStreamWriter(outputStream,StandardCharsets.UTF_8),<span class="keyword">true</span>);</span><br><span class="line">                out.println(<span class="string">&quot;服务器： 连接已经成功建立,输入exit退出&quot;</span>);</span><br><span class="line">                <span class="keyword">boolean</span> isconnected = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">while</span>(isconnected &amp;&amp; in.hasNextLine())&#123;</span><br><span class="line">                    String line = in.nextLine();</span><br><span class="line">                    out.println(<span class="string">&quot;服务器： &quot;</span>+line);</span><br><span class="line">                    <span class="keyword">if</span>(line.trim().equals(<span class="string">&quot;exit&quot;</span>))</span><br><span class="line">                        isconnected = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Client</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8189</span>)) &#123;</span><br><span class="line">            InputStream inputStream = socket.getInputStream();</span><br><span class="line">            OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">            <span class="keyword">try</span> (Scanner in = <span class="keyword">new</span> Scanner(inputStream, String.valueOf(StandardCharsets.UTF_8)))&#123;</span><br><span class="line">                Scanner sin = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">                PrintWriter out = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> OutputStreamWriter(outputStream,StandardCharsets.UTF_8),<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(in.hasNextLine())&#123;</span><br><span class="line">                    String line = in.nextLine();</span><br><span class="line">                    System.out.println(line);</span><br><span class="line">                    String msg = sin.nextLine();</span><br><span class="line">                    out.println(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先运行服务器再运行客户端结果如下：</p>
<p><img src="/images/image-20210513101935327.png" alt="image-20210513101935327"></p>
<p>socket可以用来实现两个不同程序间地方通信</p>
<h1 id="二、BIO服务器模型"><a href="#二、BIO服务器模型" class="headerlink" title="二、BIO服务器模型"></a>二、BIO服务器模型</h1><p>socket可以是阻塞的也可以是非阻塞的，上节利用阻塞的socket建立了一个简单连接，但是显然该服务器哪怕是加了while循环都难于处理高并发情况，因为其需要等待一个连接完全关闭才会到下一个socket连接，针对这种情况，可以采用多线程模型提高并发量，防止进程阻塞</p>
<p>最早的思路是每一个socket连接到来，开辟一个线程处理该连接</p>
<h2 id="一个线程一个服务"><a href="#一个线程一个服务" class="headerlink" title="一个线程一个服务"></a>一个线程一个服务</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleBIOServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8189</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;step1: listen 8189&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                Socket client = server.accept();</span><br><span class="line">                System.out.println(<span class="string">&quot;step2: client &quot;</span> + client.getPort());</span><br><span class="line">                <span class="keyword">new</span> Thread(</span><br><span class="line">                        ()-&gt;&#123;</span><br><span class="line">                            System.out.println(++num);</span><br><span class="line">                        &#125;</span><br><span class="line">                ).start();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单测试吞吐量是450/sec</p>
<h2 id="线程池复用"><a href="#线程池复用" class="headerlink" title="线程池复用"></a>线程池复用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleBIOServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8189</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;step1: listen 8189&quot;</span>);</span><br><span class="line"></span><br><span class="line">            ExecutorService threadPool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>,<span class="number">5</span>,<span class="number">0</span>, TimeUnit.SECONDS,<span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1000</span>));</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                Socket client = server.accept();</span><br><span class="line">                System.out.println(<span class="string">&quot;step2: client &quot;</span> + client.getPort());</span><br><span class="line"></span><br><span class="line">                Runnable task = ()-&gt;&#123;</span><br><span class="line">                    System.out.println(++num);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        client.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                threadPool.execute(task);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程池复用后,简单测试得吞吐量为600/sec</p>
<h1 id="三、NIO"><a href="#三、NIO" class="headerlink" title="三、NIO"></a>三、NIO</h1><h2 id="JavaNIO"><a href="#JavaNIO" class="headerlink" title="JavaNIO"></a>JavaNIO</h2><h2 id="Reactor实现"><a href="#Reactor实现" class="headerlink" title="Reactor实现"></a>Reactor实现</h2>]]></content>
      <categories>
        <category>Java语法</category>
        <category>进阶</category>
      </categories>
      <tags>
        <tag>网络IO</tag>
      </tags>
  </entry>
  <entry>
    <title>LFU算法</title>
    <url>/2021/05/09/LFU%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>在LRU的基础上更近一步实现LFU</p>
<a id="more"></a>

<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p><a href="https://leetcode-cn.com/problems/lfu-cache/">力扣链接</a></p>
<p>请你为 <a href="https://baike.baidu.com/item/%E7%BC%93%E5%AD%98%E7%AE%97%E6%B3%95">最不经常使用（LFU）</a>缓存算法设计并实现数据结构。</p>
<p>实现 <code>LFUCache</code> 类：</p>
<ul>
<li><code>LFUCache(int capacity)</code> - 用数据结构的容量 <code>capacity</code> 初始化对象</li>
<li><code>int get(int key)</code> - 如果键存在于缓存中，则获取键的值，否则返回 -1。</li>
<li><code>void put(int key, int value)</code> - 如果键已存在，则变更其值；如果键不存在，请插入键值对。当缓存达到其容量时，则应该在插入新项之前，使最不经常使用的项无效。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 <strong>最近最久未使用</strong> 的键。</li>
</ul>
<p><strong>注意</strong>「项的使用次数」就是自插入该项以来对其调用 <code>get</code> 和 <code>put</code> 函数的次数之和。使用次数会在对应项被移除后置为 0 。</p>
<p>为了确定最不常使用的键，可以为缓存中的每个键维护一个 <strong>使用计数器</strong> 。使用计数最小的键是最久未使用的键。</p>
<p>当一个键首次插入到缓存中时，它的使用计数器被设置为 <code>1</code> (由于 put 操作)。对缓存中的键执行 <code>get</code> 或 <code>put</code> 操作，使用计数器的值将会递增。</p>
<h1 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h1><p>显然题意在删除元素时会删除<strong>最低频率最近最少未使用</strong>的键</p>
<p>其中<strong>最近最少未使用</strong>是LRU，之前我们的实现是用一个双向队列+HashMap实现，这里涉及到不同频率，我们可以考虑为不同频率维护不同的双向队列（HashMap），同时维护一个当前最小频率，可以直接找到要删除的双端队列</p>
<p>关键的get、put方法思路如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">get(int key)&#123;</span><br><span class="line">	缓存中没有返回-1</span><br><span class="line">	有</span><br><span class="line">	首先先更新其出现频率到对于频率的队列</span><br><span class="line">	然后判段当前最短频率是否因此改变</span><br><span class="line">	最后返回对应值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">put(int key,int value)&#123;</span><br><span class="line">	缓存中没有&#123;</span><br><span class="line">		插入到队列</span><br><span class="line">		最小频率更新为1</span><br><span class="line">		判断是否删除最老值</span><br><span class="line">	&#125;</span><br><span class="line">	缓存中有&#123;</span><br><span class="line">		首先先更新其出现频率到对于频率的队列</span><br><span class="line">	    然后判段当前最短频率是否因此改变	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据上述思路，我们可以抽象出几个函数，提高代码复用</p>
<ul>
<li>插入值函数</li>
<li>更新最小频率函数</li>
<li>更新值频率函数</li>
<li>删除最老值函数</li>
</ul>
<p>最低一层的抽象涉及到对双向链表的插入和删除，注意插入时我们默认把最新元素插入到队列头，所以可以有以下两个函数</p>
<ul>
<li>节点插入到队列头函数</li>
<li>删除元素操作</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>最终Java代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span> </span>&#123;</span><br><span class="line">    <span class="comment">// key-vaue</span></span><br><span class="line">    Map&lt;Integer,Node&gt; cache;</span><br><span class="line">    <span class="comment">// count-list</span></span><br><span class="line">    Map&lt;Integer,Node[]&gt; lists;</span><br><span class="line">    <span class="keyword">int</span> minCount;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LFUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        cache = <span class="keyword">new</span> HashMap&lt;&gt;(capacity);</span><br><span class="line">        lists = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        minCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!cache.containsKey(key))</span><br><span class="line">            <span class="keyword">return</span> - <span class="number">1</span>;</span><br><span class="line">        Node cur = cache.get(key);</span><br><span class="line">        <span class="keyword">int</span> oldCount = cur.count;</span><br><span class="line">        updateByCount(cur);</span><br><span class="line">        <span class="keyword">if</span>(oldCount == minCount)</span><br><span class="line">            updateMinCount();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cur.value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(capacity == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        Node cur ;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!cache.containsKey(key))&#123;</span><br><span class="line">            <span class="keyword">if</span>(size == capacity)</span><br><span class="line">                removeOldest();</span><br><span class="line">            minCount = <span class="number">1</span>;</span><br><span class="line">            cur = <span class="keyword">new</span> Node(key,value,<span class="number">1</span>);</span><br><span class="line">            insertByCount(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cur = cache.get(key);</span><br><span class="line">            cur.value = value;</span><br><span class="line">            <span class="keyword">int</span> oldCount = cur.count;</span><br><span class="line">            updateByCount(cur);</span><br><span class="line">            <span class="keyword">if</span>(oldCount == minCount)</span><br><span class="line">                updateMinCount();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateMinCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Node[] arr = lists.get(minCount);</span><br><span class="line">        <span class="keyword">if</span>(arr[<span class="number">0</span>].next == arr[<span class="number">1</span>])</span><br><span class="line">            minCount++;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertByCount</span><span class="params">(Node cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> newCount = cur.count;</span><br><span class="line">        Node first;</span><br><span class="line">        Node last;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 双向链表初始化</span></span><br><span class="line">        <span class="keyword">if</span>(!lists.containsKey(newCount))&#123;</span><br><span class="line">            first = <span class="keyword">new</span> Node();</span><br><span class="line">            last = <span class="keyword">new</span> Node();</span><br><span class="line">            first.next = last;</span><br><span class="line">            last.pre = first;</span><br><span class="line">            lists.put(newCount,<span class="keyword">new</span> Node[]&#123;first,last&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            Node[] arr= lists.get(newCount);</span><br><span class="line">            first = arr[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        addFirst(cur,first);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateByCount</span><span class="params">(Node cur)</span></span>&#123;</span><br><span class="line">        remove(cur);</span><br><span class="line">        cur.count++;</span><br><span class="line">        insertByCount(cur);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">removeOldest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Node[] arr = lists.get(minCount);</span><br><span class="line">        Node cur = arr[<span class="number">1</span>].pre;</span><br><span class="line">        remove(cur);</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        Node pre;</span><br><span class="line">        Node next;</span><br><span class="line">        Node()&#123;&#125;;</span><br><span class="line">        Node(<span class="keyword">int</span> key, <span class="keyword">int</span> value, <span class="keyword">int</span> count)&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.count = count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">remove</span><span class="params">(Node cur)</span></span>&#123;</span><br><span class="line">        cur.next.pre = cur.pre;</span><br><span class="line">        cur.pre.next = cur.next;</span><br><span class="line">        size--;</span><br><span class="line">        cache.remove(cur.key);</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(Node cur, Node first)</span></span>&#123;</span><br><span class="line">        cur.next = first.next;</span><br><span class="line">        first.next.pre = cur;</span><br><span class="line">        first.next = cur;</span><br><span class="line">        cur.pre = first;</span><br><span class="line">        size++;</span><br><span class="line">        cache.put(cur.key,cur);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中Node[]大小为2包含头尾节点就相当于一个双向队列，这里也可以再做一层封装，成为一个DoubleList类</p>
<p>其次size这个元素可以不用维护，可以通过cache的size来判断，我这里没有修改</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>经典算法</category>
      </categories>
      <tags>
        <tag>LFU</tag>
      </tags>
  </entry>
  <entry>
    <title>LRU算法</title>
    <url>/2021/05/08/LRU%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>自己实现一个LRU以及利用JDK实现LRU</p>
<a id="more"></a>

<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a><strong>思路</strong></h1><p>LRU即<strong>最近最少使用</strong>，是一个经典的页面调度算法，在一定容量的缓存中也被经常使用，保证缓存的数据是热点数据，其大致思路如下：</p>
<p>LRU会删除最近最少使用的项目。缓存应该从键映射到值(允许你插入和检索特定键对应的值)，并在初始化时指定最大容量。当缓存被填满时，它应该删除最近最少使用的项目。</p>
<p>首先LRU算法涉及到频繁的插入和删除，可以考虑用内部用双向链表存储这些节点（方便查找前驱）</p>
<p>其次为了尽快得到缓存的键值映射，而不是遍历整个链表，有可以考虑用一个Map维护key和对应的链表节点，这样也便于得到链表节点对双向链表进行操作</p>
<h1 id="方案一：链表-Map"><a href="#方案一：链表-Map" class="headerlink" title="方案一：链表+Map"></a>方案一：链表+Map</h1><p>首先定义一个内部链表节点类，注意定义为<code>static</code>、减少持有外部类的引用消耗</p>
<p>其次思考对链表涉及到的操作</p>
<ul>
<li>插入最新节点，那应该有addFirst API</li>
<li>删除最老节点，那应该有removeLast API</li>
<li>当一个缓存更新时，涉及到删除其旧位置并更新到最新的操作，那应该还要增加一个remove功能</li>
</ul>
<p>最后LRU应该维护一个size变量，便于判断缓存是否溢出</p>
<p>设计完这些功能操作细节后，在来编写LRU的核心get、put功能，注意逻辑即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer,Node&gt; map;</span><br><span class="line">    <span class="keyword">private</span> Node first;</span><br><span class="line">    <span class="keyword">private</span> Node last;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;(capacity);</span><br><span class="line">        first = <span class="keyword">new</span> Node();</span><br><span class="line">        last = <span class="keyword">new</span> Node();</span><br><span class="line">        first.next = last;</span><br><span class="line">        last.pre = first;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(key))</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        Node cur = map.get(key);</span><br><span class="line">        remove(cur);</span><br><span class="line">        addFirst(cur);</span><br><span class="line">        <span class="keyword">return</span> cur.value;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            Node cur = <span class="keyword">new</span> Node(key,value);</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(key))&#123;</span><br><span class="line">                cur = map.get(key);</span><br><span class="line">                remove(cur);</span><br><span class="line">            &#125;</span><br><span class="line">            cur.value = value;</span><br><span class="line">            <span class="comment">// 删除缓存和老节点</span></span><br><span class="line">            <span class="keyword">if</span>(size == capacity)&#123;       </span><br><span class="line">                Node temp = removeLast();</span><br><span class="line">                map.remove(temp.key);</span><br><span class="line">                &#125;</span><br><span class="line">            addFirst(cur);</span><br><span class="line">            map.put(key,cur);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">remove</span><span class="params">(Node cur)</span></span>&#123;</span><br><span class="line">        cur.next.pre = cur.pre;</span><br><span class="line">        cur.pre.next = cur.next;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(Node cur)</span></span>&#123;</span><br><span class="line">        cur.next = first.next;</span><br><span class="line">        first.next.pre = cur;</span><br><span class="line">        first.next = cur;</span><br><span class="line">        cur.pre = first;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  Node <span class="title">removeLast</span><span class="params">()</span></span>&#123;</span><br><span class="line">           <span class="keyword">return</span> remove(last.pre);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  链表节点类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        Node pre;</span><br><span class="line">        Node next;</span><br><span class="line"></span><br><span class="line">        Node()&#123;&#125;</span><br><span class="line">        Node(<span class="keyword">int</span> key ,<span class="keyword">int</span> value)&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;     </span><br><span class="line">        Node(<span class="keyword">int</span> key ,<span class="keyword">int</span> value, Node pre ,Node next)&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.pre = pre;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="方案二：LinkedHashMap"><a href="#方案二：LinkedHashMap" class="headerlink" title="方案二：LinkedHashMap"></a>方案二：LinkedHashMap</h1><p>LinkedHashMap有这样一个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Returns:true if the eldest entry should be removed from the map; false if it should be retained.</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>该方法可以继承，在调用map的put或putAll方法时，其调用该方法判断是否为true来决定是否删除最老的节点，一般默认是不删除，所以表现得像正常的map</p>
<p>于是我们可以重写该方法从而实现LRU</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">Integer</span>, <span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(capacity, <span class="number">0.75F</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getOrDefault(key, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;Integer, Integer&gt; eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; capacity; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>算法</category>
        <category>经典算法</category>
      </categories>
      <tags>
        <tag>LRU</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树的增删查改</title>
    <url>/2021/05/10/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9/</url>
    <content><![CDATA[<p>二叉搜索树的小专题，学会对二叉搜索树进行简单的增删查改</p>
<a id="more"></a>

<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><p>设计到二叉搜索树，和普通的二叉树的遍历模板有些区别，实际上，二叉树搜索树的模板更像是二分查找的模板，这样才能更好发挥其性质</p>
<p>下面是其模板</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BST</span><span class="params">(TreeNode root,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root.val == target)&#123;</span><br><span class="line">		<span class="comment">//对找到的目标进行操作</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(root.val &gt; target)</span><br><span class="line">		BST(root.left,target);</span><br><span class="line">	<span class="keyword">if</span>(root.val &lt; target)</span><br><span class="line">		BST(root.right,target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总体来说，二叉搜索树的时间复杂度要求是O(h)</p>
<h1 id="查"><a href="#查" class="headerlink" title="查"></a>查</h1><p><strong>题目</strong></p>
<p><a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/">力扣链接</a></p>
<p>给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。</p>
<p><strong>思考</strong></p>
<p>在二叉搜索树中的查找，大多要求时间复杂度是O(h),主要利用了二叉搜索树的性质</p>
<ul>
<li>结点左子树的值都比结点值小</li>
<li>结点右子树的值都比结点值大</li>
</ul>
<p>由此套用上诉模板可以写出该题代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">searchBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.val == val)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(root .val &gt; val)</span><br><span class="line">            <span class="keyword">return</span> searchBST(root.left,val);</span><br><span class="line">        <span class="keyword">if</span>(root .val &lt; val)</span><br><span class="line">            <span class="keyword">return</span> searchBST(root.right,val);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>标准的二叉搜索树查找</p>
<h1 id="增"><a href="#增" class="headerlink" title="增"></a>增</h1><p><strong>题目</strong></p>
<p><a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/">力扣链接</a></p>
<p>给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证，新值和原始二叉搜索树中的任意节点值都不同。</p>
<p>可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。</p>
<p> <strong>思考</strong></p>
<p>插入新结点确实有多种方式，最不容易破坏树结构的，是插入节点作为叶子节点，找到适合的位置插入，几乎不改变原来树的节点关系，实际上是套用查找的那一套，这里找到适合的位置后，需要进行增加节点操作</p>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">insertIntoBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里的root == null就是找到了</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; val)</span><br><span class="line">            root.right = insertIntoBST(root.right,val);</span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; val)</span><br><span class="line">            root.left = insertIntoBST(root.left,val);</span><br><span class="line">        <span class="keyword">return</span> root;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="删"><a href="#删" class="headerlink" title="删"></a>删</h1><p><strong>题目</strong></p>
<p><a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/">力扣链接</a></p>
<p>给定一个二叉搜索树的根节点 <strong>root</strong> 和一个值 <strong>key</strong>，删除二叉搜索树中的 <strong>key</strong> 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p>
<p>一般来说，删除节点可分为两个步骤：</p>
<ol>
<li>首先找到需要删除的节点；</li>
<li>如果找到了，删除它。</li>
</ol>
<p><strong>说明：</strong> 要求算法时间复杂度为 O(h)，h 为树的高度。</p>
<p><strong>思路</strong></p>
<p>二叉搜索树的删除步骤比较复杂，但是正如题目所述，步骤可以拆分</p>
<ul>
<li>首先找到该删除的节点</li>
<li>根据节点情况进行删除：<ul>
<li>如果节点是叶子节点直接删除</li>
<li>如果节点只有左右子树之一，那样删除该节点后就用子树代替该节点位置，不会破坏二叉树的结构</li>
<li>如果节点有左右子树，也是最复杂的情况，要使改变最小，就得从左子树中选取最大的值或者右子树中选取最小的值来替代该节点的位置</li>
</ul>
</li>
</ul>
<p>考虑清楚后，依旧套用模板先填出<strong>查找</strong>框架</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deleteNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root  == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.val == key)&#123;</span><br><span class="line">          	三种情况讨论，涉及具体操作</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root.val &gt; key)&#123;</span><br><span class="line">            root.left = deleteNode(root.left,key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root.val &lt; key)</span><br><span class="line">            root.right = deleteNode(root.right,key);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>找到对应节点之后，根据节点情况进行<strong>删除</strong>，最后将具体操作的思路填充完整</p>
<p>这里左右子树存在采用就找右子树最小的的思路，最终代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deleteNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root  == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 找到的删除情况</span></span><br><span class="line">        <span class="keyword">if</span>(root.val == key)&#123;</span><br><span class="line">            <span class="comment">// 前两个判断包含1,2情况</span></span><br><span class="line">            <span class="keyword">if</span>(root.left == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> root.right;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(root.right == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> root.left;</span><br><span class="line">            <span class="comment">// 左右子树存在情况</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                TreeNode min = getMin(root.right);</span><br><span class="line">                root.val = min.val;</span><br><span class="line">                root.right = deleteNode(root.right,min.val);</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root.val &gt; key)&#123;</span><br><span class="line">            root.left = deleteNode(root.left,key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root.val &lt; key)</span><br><span class="line">            root.right = deleteNode(root.right,key);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">getMin</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">return</span> getMin(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="改"><a href="#改" class="headerlink" title="改"></a><strong>改</strong></h1><p><strong>题目</strong></p>
<p><a href="https://leetcode-cn.com/problems/trim-a-binary-search-tree/">力扣链接</a></p>
<p>给你二叉搜索树的根节点 <code>root</code> ，同时给定最小边界<code>low</code> 和最大边界 <code>high</code>。通过修剪二叉搜索树，使得所有节点的值在<code>[low, high]</code>中。修剪树不应该改变保留在树中的元素的相对结构（即，如果没有被移除，原有的父代子代关系都应当保留）。 可以证明，存在唯一的答案。</p>
<p>所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。</p>
<p><strong>思路</strong></p>
<p>依旧是查找的思路，只是查找的节点值要求在<code>[low, high]</code>中，我们继续套用模板</p>
<p>如果找到了这样的root，我们就对以其为根节点对其左右子树进行同样的操作</p>
<p>否则就去其左子树或者右子树进行继续查找</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">trimBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root.val &lt;= high &amp;&amp; root.val &gt;= low)&#123;</span><br><span class="line">            root.right = trimBST(root.right,low,high);</span><br><span class="line">            root.left = trimBST(root.left,low,high);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root.val &lt; low)</span><br><span class="line">            <span class="keyword">return</span> trimBST(root.right,low,high);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root.val &gt; high)</span><br><span class="line">            <span class="keyword">return</span> trimBST(root.left,low,high);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>二叉搜索树的模板是一个递归模板，主要概述就是两步</p>
<p><strong>找值</strong></p>
<p><strong>操作</strong></p>
<p>按照模板的找值，找到了再思考对其该进行怎样的操作，可以帮我我们减少思考递归的细节，只要操作对了基本结果也就对了</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>二叉搜索树</category>
      </categories>
      <tags>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title>树的最近祖先问题</title>
    <url>/2021/05/13/%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E7%A5%96%E5%85%88%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>树的最近祖先问题，涉及到对二叉树的后序遍历的巧妙应用</p>
<a id="more"></a>

<h1 id="基础问题"><a href="#基础问题" class="headerlink" title="基础问题"></a>基础问题</h1><p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">力扣链接</a></p>
<p><strong>二叉树的最近公共祖先</strong></p>
<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<ul>
<li>树中节点数目在范围 <code>[2, 105]</code> 内。</li>
<li><code>-109 &lt;= Node.val &lt;= 109</code></li>
<li>所有 <code>Node.val</code> <code>互不相同</code> 。</li>
<li><code>p != q</code></li>
<li><code>p</code> 和 <code>q</code> 均存在于给定的二叉树中。</li>
</ul>
<h1 id="两个思路"><a href="#两个思路" class="headerlink" title="两个思路"></a>两个思路</h1><h2 id="思路一：记录节点父路径比较法"><a href="#思路一：记录节点父路径比较法" class="headerlink" title="思路一：记录节点父路径比较法"></a>思路一：记录节点父路径比较法</h2><p>类似于求两个链表的第一个公共子节点，我们记录下两个节点的祖先路径，视为链表，从后向前寻找第一个相同节点即为最近公共父节点</p>
<p>至于记录路径，我们可以用中序遍历实现</p>
<p>最终代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	 <span class="keyword">boolean</span> isfind = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	 <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; max = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        dfs(root,p,max);</span><br><span class="line">        isfind = <span class="keyword">false</span>;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; min = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        dfs(root,q,min);</span><br><span class="line">         </span><br><span class="line">         </span><br><span class="line">        <span class="keyword">if</span>(min.size() &gt; max.size())&#123;</span><br><span class="line">            LinkedList&lt;TreeNode&gt; temp = min;</span><br><span class="line">            min = max;</span><br><span class="line">            max = temp;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">// 寻找最近公共父节点逻辑</span></span><br><span class="line">        <span class="keyword">while</span>(max.size() &gt; min.size())</span><br><span class="line">            max.removeLast();</span><br><span class="line">        <span class="keyword">while</span>(!max.isEmpty())&#123;</span><br><span class="line">            TreeNode t1 = max.removeLast();</span><br><span class="line">            TreeNode t2 = min.removeLast();</span><br><span class="line">            <span class="keyword">if</span>(t1 == t2)</span><br><span class="line">                <span class="keyword">return</span> t1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 路径打印</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">( TreeNode root,TreeNode target,LinkedList&lt;TreeNode&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        list.add(root);</span><br><span class="line">        <span class="keyword">if</span>(root == target)</span><br><span class="line">            isfind = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(isfind)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        dfs(root.left,target,list);</span><br><span class="line">        <span class="keyword">if</span>(isfind)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        dfs(root.right,target,list);</span><br><span class="line">        <span class="keyword">if</span>(isfind)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        list.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="思路二：利用后序遍历性质"><a href="#思路二：利用后序遍历性质" class="headerlink" title="思路二：利用后序遍历性质"></a>思路二：利用后序遍历性质</h2><p><strong>递归解法一</strong></p>
<p>递归解法一思路比较简洁，但是在书写上为了剪枝的话判断语句过于累赘</p>
<p>我们用两个指针记录p，q的父亲节点，由于采用的是后序遍历，如果某节点是p，q祖先，此时p、q必定遍历到。我们比较这两个父节点，直到某一层其相等，之后某一层都返回，第一次相等时记录下的父节点既是最近公共祖先</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"> 	TreeNode pfather,qfather;</span><br><span class="line">	 <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">//一旦找到公共祖先即返回，这里起剪枝作用</span></span><br><span class="line">        <span class="keyword">if</span>(pfather !=<span class="keyword">null</span> &amp;&amp; pfather == qfather)</span><br><span class="line">            <span class="keyword">return</span> pfather;</span><br><span class="line">         </span><br><span class="line">        lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        lowestCommonAncestor(root.right,p,q);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//标准后序遍历操作位置</span></span><br><span class="line">        <span class="keyword">if</span>(pfather !=<span class="keyword">null</span> &amp;&amp; pfather == qfather)</span><br><span class="line">            <span class="keyword">return</span> pfather;  </span><br><span class="line">        <span class="comment">// 更新p的祖先</span></span><br><span class="line">        <span class="keyword">if</span>(root == p || (pfather != <span class="keyword">null</span> &amp;&amp; (root.left == pfather || root.right == pfather)))</span><br><span class="line">            pfather = root; </span><br><span class="line">        <span class="comment">// 更新q的祖先</span></span><br><span class="line">        <span class="keyword">if</span>(root == q || (qfather != <span class="keyword">null</span> &amp;&amp; (root.left == qfather || root.right == qfather)))</span><br><span class="line">            qfather = root;</span><br><span class="line">        <span class="keyword">return</span> pfather;</span><br><span class="line">	    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>递归解法二</strong></p>
<p>第二种递归解法有个前提在于该题一定存在解，<strong>即两个节点在树中</strong></p>
<p>关于root、p、q</p>
<ul>
<li><p>如果root == null 无解</p>
</li>
<li><p>如果root == p或q，其子树肯定包含另一个节点，所以root是最近祖先</p>
</li>
<li><p>否则则观察左右子树的递归返回值记left和right</p>
<ul>
<li>如果其中如果left或right其中一返回值为空说明最近公共祖先在另一颗子树上</li>
<li>都不为空，则还是说明该root节点是最近公共祖先</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 如果树为空，直接返回null</span></span><br><span class="line">        <span class="keyword">if</span>(root == p || root == q) <span class="keyword">return</span> root; </span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left, p, q); </span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right, p, </span><br><span class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span>) <span class="keyword">return</span> right; <span class="comment">// 如果在左子树中 p和 q都找不到，则 p和 q一定都在右子树中，右子树中先遍历到的那个就是最近公共祖先</span></span><br><span class="line">                                              </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(right == <span class="keyword">null</span>) <span class="keyword">return</span> left; <span class="comment">//同理</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> root; <span class="comment">//当 left和 right均不为空时，说明 p、q节点分别在 root异侧, 最近公共祖先即为 root</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="题目变形"><a href="#题目变形" class="headerlink" title="题目变形"></a>题目变形</h1><h2 id="变形一：不保证两个节点存在"><a href="#变形一：不保证两个节点存在" class="headerlink" title="变形一：不保证两个节点存在"></a>变形一：不保证两个节点存在</h2><p>实际上该变形仅仅会影响递归解法二，最简单的思路是在开一个函数判断节点是否存在树中</p>
<h2 id="变形二：不给出根节点"><a href="#变形二：不给出根节点" class="headerlink" title="变形二：不给出根节点"></a>变形二：不给出根节点</h2><p>只给出两个节点，不给出根节点，但节点里存储着父节点</p>
<p>显然这个时候采用方法一的思路更为快捷</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>二叉树遍历</category>
      </categories>
      <tags>
        <tag>后序遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>NIO</title>
    <url>/2021/05/14/NIO/</url>
    <content><![CDATA[<p>了解Java NIO和传统BIO的区别以及使用</p>
<a id="more"></a>

<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>NIO主要有三大核心部分：Channel(通道)，Buffer(缓冲区), Selector。传统IO基于字节流和字符流进行操作，而NIO基于Channel和Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector(选择区)用于监听多个通道的事件。下图可以完整体现通道和缓冲区的关系：</p>
<p><img src="/images/image-20210514155321106.png" alt="image-20210514155321106"></p>
<p>对于<strong>传统IO</strong>有两个层次InputStream、Reader分别处理字节流和字符流，每次从流中读一个或多个字节（字符），直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。最重要的是，传统IO的各种流是<strong>阻塞</strong>的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。</p>
<p>而<strong>NIO</strong>的缓冲导向方法略有不同。数据读取到一个它稍后处理的<strong>缓冲区</strong>，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。NIO存在<strong>非阻塞模式</strong>，在此模式下的读，当一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，一个单独的线程现在可以<strong>管理多个输入和输出通道</strong></p>
<h1 id="一、Channel和Buffer"><a href="#一、Channel和Buffer" class="headerlink" title="一、Channel和Buffer"></a>一、Channel和Buffer</h1><h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>实际上Channel和传统IO之间的流基本是一个层级，区别在于NIO中对Channel操作时加了Buffer一层抽象，先对Buffer操作，再将操作从Buffer传递到Channel。此外，还有一点，Channel是双向的，对一个Channel即可读又可以写</p>
<p>Java NIO 中常见 Channel实现如下：</p>
<ul>
<li>FileChannel，对文件进行IO操作</li>
<li>DatagramChannel，对UDP进行IO操作</li>
<li>SocketChannel，对TCP进行IO操作</li>
<li>ServerSocketChannel，对TCP进行IO操作</li>
</ul>
<p>前者可以称为<strong>本地IO</strong>，其中后三者就是<strong>网络IO</strong>，可以转化为<strong>非阻塞模式</strong></p>
<p><strong>1.channel生成</strong></p>
<p>对于FileChannel，Java 针对支持通道的类提供了 getChannel() 方法，也有静态open方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileInputStream/FileOutputStream</span><br><span class="line">RandomAccessFile</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例子</span></span><br><span class="line">FileChannel fileChannel = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;src/nio.txt&quot;</span>).getChannel();</span><br></pre></td></tr></table></figure>
<p>对于网络IO，可以用工厂静态open方法获取，再进行一些参数设置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServerSocketChannel listenerChannel = ServerSocketChannel.open();</span><br><span class="line">		<span class="comment">// 与本地端口绑定</span></span><br><span class="line">		listenerChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(ListenPort));</span><br><span class="line">		<span class="comment">// 设置为非阻塞模式</span></span><br><span class="line">		listenerChannel.configureBlocking(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>
<p><strong>2.channel操作</strong></p>
<p>channel和buffer,主要<strong>通过read和write向channel读取或者向channel写</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(ByteBuffer dst)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">(ByteBuffer[] dsts, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">(ByteBuffer[] dsts)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> read(dsts, <span class="number">0</span>, dsts.length);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">write</span><span class="params">(ByteBuffer src)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">write</span><span class="params">(ByteBuffer[] srcs, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">write</span><span class="params">(ByteBuffer[] srcs)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> write(srcs, <span class="number">0</span>, srcs.length);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>channel之间数据传输，可以通过<code>transferFrom()、transferTo()</code>进行操作</p>
<h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><p>Buffer顾名思义：缓冲区，实际上是一个容器，一个连续数组。Channel提供从文件、网络读取数据的渠道，但是读写的数据都必须经过Buffer</p>
<p>对buffer进行操作首先要分配空间，在进行具体操作，这里用到<strong>allocate()</strong></p>
<p>然后就是通常意义的<strong>读写操作</strong></p>
<p>向Buffer中读写数据：</p>
<ul>
<li>从Channel写到Buffer (channel.read(buf))</li>
<li>通过Buffer的put()方法 （buf.put(…)）</li>
</ul>
<p>从Buffer中读取数据：</p>
<ul>
<li><p>从Buffer读取到Channel (channel.write(buf))</p>
</li>
<li><p>使用get()方法从Buffer中读取数据 （buf.get()）</p>
</li>
</ul>
<p>前面说到Buffer操作相对于流操作有更多的<strong>灵活性</strong>，灵活性主要由下体现：</p>
<p>buffer过几个变量来保存这个数据的当前位置状态：capacity, position, limit, mark</p>
<ul>
<li><p>capacity，缓冲区数组的总长度</p>
</li>
<li><p>position，下一个要操作的数据元素的位置</p>
</li>
<li><p>limit，缓冲区数组中不可操作的下一个元素的位置：limit&lt;=capacity</p>
</li>
<li><p>mark，用于记录当前position的前一个位置或者默认是-1</p>
</li>
</ul>
<p>针对这些变量可以和一些方法相对应：</p>
<p>ByteBuffer.allocate(len)方法创建了一个len个byte的数组的缓冲区position的位置为0，capacity和limit默认都是数组长度。</p>
<p>当buf读入5字节数据时，position =  5，其他值不变</p>
<p>这时我们想要读取buf的数据，需要调用**buf.flip()**方法，令limit = position = 5 ，position设回0</p>
<p>可以说<strong>postion-limit要么是可以写的空间范围，要么是可以读的空间范围</strong></p>
<p>**buf.clear()**：position将被设回0，limit设置成capacity，相当于是buffer清空</p>
<p>**compact()**：compact()方法将所有未读的数据拷贝到Buffer起始处。然后将position设到最后一个未读元素正后面。limit属性依然像clear()方法一样，设置成capacity。现在Buffer准备好写数据了，但是不会覆盖未读的数据。</p>
<p><strong>mark()**：可以标记Buffer中的一个特定的position，之后可以通过调用</strong>reset()<strong>方法恢复到这个position。</strong>rewind()**：将position设回0，limit保持不变，所以你可以重读Buffer中的所有数据。</p>
<p>实际上上诉方法是和buffer的读写相关的，用flip是为了读，是向buffer写到读的切换，用clear或者compact，说明接下来需要向buffer写了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOLearn</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (FileChannel fileChannel = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;src/nio.txt&quot;</span>).getChannel()) &#123;</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">int</span> isread = fileChannel.read(buffer);</span><br><span class="line">            <span class="keyword">while</span>(isread != -<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">// 写读切换</span></span><br><span class="line">                buffer.flip();</span><br><span class="line">                <span class="keyword">while</span>(buffer.hasRemaining())</span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.print((<span class="keyword">char</span>)buffer.get());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 读写切换</span></span><br><span class="line">                buffer.clear();</span><br><span class="line">                isread = fileChannel.read(buffer);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二、Selector"><a href="#二、Selector" class="headerlink" title="二、Selector"></a>二、Selector</h1><p>Selector（选择器）是Java NIO中能够检测一到多个NIO通道，并能够知晓通道是否为诸如读写事件做好准备的组件。<strong>一个Selector可以管理多个通道</strong></p>
<p>使用Selector的过程也与通道息息相关</p>
<h2 id="1-Selector和通道建立联系"><a href="#1-Selector和通道建立联系" class="headerlink" title="1.Selector和通道建立联系"></a><strong>1.Selector和通道建立联系</strong></h2><p><strong><code>selectableChannel.register()</code></strong></p>
<p>为了将Channel和Selector配合使用，必须将Channel注册到Selector上，通过**selectableChannel.register()**方法来实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// selector建立</span></span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通道建立和绑定          </span></span><br><span class="line">ssc= ServerSocketChannel.open();</span><br><span class="line">ssc.socket().bind(<span class="keyword">new</span> InetSocketAddress(PORT));</span><br><span class="line">ssc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两者建立联系</span></span><br><span class="line">ssc.register(selector, SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></table></figure>
<p>上诉有几个补充</p>
<p>1、<code>selectableChannel</code>要求该通道是非阻塞的，这意味着不能将FileChannel与Selector一起使用，因为FileChannel不能切换到非阻塞模式。而套接字通道都可以。</p>
<p>2、<code>register()</code>方法的第二个参数。这是一个“interest集合”，意思是在通过Selector监听Channel时对什么事件感兴趣。可以监听四种不同类型的事件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. Connect</span><br><span class="line">2. Accept</span><br><span class="line">3. Read</span><br><span class="line">4. Write</span><br></pre></td></tr></table></figure>
<p>通道触发了一个事件意思是该事件已经就绪。所以，某个channel成功连接到另一个服务器称为“连接就绪”。一个server socket channel准备好接收新进入的连接称为“接收就绪”。一个有数据可读的通道可以说是“读就绪”。等待写数据的通道可以说是“写就绪”。</p>
<p>这四种事件用<code>SelectionKey</code>的四个常量来表示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. SelectionKey.OP_CONNECT</span><br><span class="line">2. SelectionKey.OP_ACCEPT</span><br><span class="line">3. SelectionKey.OP_READ</span><br><span class="line">4. SelectionKey.OP_WRITE</span><br></pre></td></tr></table></figure>
<h2 id="2-等待通道就绪"><a href="#2-等待通道就绪" class="headerlink" title="2.等待通道就绪"></a><strong>2.等待通道就绪</strong></h2><p><strong><code>selctor.select()</code></strong></p>
<p>当注册通道后，我们需要调用注册器几个重载的select()方法。这些方法返回你所感兴趣的事件已经准备就绪的那些通道。</p>
<p>下面是select()方法：</p>
<ul>
<li>int select()，<strong>阻塞</strong>到至少有一个通道在你注册的事件上就绪了。</li>
<li>int select(long timeout)，select()一样，但是最长只阻塞timeout毫秒</li>
<li>int selectNow()，不会阻塞</li>
</ul>
<p>而select方法的返回值是一个int，表示有多少通道已经就绪。显然为0代表没有通道准备就绪</p>
<h2 id="3-对就绪的通道进行操作"><a href="#3-对就绪的通道进行操作" class="headerlink" title="3.对就绪的通道进行操作"></a><strong>3.对就绪的通道进行操作</strong></h2><p><strong><code>SelectionKey</code></strong></p>
<p>Java NIO 中对就绪的通道进行操作主要涉及到SelectionKey对象的操作</p>
<p>实际上在前面当向Selector注册Channel时，register()方法会返回一个SelectionKey对象</p>
<p>此外调用<code>Set selectedKeys = selector.selectedKeys();</code>也可以返回已选择键集，通过这个已选择键集对已就绪的通道进行操作，因为一个SelectionKey对象可以包含以下很多信息：</p>
<ul>
<li><p>Channel</p>
</li>
<li><p>Selector</p>
</li>
<li><p>附加的对象（可选），比如通道对应的buffer</p>
</li>
<li><p>interest集合</p>
</li>
<li><p>ready集合</p>
</li>
</ul>
<p>下列是具体操作：</p>
<ul>
<li>获取已就绪的通道：<code>Channel  channel  = selectionKey.channel();</code>。</li>
<li>判断通道什么事件就绪：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">selectionKey.isAcceptable();</span><br><span class="line">selectionKey.isConnectable();</span><br><span class="line">selectionKey.isReadable();</span><br><span class="line">selectionKey.isWritable();</span><br></pre></td></tr></table></figure>
<ul>
<li><p>向SelectionKey附着更多信息：<code>selectionKey.attach(obj);</code></p>
</li>
<li><p>获取附着信息：<code>Object attachedObj = selectionKey.attachment();</code></p>
</li>
</ul>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>下列是一个对于就绪通道操作的伪代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(selector.select(TIMEOUT) == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();</span><br><span class="line">                <span class="keyword">while</span>(iter.hasNext())&#123;</span><br><span class="line">                    SelectionKey key = iter.next();</span><br><span class="line">                    <span class="keyword">if</span>(key.isAcceptable())&#123;</span><br><span class="line">                        handleAccept(key);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">                        handleRead(key);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(key.isWritable() &amp;&amp; key.isValid())&#123;</span><br><span class="line">                        handleWrite(key);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(key.isConnectable())&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;isConnectable = true&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    iter.remove();</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>
<p>注意每次迭代末尾的keyIterator.remove()调用。Selector不会自己从已选择键集中移除SelectionKey实例。必须在处理完通道时自己移除。下次该通道变成就绪时，Selector会再次将其放入已选择键集中</p>
<h1 id="三、简单demo"><a href="#三、简单demo" class="headerlink" title="三、简单demo"></a>三、简单demo</h1><p>利用上诉知识，写一个小demo</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleNIOServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BUFFER_SIZE = <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">8888</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIMEOUT = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleAccept</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocketChannel socketChannel = (ServerSocketChannel) key.channel();</span><br><span class="line">        SocketChannel accept = socketChannel.accept();</span><br><span class="line">        accept.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        accept.register(key.selector(),SelectionKey.OP_READ, ByteBuffer.allocate(BUFFER_SIZE));</span><br><span class="line">        System.out.println(<span class="string">&quot;连接完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleRead</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SocketChannel channel = (SocketChannel) key.channel();</span><br><span class="line">        ByteBuffer buffer = (ByteBuffer) key.attachment();</span><br><span class="line">        <span class="keyword">int</span> read = channel.read(buffer);</span><br><span class="line">        <span class="keyword">while</span>(read != -<span class="number">1</span>)&#123;</span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="keyword">while</span>(buffer.hasRemaining())&#123;</span><br><span class="line">                System.out.print((<span class="keyword">char</span>)buffer.get());</span><br><span class="line">        &#125;</span><br><span class="line">            buffer.clear();</span><br><span class="line">            read  = channel.read(buffer);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;读取完毕&quot;</span>);</span><br><span class="line">        channel.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleWrite</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SocketChannel channel = (SocketChannel) key.channel();</span><br><span class="line">        ByteBuffer buffer = (ByteBuffer) key.attachment();</span><br><span class="line">        buffer.flip();</span><br><span class="line">        <span class="keyword">while</span>(buffer.hasRemaining())</span><br><span class="line">            channel.write(buffer);</span><br><span class="line">        buffer.compact();</span><br><span class="line">        System.out.println(<span class="string">&quot;写完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">server</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(PORT));</span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        serverSocketChannel.register(selector,SelectionKey.OP_ACCEPT);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(selector.select(TIMEOUT) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterable = selector.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span>(iterable.hasNext())&#123;</span><br><span class="line">                SelectionKey key= iterable.next();</span><br><span class="line">                <span class="keyword">if</span>(key.isAcceptable())</span><br><span class="line">                    handleAccept(key);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(key.isReadable())</span><br><span class="line">                    handleRead(key);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable())</span><br><span class="line">                    handleWrite(key);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(key.isConnectable())</span><br><span class="line">                    System.out.println(<span class="string">&quot;连接中&quot;</span>);</span><br><span class="line">                iterable.remove();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        server();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java语法</category>
        <category>进阶</category>
      </categories>
      <tags>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>单调栈</title>
    <url>/2021/05/16/%E5%8D%95%E8%B0%83%E6%A0%88/</url>
    <content><![CDATA[<p>栈的一种应用——单调栈</p>
<a id="more"></a>

<p>单调栈顾名思义栈内的数据要么单调增，要么单调减，是栈的一种变种，主要是为了解决下一个更大或者下一个更小的类似问题</p>
<h1 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><strong>496. 下一个更大元素 I</strong></p>
<p><a href="https://leetcode-cn.com/problems/next-greater-element-i/">力扣链接</a></p>
<p>给你两个 <strong>没有重复元素</strong> 的数组 <code>nums1</code> 和 <code>nums2</code> ，其中<code>nums1</code> 是 <code>nums2</code> 的子集。</p>
<p>请你找出 <code>nums1</code> 中每个元素在 <code>nums2</code> 中的下一个比其大的值。</p>
<p><code>nums1</code> 中数字 <code>x</code> 的下一个更大元素是指 <code>x</code> 在 <code>nums2</code> 中对应位置的右边的第一个比 <code>x</code> 大的元素。如果不存在，对应位置输出 <code>-1</code> 。</p>
<p><strong>示例 :</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums1 &#x3D; [4,1,2], nums2 &#x3D; [1,3,4,2].</span><br><span class="line">输出: [-1,3,-1]</span><br><span class="line">解释:</span><br><span class="line">    对于 num1 中的数字 4 ，你无法在第二个数组中找到下一个更大的数字，因此输出 -1 。</span><br><span class="line">    对于 num1 中的数字 1 ，第二个数组中数字1右边的下一个较大数字是 3 。</span><br><span class="line">    对于 num1 中的数字 2 ，第二个数组中没有下一个更大的数字，因此输出 -1 。</span><br></pre></td></tr></table></figure>


<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums1.length &lt;= nums2.length &lt;= 1000</code></li>
<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 104</code></li>
<li><code>nums1</code>和<code>nums2</code>中所有整数 <strong>互不相同</strong></li>
<li><code>nums1</code> 中的所有整数同样出现在 <code>nums2</code> 中</li>
</ul>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>显然该题的<strong>主要逻辑部分</strong>找出<code>x</code> 在 <code>nums2</code> 中对应位置的右边的第一个比 <code>x</code> 大的元素，至于nums1的x在nums2中的位置，由于x不大，可以考虑用一个数组作为映射。</p>
<p>把该题抽象为我们生活中的列队，即找到x位置向后看，第一个比他高的人记位置为y，那显然对于x- 1，显然看不到x到y之间的人，因为他们比x矮，被x挡住了</p>
<p>从y到x呈现出一个单调减的趋势，当x-1找下一个更高的人，又是先看x、再看y，再到y之后比y高的元素，这又呈现后进先出的趋势，所以可以使用一个栈来维护这些数据，这就是单调栈</p>
<p>注意上诉场景既然向后看，我们就从后向前维护这样一个单调栈</p>
<p>落实到具体代码，可以见如下注释</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElement(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums2.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10001</span>];</span><br><span class="line">        LinkedList&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = n; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">            <span class="keyword">int</span> num = nums2[j];</span><br><span class="line">            <span class="comment">// 映射num在nums2的位置</span></span><br><span class="line">            map[num] = j;</span><br><span class="line">            <span class="comment">// 找比num更高的元素，显然之间的元素都会被即将加入的num挡住，直接出栈</span></span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; stack.getLast() &lt;= num)</span><br><span class="line">                stack.removeLast();</span><br><span class="line">            <span class="comment">// 当栈空说明没有</span></span><br><span class="line">            nums2[j] = stack.isEmpty() ? -<span class="number">1</span> : stack.getLast();</span><br><span class="line">            stack.addLast(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.length; i++)&#123;</span><br><span class="line">            nums1[i] = nums2[map[nums1[i]]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="进阶：循环数组"><a href="#进阶：循环数组" class="headerlink" title="进阶：循环数组"></a>进阶：循环数组</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p><strong>503. 下一个更大元素 II</strong></p>
<p><a href="https://leetcode-cn.com/problems/next-greater-element-ii/">力扣链接</a></p>
<p>给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,1]</span><br><span class="line">输出: [2,-1,2]</span><br><span class="line">解释: 第一个 1 的下一个更大的数是 2；</span><br><span class="line">数字 2 找不到下一个更大的数； </span><br><span class="line">第二个 1 的下一个最大的数需要循环搜索，结果也是 2。</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong> 输入数组的长度不会超过 10000。</p>
<h2 id="思考-1"><a href="#思考-1" class="headerlink" title="思考"></a>思考</h2><p>该题变循环数组后，意味这个下一个最大元素可以向后看，也可以向前看</p>
<p>我们可以维护两个单调栈分别向前看和向后看解决问题，但是还有一种更巧妙的思路</p>
<p>把向前看的人移动到末尾，即将原始数组翻倍在后面再接一个原始数组，这样统一了只用向后看</p>
<p>这时节约了一个栈的空间，因为再接一个原始数组相等于再从后向前遍历一些原始数据，实际不费空间</p>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElements(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        LinkedList&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 相当于再接一个原始数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; stack.getLast() &lt;= nums[i])</span><br><span class="line">                stack.removeLast();</span><br><span class="line">            stack.addLast(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 正常操作</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; stack.getLast() &lt;= temp)</span><br><span class="line">                stack.removeLast();</span><br><span class="line">            nums[i] = stack.isEmpty() ? -<span class="number">1</span> : stack.getLast();</span><br><span class="line">            </span><br><span class="line">            stack.addLast(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>经典数据结构</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>回溯经典</title>
    <url>/2021/05/19/%E5%9B%9E%E6%BA%AF%E7%BB%8F%E5%85%B8/</url>
    <content><![CDATA[<p>主要涉及，主要涉及到利用回溯的子集、排列、组合等相近但是又有区别的问题</p>
<a id="more"></a>

<h1 id="子集问题"><a href="#子集问题" class="headerlink" title="子集问题"></a>子集问题</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><strong>78. 子集</strong></p>
<p><a href="https://leetcode-cn.com/problems/subsets/">力扣链接</a></p>
<p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p>
<p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3]</span><br><span class="line">输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [0]</span><br><span class="line">输出：[[],[0]]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10</code></li>
<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>
<li><code>nums</code> 中的所有元素 <strong>互不相同</strong></li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>如果题目要求个数，很容易知道是2的n次方个。现在要求穷举具体解集，我们就需要理清楚自己的思路</p>
<p>总的来说每一个元素，我们要选择他加入子集或者不选择他加入子集，这里肯定就涉及到<strong>回溯</strong></p>
<p>下面具体到思路</p>
<p><strong>思路1</strong></p>
<p>对每一个元素，我们决定选或不选，直到所有元素决定完后，再将结果填入子集</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] nums;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">this</span>.nums = nums;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length - <span class="number">1</span>;</span><br><span class="line">        dfs(n,<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur,List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(cur &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">            <span class="keyword">return</span>;&#125;</span><br><span class="line">        	<span class="comment">// 选择该元素</span></span><br><span class="line">            list.add(nums[cur]);</span><br><span class="line">            dfs(cur - <span class="number">1</span>,list);</span><br><span class="line">        	<span class="comment">// 回溯</span></span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        	<span class="comment">// 不选择该元素</span></span><br><span class="line">            dfs(cur-<span class="number">1</span>,list);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中cur用来控制选择元素的位置，直到所有元素选择完毕</p>
<p><strong>思路2</strong></p>
<p>我们还可以换一种思路，总共n个元素，我们可以按以下方案抉择</p>
<ul>
<li><p>一个不选</p>
</li>
<li><p>选一个</p>
<p>……</p>
</li>
<li><p>选n个</p>
</li>
</ul>
<p>这里每一层都把结果添加到子集中，代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] nums;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">this</span>.nums = nums;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length - <span class="number">1</span>;</span><br><span class="line">        dfs(n,<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur,List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 每一层添加答案入解集</span></span><br><span class="line">        ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里控制cur比上一层的cur小，避免产生重复的子集</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = cur; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">            list.add(nums[j]);</span><br><span class="line">            dfs(j - <span class="number">1</span>,list);</span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>写完这题，基本可以见识到回溯算法的两种写法，主体有for循环和没有for循环的，一般的说，有for循环的参数控制更为讲究</p>
<h1 id="组合问题"><a href="#组合问题" class="headerlink" title="组合问题"></a>组合问题</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p><strong>77. 组合</strong></p>
<p><a href="https://leetcode-cn.com/problems/combinations/">力扣链接</a></p>
<p>给定两个整数 <em>n</em> 和 <em>k</em>，返回 1 … <em>n</em> 中所有可能的 <em>k</em> 个数的组合。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 4, k &#x3D; 2</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>很显然，组合问题是子集问题的一个子集，特别是到子集问题的思路二中，其只是子集问题递归第k层选k个的结果</p>
<p>延续前面子集问题的两种思路，我们这里依旧对照两种思路，不够现在回溯应该得再加一个参数k来判断选取组合是否到达k个</p>
<p><strong>思路1</strong></p>
<p>选或不选，当选到k个时就返回</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        dfs(n,k,<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur,<span class="keyword">int</span> k,List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">         <span class="comment">// 选到k个返回</span></span><br><span class="line">         <span class="keyword">if</span>(k == <span class="number">0</span>)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 剪枝，当选完了或者剩下的选不了k个了</span></span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="number">0</span> || cur &lt; k)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        list.add(cur);</span><br><span class="line">        dfs(cur - <span class="number">1</span>,k - <span class="number">1</span>,list);</span><br><span class="line">        list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        dfs(cur - <span class="number">1</span>,k,list);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>思路2</strong></p>
<p>就按照一层一层的选，选到满足条件结束</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        dfs(n,k,<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur,<span class="keyword">int</span> k,List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(k == <span class="number">0</span>)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">       	</span><br><span class="line">         <span class="comment">// 这里的j &gt;= k 是剪枝，即剩下的选不了k个了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = cur; j &gt;= k; j--)&#123;</span><br><span class="line">            list.add(j);</span><br><span class="line">            dfs(j - <span class="number">1</span>,k - <span class="number">1</span>,list);</span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="排列问题"><a href="#排列问题" class="headerlink" title="排列问题"></a>排列问题</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p><strong>46. 全排列</strong></p>
<p><a href="https://leetcode-cn.com/problems/permutations/">力扣链接</a></p>
<p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <strong>所有可能的全排列</strong> 。你可以 <strong>按任意顺序</strong> 返回答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [0,1]</span><br><span class="line">输出：[[0,1],[1,0]]</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1]</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 6</code></li>
<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>
<li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li>
</ul>
<h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>排列问题和子集、组合问题主要区别就在于排列问题顺序不一样就是一个排列，一个解</p>
<p>这个时候也用回溯，但是就不能用cur来控制顺序防止重复选取了</p>
<p>此时思路一的选或不选也不再生效</p>
<p>但是排列问题也有重复问题，注意<strong>重复问题的区别</strong>：前面的重复问题是指[2,1]和[1,2]的重复，而这里的重复问题再不以cur来控制顺序后，可能出现选取已选取元素的重复如[1,1]</p>
<p>这时我们就需要用一个visited数组来记录选取元素的情况</p>
<p>最后代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span>[] nums;</span><br><span class="line">    <span class="comment">// 用来标记是否选取</span></span><br><span class="line">    <span class="keyword">boolean</span>[] visited;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        <span class="keyword">this</span>.nums = nums;</span><br><span class="line">        dfs(n,<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k,List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">            <span class="keyword">return</span>;      </span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 无差别排列，和子集、组合的最大不同</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">            list.add(nums[i]);</span><br><span class="line">            visited[i] = <span class="keyword">true</span>;</span><br><span class="line">            dfs(k - <span class="number">1</span>,list);</span><br><span class="line">            visited[i] = <span class="keyword">false</span>;</span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="元素重复问题"><a href="#元素重复问题" class="headerlink" title="元素重复问题"></a>元素重复问题</h1><p>实际上，上诉问题都在题目中表明了数组中的<strong>元素重复唯一</strong></p>
<p>但是当数组元素不唯一时，会由于元素的重复带来解集的重复</p>
<p>这时就加大了题目难度</p>
<p>最简单的解决思路可能是用<strong>一个set集合来放解集来实现去重</strong>，但是否会有更巧妙的解法，直接剪枝判断去重呢</p>
<h2 id="思路一元素重复"><a href="#思路一元素重复" class="headerlink" title="思路一元素重复"></a>思路一元素重复</h2><p>在这情况下，首先面对思路一</p>
<p>如果<code>nums = [1,1,2]</code></p>
<p>如果我们选取了第一个1，那么第二个1有选或不选两种情况即[1,1]、[1]</p>
<p>如果我们不选取第一个1，那么第二个1如果选取了就会前面的两种情况之一重复即[1]</p>
<p>由此我们发现<strong>如果前一个重复元素没有选取情况下，后一个的重复元素也不用选取</strong>，就不会造成选取元素的重复了</p>
<p>但是有两个问题：</p>
<ul>
<li>如何判断前一个元素是否选取：同排列一样，采用<strong>visited数组</strong></li>
<li>如何判断保证重复元素紧挨着：先对<strong>数组进行排序预处理</strong></li>
</ul>
<p>下面两道题分别对应不同的处理方式</p>
<h3 id="实践一：子集重复"><a href="#实践一：子集重复" class="headerlink" title="实践一：子集重复"></a>实践一：子集重复</h3><p><strong>90. 子集 II</strong></p>
<p><a href="https://leetcode-cn.com/problems/subsets-ii/">力扣链接</a></p>
<p>给你一个整数数组 <code>nums</code> ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</p>
<p>解集 <strong>不能</strong> 包含重复的子集。返回的解集中，子集可以按 <strong>任意顺序</strong> 排列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,2]</span><br><span class="line">输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [0]</span><br><span class="line">输出：[[],[0]]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10</code></li>
<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] nums;</span><br><span class="line">    <span class="keyword">boolean</span>[] visited;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">this</span>.nums = nums;</span><br><span class="line">        <span class="comment">// 排序预处理</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur,List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == nums.length)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 如果前一个重复元素没有选取，就</span></span><br><span class="line">        <span class="keyword">if</span>(cur &gt; <span class="number">0</span> &amp;&amp; nums[cur] == nums[cur - <span class="number">1</span>] &amp;&amp; !visited[cur - <span class="number">1</span>])&#123;</span><br><span class="line">            ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            list.add(nums[cur]);</span><br><span class="line">            visited[cur] = <span class="keyword">true</span>;</span><br><span class="line">            dfs(cur + <span class="number">1</span>,list);</span><br><span class="line">            visited[cur] = <span class="keyword">false</span>;</span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(cur + <span class="number">1</span>,list);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="思路二元素重复"><a href="#思路二元素重复" class="headerlink" title="思路二元素重复"></a>思路二元素重复</h2><p>对于思路二的去重还可以再省掉一个visited数组</p>
<p>对于思路二，我们知道有一个cur记录了这一层的起始位置，其主体遍历结构如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = cur; j &lt; n; j++)&#123;</span><br><span class="line">           回溯</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>显然在一层的意思就是选择第t个数字，当位置处于j时，代表[cur,j-1]之前的数字已经选取过</p>
<p>那意味者当<strong>数组排好序过，相同元素相邻</strong>，如果<code>j &gt; cur </code>并且<code> nums[j] == nums[j - 1]</code>就说明这一层<code>nums[j]</code>已经选择作为第t个数字过了，就没有必要再选了</p>
<h3 id="实践二：组合重复"><a href="#实践二：组合重复" class="headerlink" title="实践二：组合重复"></a>实践二：组合重复</h3><ol start="40">
<li><strong>组合总和 II</strong></li>
</ol>
<p><a href="https://leetcode-cn.com/problems/combination-sum-ii/">力扣链接</a></p>
<p>给定一个数组 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p>
<p><code>candidates</code> 中的每个数字在每个组合中只能使用一次。</p>
<p><strong>说明：</strong></p>
<ul>
<li>所有数字（包括目标数）都是正整数。</li>
<li>解集不能包含重复的组合。 </li>
</ul>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: candidates &#x3D; [10,1,2,7,6,1,5], target &#x3D; 8,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [1, 7],</span><br><span class="line">  [1, 2, 5],</span><br><span class="line">  [2, 6],</span><br><span class="line">  [1, 1, 6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: candidates &#x3D; [2,5,2,1,2], target &#x3D; 5,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>代码</strong></p>
<p>这道题也是组合问题，只不过k变成了目标和，我们套用之前的思路</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        nums = candidates;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        dfs(<span class="number">0</span>,target,<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur,<span class="keyword">int</span> k,List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  nums[i] &lt;= k去重</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = cur; i &lt; nums.length &amp;&amp; nums[i] &lt;= k; i++)&#123;</span><br><span class="line">            <span class="comment">// 去重思路，这一层选取的nums[i]已经被选取过</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; cur &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            list.add(nums[i]);</span><br><span class="line">            dfs(i + <span class="number">1</span>, k - nums[i],list);</span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="排列问题元素重复"><a href="#排列问题元素重复" class="headerlink" title="排列问题元素重复"></a>排列问题元素重复</h2><p>对于排列问题的元素重复和思路二很相似，只是排列中没有i &gt; cur 的判断手段，但是可以利用visited数组辅助判断</p>
<h3 id="实践三：排列重复"><a href="#实践三：排列重复" class="headerlink" title="实践三：排列重复"></a>实践三：排列重复</h3><p><strong>47. 全排列 II</strong></p>
<p><a href="https://leetcode-cn.com/problems/permutations-ii/">力扣链接</a></p>
<p>给定一个可包含重复数字的序列 <code>nums</code> ，<strong>按任意顺序</strong> 返回所有不重复的全排列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,1,2]</span><br><span class="line">输出：</span><br><span class="line">[[1,1,2],</span><br><span class="line"> [1,2,1],</span><br><span class="line"> [2,1,1]]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure>


<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 8</code></li>
<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span>[] nums;</span><br><span class="line">    <span class="keyword">boolean</span>[] visited;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        <span class="keyword">this</span>.nums = nums;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        dfs(n,<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k,List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">            <span class="keyword">return</span>;      </span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 无差别排列，从0开始，和子集、组合的最大不同</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length ; i++)&#123;</span><br><span class="line">            <span class="comment">// 利用visited辅助去重判断</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !visited[i - <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">            list.add(nums[i]);</span><br><span class="line">            visited[i] = <span class="keyword">true</span>;</span><br><span class="line">            dfs(k - <span class="number">1</span>,list);</span><br><span class="line">            visited[i] = <span class="keyword">false</span>;</span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>根据上诉情况，我们可以总结出一套该问题的回溯模板</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(符合条件)&#123;</span><br><span class="line">           具体操作</span><br><span class="line">           <span class="keyword">return</span>;      </span><br><span class="line">       &#125;</span><br><span class="line">	</span><br><span class="line">       <span class="comment">// cur === 0,全排列模板</span></span><br><span class="line">    	<span class="comment">// cur 记录位置，集合组合模板</span></span><br><span class="line">    	<span class="comment">// 此处可以加条件剪枝</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = cur; i &lt; nums.length ; i++)&#123;</span><br><span class="line">          	</span><br><span class="line">           <span class="comment">// 去重模板都可以使用visited数组，对于前两者可以利用cur的位置辅助而不用数组 if(i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !visited[i - 1])continue;</span></span><br><span class="line">               </span><br><span class="line">           <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">           回溯部分</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>




<p>更多Java后端学习记录，可以观看我的博客：<a href="https://zhu-ym.github.io/">博客链接</a></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>回溯</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>消息队列</title>
    <url>/2021/05/19/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>主要是对消息队列的使用、可能出现的问题和常见的消息队列做一些概述</p>
<a id="more"></a>

<h1 id="消息模型"><a href="#消息模型" class="headerlink" title="消息模型"></a>消息模型</h1><p>消息模型主要有两种模式，一种是点对点，一种是发布订阅</p>
<h2 id="点对点"><a href="#点对点" class="headerlink" title="点对点"></a>点对点</h2><p>消息生产者向消息队列中发送了一个消息之后，只能被一个消费者消费一次。</p>
<h2 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h2><p>消息生产者向频道发送一个消息之后，多个消费者可以从该频道订阅到这条消息并消费。</p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>消息队列主要有三种应用：<strong>异步提高响应</strong>、<strong>高并发削峰限流</strong>、<strong>解耦</strong></p>
<h2 id="异步提高响应"><a href="#异步提高响应" class="headerlink" title="异步提高响应"></a>异步提高响应</h2><p>发送者将消息发送给消息队列之后，不需要同步等待消息接收者处理完毕，而是立即返回进行其它操作。消息接收者从消息队列中订阅消息之后异步处理。</p>
<p>比如淘宝提交订单后，后序可能会有短信通知，或者消费积分活动，这个过程可能用到了消息队列，首先保证了订单提交，然后将信息放入消息队列：短信通知，或者消费积分活动等其他流程业务异步进行</p>
<p>这样一个订单流程中可以缩减一些其他功能，提高响应速度</p>
<h2 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h2><p>如果模块之间不直接进行调用，模块之间耦合度就会很低，那么修改一个模块或者新增一个模块对其它模块的影响会很小，从而实现可扩展性。</p>
<p>通过使用消息队列，一个模块只需要向消息队列中发送消息，其它模块可以选择性地从消息队列中订阅消息从而完成调用。</p>
<p>显然上诉的异步案例也是解耦案例，消息队列让订单和短信通知，或者消费积分活动等别的模块功能之间实现了解耦</p>
<h2 id="高并发削峰限流"><a href="#高并发削峰限流" class="headerlink" title="高并发削峰限流"></a><strong>高并发削峰限流</strong></h2><p>在高并发的场景下，如果短时间有大量的请求到达会压垮服务器。</p>
<p>可以将请求发送到消息队列中，服务器按照其处理能力从消息队列中订阅消息进行处理。</p>
<p>一般在秒杀系统中可能涉及到对数据数据的操作，如果并发量过大，可能会造成数据库崩溃，可以将把请求放到队列里面，然后至于每秒消费多少请求，就看自己的服务器处理能力</p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>如果引入消息队列后，可能也会造成一些问题</p>
<h2 id="重复消费"><a href="#重复消费" class="headerlink" title="重复消费"></a>重复消费</h2><p>比如其他业务抛出异常后，利用<strong>重试机制</strong>要求消息重发而可能导致的重复消费问题</p>
<p>这样一般通过业务接口具有<strong>幂等性</strong>来解决，保证同样的参数调用接口，调用多少次结果都是一个</p>
<p>比如在下单系统中，做一个业务的流水表，每次消息过来都要拿着<strong>订单号+业务场景这样的唯一标识</strong>判断是否要走接下来的流程</p>
<h2 id="消息丢失"><a href="#消息丢失" class="headerlink" title="消息丢失"></a>消息丢失</h2><p>如上，一般采用重试机制</p>
<p>具体的消息队列可能有不同的处理方法</p>
<h2 id="消息消费顺序"><a href="#消息消费顺序" class="headerlink" title="消息消费顺序"></a>消息消费顺序</h2><p>主要是是<strong>同个业务场景下不同几个操作的消息同时过去</strong>，本身顺序是对的，但消费的时候却混乱</p>
<p>具体的消息队列可能有不同的处理方法</p>
<h2 id="一致性问题"><a href="#一致性问题" class="headerlink" title="一致性问题"></a>一致性问题</h2><p>主要是指真正的消费者们，没有正确消费消息，造成的数据不一致。</p>
<p>一般可以用<strong>分布式事务</strong>解决</p>
<h2 id="系统可用性问题"><a href="#系统可用性问题" class="headerlink" title="系统可用性问题"></a>系统可用性问题</h2><p>考虑到消息中间件可能挂掉的情况</p>
<h1 id="常见消息队列"><a href="#常见消息队列" class="headerlink" title="常见消息队列"></a>常见消息队列</h1><p>下图是常见消息队列的对比</p>
<p><img src="/images/image-20210524161213694.png" alt="image-20210524161213694"></p>
<p>其中</p>
<p><strong>ActiveMQ：</strong>没经过大规模吞吐量场景的验证，社区也不是很活跃，所以不推荐 <strong>RabbitMQ：</strong>活跃度高，<strong>开源</strong>，比较稳定的支持，推荐中小型公司使用，数据量较小</p>
<p><strong>RocketMQ：</strong>阿里出品，Java语言编写，经过了阿里多年双十一大促的考验，性能和稳定性得到了充分的严重。目前在业界被广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理，binlog分发等场景</p>
<p> <strong>kafka：</strong>大数据领域的实时计算、日志采集等场景，适合产生大量数据的互联网服务的数据收集业务</p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>一个双向BFS的写法</title>
    <url>/2021/05/21/%E4%B8%80%E4%B8%AA%E5%8F%8C%E5%90%91BFS%E7%9A%84%E5%86%99%E6%B3%95/</url>
    <content><![CDATA[<p>BFS是穷举法的一种，但是天生适合用来求最少次数等最值问题</p>
<p>而双向BFS相等于是对BFS的一种优化，在情况越大时，效果越好</p>
<a id="more"></a>

<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>773. 滑动谜题</strong></p>
<p><a href="https://leetcode-cn.com/problems/sliding-puzzle/">力扣链接</a></p>
<p>在一个 2 x 3 的板上（<code>board</code>）有 5 块砖瓦，用数字 <code>1~5</code> 来表示, 以及一块空缺用 <code>0</code> 来表示.</p>
<p>一次移动定义为选择 <code>0</code> 与一个相邻的数字（上下左右）进行交换.</p>
<p>最终当板 <code>board</code> 的结果是 <code>[[1,2,3],[4,5,0]]</code> 谜板被解开。</p>
<p>给出一个谜板的初始状态，返回最少可以通过多少次移动解开谜板，如果不能解开谜板，则返回 -1 。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：board &#x3D; [[1,2,3],[4,0,5]]</span><br><span class="line">输出：1</span><br><span class="line">解释：交换 0 和 5 ，1 步完成</span><br><span class="line">输入：board &#x3D; [[1,2,3],[5,4,0]]</span><br><span class="line">输出：-1</span><br><span class="line">解释：没有办法完成谜板</span><br><span class="line">输入：board &#x3D; [[4,1,2],[5,0,3]]</span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line">最少完成谜板的最少移动次数是 5 ，</span><br><span class="line">一种移动路径:</span><br><span class="line">尚未移动: [[4,1,2],[5,0,3]]</span><br><span class="line">移动 1 次: [[4,1,2],[0,5,3]]</span><br><span class="line">移动 2 次: [[0,1,2],[4,5,3]]</span><br><span class="line">移动 3 次: [[1,0,2],[4,5,3]]</span><br><span class="line">移动 4 次: [[1,2,0],[4,5,3]]</span><br><span class="line">移动 5 次: [[1,2,3],[4,5,0]]</span><br><span class="line">输入：board &#x3D; [[3,2,4],[1,5,0]]</span><br><span class="line">输出：14</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>board</code> 是一个如上所述的 2 x 3 的数组.</li>
<li><code>board[i][j]</code> 是一个 <code>[0, 1, 2, 3, 4, 5]</code> 的排列.</li>
</ul>
<h1 id="思路概述"><a href="#思路概述" class="headerlink" title="思路概述"></a>思路概述</h1><p>该题求最小次数，显然采用BFS，大致根据起始状态，按照题目方式变换到相邻状态，再看最后是否能够变换到</p>
<p>目标态</p>
<p>值得注意一点，该题可能无解，这必须要求我们不能回到已经到过的状态，<strong>不然循环一定退不出来</strong>，关于判断状态是否到达，肯定是用<strong>集合</strong>时间高效</p>
<p>但决定采用集合后，本题的难点也就在此：什么样的<strong>状态存储方便放入集合</strong></p>
<p>有两个思路：</p>
<ul>
<li><p>将状态转化成<strong>字符串或数字等Java的原生值比较类</strong></p>
</li>
<li><p><strong>自定义一个类</strong>，重写<code>hashCode</code>和<code>equals</code>方法</p>
</li>
</ul>
<h1 id="思路一：利用Java原生类"><a href="#思路一：利用Java原生类" class="headerlink" title="思路一：利用Java原生类"></a>思路一：利用Java原生类</h1><p>对于思路一，转成字符串简单，可能消耗比数字大；转化为一个整数，由于存在0在首位的问题，可以尝试将0替换成6-9的一个数字，就更加不用思考特殊情况</p>
<p>这两种方法推荐使用第二种，可以在BFS队列中就放置一个int[] 数组，将board存放为一维，还可以多加一位作为标记0的位置</p>
<p>但是这里我采用了字符串的方式，主要是我想练习一下双向BFS的书写，采用的是Set集合作为队列</p>
<p>near数组是二维化为一维后的标记</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 记录相邻可变换位置</span></span><br><span class="line">    <span class="keyword">int</span> [][] near= &#123;&#123;<span class="number">1</span>,<span class="number">3</span>&#125;,&#123;<span class="number">0</span>,<span class="number">4</span>,<span class="number">2</span>&#125;,&#123;<span class="number">1</span>,<span class="number">5</span>&#125;,&#123;<span class="number">0</span>,<span class="number">4</span>&#125;,&#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>&#125;,&#123;<span class="number">4</span>,<span class="number">2</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">slidingPuzzle</span><span class="params">(<span class="keyword">int</span>[][] board)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; q1 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Set&lt;String&gt; q2 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Set&lt;String&gt; set1 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] arr: board )&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i: arr)&#123;</span><br><span class="line">                sb.append(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        q1.add(sb.toString());</span><br><span class="line">        q2.add(<span class="string">&quot;123450&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!q1.isEmpty() &amp;&amp; !q2.isEmpty())&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 每次选取size小的队列做q1，减少遍历广度</span></span><br><span class="line">            <span class="keyword">if</span>(q2.size() &lt; q1.size())&#123;</span><br><span class="line">                Set&lt;String&gt; temp = q2;</span><br><span class="line">                q2 = q1;</span><br><span class="line">                q1 = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            Set&lt;String&gt; newQueue = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">            <span class="keyword">for</span>(String str: q1)&#123;</span><br><span class="line">                <span class="keyword">if</span>(q2.contains(str))</span><br><span class="line">                    <span class="keyword">return</span>  step;</span><br><span class="line">       </span><br><span class="line">                set1.add(str);</span><br><span class="line">                <span class="keyword">char</span>[] ch = str.toCharArray();</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 字符串的find0消耗了一定时间</span></span><br><span class="line">                <span class="keyword">int</span> k = find0(ch);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j: near[k])&#123;</span><br><span class="line">                    swap(k,j,ch);</span><br><span class="line">                    String s1 = <span class="keyword">new</span> String(ch);</span><br><span class="line">   					<span class="comment">// 去重</span></span><br><span class="line">                    <span class="keyword">if</span>(!set1.contains(s1))</span><br><span class="line">                        newQueue.add(s1);</span><br><span class="line">                    swap(k,j,ch);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            step++;</span><br><span class="line">            q1 = newQueue;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find0</span><span class="params">(<span class="keyword">char</span>[] c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c.length; i++)</span><br><span class="line">            <span class="keyword">if</span>(c[i] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span>  i;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">char</span>[] ch)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> temp = ch[i];</span><br><span class="line">        ch[i] = ch[j];</span><br><span class="line">        ch[j] = temp;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法，BFS</category>
      </categories>
      <tags>
        <tag>双向BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>前缀和数组</title>
    <url>/2021/05/23/%E5%89%8D%E7%BC%80%E5%92%8C%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>前缀和数组是对一个数组进行累加求和，然后可以通过O(1)的时间复杂度得到数组的任意子数组和</p>
<a id="more"></a>

<p>下面通过一题看其具体应用</p>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>560. 和为K的子数组</strong></p>
<p><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/">力扣链接</a></p>
<p>给定一个整数数组和一个整数 <strong>k，</strong>你需要找到该数组中和为 <strong>k</strong> 的连续的子数组的个数。</p>
<p><strong>示例 1 :</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:nums &#x3D; [1,1,1], k &#x3D; 2</span><br><span class="line">输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。</span><br></pre></td></tr></table></figure>
<p><strong>说明 :</strong></p>
<ol>
<li>数组的长度为 [1, 20,000]。</li>
<li>数组中元素的范围是 [-1000, 1000] ，且整数 <strong>k</strong> 的范围是 [-1e7, 1e7]。</li>
</ol>
<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>显然该题涉及到连续子数组求和，我们如果枚举子数组后再求和可能导致时间复杂度很高</p>
<p>这时类似于数学中的前n项和</p>
<p>我们如果有p[i] 表示 nums数组的前i项和</p>
<p>那么任意num[i…j]和就等于<code>p[j + 1] - p[i]</code></p>
<p>而求取p[i]也比较简单，只需要遍历一遍数组即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">preSum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    preSum[i + <span class="number">1</span>] = preSum[i] + nums[i];</span><br></pre></td></tr></table></figure>
<p>当然对于该题</p>
<p>我们预处理得到<code>preSum</code>后我们就要寻找<code>preSum[j] - preSum[i] == k</code>即的个数即答案</p>
<p><code>preSum[j] - preSum[i] == k</code>即**<code>preSum[j] + (-preSum[i]) == k</code><strong>,这个题目明显转化成了经典的</strong>两数之和问题**（狗头）</p>
<p>我们如果利用一个map记录下前面的<code>preSum[i] + k</code>,到后面的<code>j</code>时只有判断<code>preSum[j]</code>是否存在即可</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>最后代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n  = nums.length;</span><br><span class="line">        <span class="comment">// preSum[i] 表示nums前i项和</span></span><br><span class="line">        <span class="keyword">int</span>[] preSum = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        preSum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            preSum[i + <span class="number">1</span>] = preSum[i] + nums[i];</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面是经典两数之和问题变种</span></span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(k,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(preSum[i]))</span><br><span class="line">                sum += map.get(preSum[i]);</span><br><span class="line"></span><br><span class="line">            map.put(preSum[i] + k,map.getOrDefault(preSum[i] + k,<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>经典数据结构</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>表达式求值问题</title>
    <url>/2021/05/22/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>表达式求值问题，简单来说就是编写一个计算器</p>
<a id="more"></a>

<p>题目大概就是给出一个表达式，怎么求值如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 ：&quot;1+ 2*4 - 4&quot;</span><br><span class="line">2 ： &quot;-(-2*4-3)&quot;</span><br></pre></td></tr></table></figure>
<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>首先不考虑括号，我们遍历表达式</p>
<p>对第一个式子，出现<code>1+2</code>时不能计算，可能2会被后面<strong>更高的优先级</strong>的式子占用,那我们只好把1,2记录下来，也把<code>+</code>记录下来</p>
<p>当出现<code>2*4</code>时，也不能直接计算，因为后面的数字也可能被更高的优先级的式子占用，我们继续记录<code>*</code>和<code>4</code></p>
<p>当<code>-</code>出现时，我们可以明确清楚，前面的<code>*</code><strong>优先级比较高</strong>，我们可以计算<code>2*4</code>，计算结果得8，我们记录下来,同时根据运算顺序，<code>1 + 8</code>也可以算了，再次计算得<code>9</code>记录下来，</p>
<p>最后我们记录下<code>9</code>和<code>4</code>和<code>-</code></p>
<p>当整个式子遍历结束，计算<code>9 - 4</code>得结果<code>5</code></p>
<p>上诉这个过程，有几个点，首先记录数字和符号有后进先出的特性，考虑用<strong>栈</strong>来存储</p>
<p>最重要的是对于操作符有着<strong>优先级大小比较问题</strong>，结合栈正像我们之前学习过的一个数据结构<strong>单调栈</strong>，我们保证栈里的优先级是单调增加的</p>
<p>上诉思路描述成算法如下</p>
<ul>
<li>遇到数字进栈</li>
<li>遇到操作符与栈顶操作符比较，如果优先级低：<ul>
<li>取栈顶操作符+两个数计算，计算数存入操作数栈中</li>
<li>循环此操作，直到栈空或者该操作符优先级高于栈顶元素</li>
<li>该操作符进栈</li>
</ul>
</li>
</ul>
<p>当考虑加入括号时，我们可以拆分到一个完整的<code>()</code><strong>内是一个没有括号的表达式</strong>，当遇到<code>)</code>时要求把这个<code>()</code>内的表达式算成<strong>一个数</strong>，加入上诉理论我们可以把**<code>)</code>优先级定为最低<strong>，这样其他操作符就会一直出栈，直到遇到<code>(</code>为止，这样就保证了一个<code>()</code>结束能得到内部表达式的值，那对应</strong><code>(</code>优先级也是最低**，不遇到<code>)</code>就不出栈</p>
<p>完成该思路后基本模型也就出来</p>
<p>最后补充一个对于+、-做<strong>符号位</strong>的处理方案</p>
<p><code>+5-(-2*3)</code></p>
<p>我在代码中遇到符号位进行了添0处理，以求代码统一</p>
<p>上式可以表达成</p>
<p><code>0+5-(0-2*3)</code></p>
<p>不影响结果</p>
<p>而符号位的判断也比较简单，符号位要么在开头，要么前面还是操作符</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>根据上诉思路</p>
<p>最后代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] priority = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">60</span>];</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">// 可以简单添加优先级添加其他操作符，便于扩展</span></span><br><span class="line">        priority[<span class="string">&#x27;+&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">        priority[<span class="string">&#x27;-&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">        priority[<span class="string">&#x27;*&#x27;</span>] = <span class="number">2</span>;</span><br><span class="line">        priority[<span class="string">&#x27;/&#x27;</span>] = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] ch = s.toCharArray();</span><br><span class="line">        LinkedList&lt;Integer&gt; numsStack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        LinkedList&lt;Character&gt; opsStack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 该计数只是为了处理正负号而存在，记0表示上一步为+-/*(, 1为数字或)</span></span><br><span class="line">        <span class="keyword">int</span> preStep = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; ch.length)&#123;</span><br><span class="line">            <span class="comment">// 去掉空格</span></span><br><span class="line">            <span class="keyword">while</span>(i &lt; ch.length &amp;&amp; ch[i] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                i++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理数字</span></span><br><span class="line">            <span class="keyword">if</span>(i &lt; ch.length &amp;&amp; Character.isDigit(ch[i]))&#123;</span><br><span class="line">                <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 获取数字值</span></span><br><span class="line">                <span class="keyword">while</span>(i &lt; ch.length &amp;&amp;Character.isDigit(ch[i]))&#123;</span><br><span class="line">                    res = res * <span class="number">10</span> + ch[i++] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                numsStack.push(res);</span><br><span class="line">                preStep = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 处理符号</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i &lt; ch.length )&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">char</span> c = ch[i++];</span><br><span class="line">                <span class="comment">// 当该位是符号位时我们添0处理</span></span><br><span class="line">                <span class="keyword">if</span>(preStep == <span class="number">0</span> &amp;&amp; (c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span>))&#123;</span><br><span class="line">                    numsStack.push(<span class="number">0</span>);&#125;</span><br><span class="line">                preStep = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// &#x27;(&#x27;直接入栈，其他比较优先级</span></span><br><span class="line">                <span class="keyword">if</span>(c != <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">while</span>(!opsStack.isEmpty() &amp;&amp; priority[c] &lt;= priority[opsStack.peek()])&#123;</span><br><span class="line">                        <span class="comment">// 优先级高的操作符出栈,直接计算,同优先级先算前面,(不计算</span></span><br><span class="line">                        <span class="keyword">if</span>(opsStack.peek() != <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                            <span class="keyword">int</span> num = calculateOne(numsStack.pop(),numsStack.pop(), opsStack.peek());</span><br><span class="line">                            numsStack.push(num);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 一个）匹配到一个（为止</span></span><br><span class="line">                        <span class="keyword">else</span>&#123;</span><br><span class="line">                            opsStack.pop();</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                        opsStack.pop();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 对)不进操作栈</span></span><br><span class="line">                <span class="keyword">if</span>(c != <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">                    opsStack.push(c);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    preStep = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!opsStack.isEmpty())&#123;</span><br><span class="line">            <span class="comment">// 优先级高的操作符出栈,直接计算,同优先级先算前面,(不计算</span></span><br><span class="line">                <span class="keyword">int</span> num = calculateOne(numsStack.pop(),numsStack.pop(), opsStack.peek());</span><br><span class="line">                numsStack.push(num);</span><br><span class="line">                opsStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numsStack.pop();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateOne</span><span class="params">(<span class="keyword">int</span> post,<span class="keyword">int</span> pre, <span class="keyword">char</span> op)</span></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(op)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: <span class="keyword">return</span> pre + post;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: <span class="keyword">return</span> pre - post;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: <span class="keyword">return</span> pre * post;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: <span class="keyword">return</span> pre / post;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 正常应该抛出异常</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该计算器器代码的扩展性强，实际上速构造的**<code>单调栈+数字栈</code><strong>也叫</strong>后缀表达式**</p>
<p>我更认为该计算过程更像是一道模拟题，对计算过程进行模拟</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>经典算法</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
        <tag>表达式求值</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ原理</title>
    <url>/2021/05/25/RocketMQ%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>了解RocketMQ的一些设计原理</p>
<a id="more"></a>

<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p><code>RocketMQ</code> 是一个 <strong>队列模型</strong> 的消息中间件，具有<strong>高性能、高可靠、高实时、分布式</strong> 的特点。</p>
<h1 id="二、消息模型"><a href="#二、消息模型" class="headerlink" title="二、消息模型"></a>二、消息模型</h1><p>RocketMQ采用的消息模型是<strong>发布订阅模型</strong>，也叫<strong>主题模型</strong>，其中：</p>
<p>消息的生产者称为 <strong>发布者(Publisher)</strong> ，消息的消费者称为 <strong>订阅者(Subscriber)</strong> ，存放消息的容器称为 <strong>主题(Topic)</strong> 。</p>
<p>发布者将消息发送到指定主题中，订阅者需要 <strong>提前订阅主题</strong> 才能接受特定主题的消息。</p>
<p>对于RocketMQ，其主题模型的实现，如下图所示：</p>
<p><img src="/images/image-20210525145954822.png" alt="image-20210525145954822"></p>
<ul>
<li>首先其一个<strong>Topic配置了多个队列，并且每个队列队列维护了每个消费者组的消费位置</strong>。前者提高了并发能力，后者就是让多个消费群组记录自己的消费位置，不会重复消费</li>
<li>然后一个<strong>生产者组生产相同的消息，生产者组有可以有多个生产者</strong></li>
<li>最后一个<strong>消费者组可以有多个消费者，共同消费一个 <code>topic</code> 的多个队列，一个队列只会被一个消费者消费</strong></li>
</ul>
<p>总的来说该RocketMQ如此实现的主题模型明显<strong>适合于分布式横向扩展部署架构</strong>，不仅生产者组消费者组可以集群部署、一个Topic也适合集群部署</p>
<h1 id="三、架构组成"><a href="#三、架构组成" class="headerlink" title="三、架构组成"></a>三、架构组成</h1><p><code>RocketMQ</code> 技术架构中有四大角色 <code>NameServer</code> 、<code>Broker</code> 、<code>Producer</code> 、<code>Consumer</code> 。</p>
<p><img src="/images/image-20210525152218692.png" alt="image-20210525152218692"></p>
<h2 id="NameServer"><a href="#NameServer" class="headerlink" title="NameServer"></a>NameServer</h2><p><strong><code>主要负责对于源数据的管理，包括了对于Topic和Broker路由信息的管理。</code></strong></p>
<p>具体来说，如上图所示</p>
<p>每个 <code>Broker </code>在启动的时候会到 <code>NameServer </code>注册，<code>Producer</code> 在发送消息前会根据 <code>Topic </code>到 <code>NameServer</code> 获取到 <code>Broker </code>的路由信息，<code>Consumer</code> 也会定时获取 <code>Topic</code> 的路由信息，然后再和对应的<code>Broker</code>进行通信。</p>
<p><code>NameServer</code>压力不会太大，平时主要开销是在维持心跳和提供Topic-Broker的关系数据，其降低了<code>Broker</code>修改时对生产者和消费者的影响</p>
<p> 最后<code>NameServer</code> 可以做集群部署，其是去<strong>中心化</strong>的，意味着在 <code>RocketMQ</code> 中 <strong>单个Broker和所有NameServer保持长连接</strong></p>
<h2 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h2><p><strong><code>消息中转角色，负责存储消息，转发消息。</code></strong></p>
<p><code>Broker</code>是具体提供业务的服务器，单个<code>Broker</code>节点与所有的<code>NameServer</code>节点保持长连接及心跳，并会定时将<code>Topic</code>信息注册到<code>NameServer</code>,当生产者、消费者从<code>NameServer</code>得到<code>Broker </code>的路由信息后，生产者生产消息到 <code>Broker</code> ，消费者从 <code>Broker</code> 拉取消息并消费</p>
<p>前面说到<code>RocketMQ</code>的主题模型明显<strong>适合于分布式横向扩展部署架构</strong>，主要在于<strong>一个 <code>Topic</code> 的多个队列可以分布在多个 <code>Broker</code>上，一个 <code>Broker</code> 可以配置多个 <code>Topic</code> ，它们是多对多的关系</strong>。</p>
<h2 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h2><p><strong><code>消息生产者，负责产生消息，一般由业务系统负责产生消息</code></strong></p>
<p><code>Producer</code>由用户进行分布式部署，消息由<code>Producer</code>通过多种<strong>负载均衡模式</strong>发送到<code>Broker</code>集群，发送低延时，支持快速失败。</p>
<p>其中主要有三种方式发送消息：同步、异步和单向</p>
<ul>
<li><strong>同步发送</strong>：同步发送指消息发送方发出数据后会在收到接收方发回响应之后才发下一个数据包。一般用于重要通知消息，例如重要通知邮件、营销短信。</li>
<li><strong>异步发送</strong>：异步发送指发送方发出数据后，不等接收方发回响应，接着发送下个数据包，一般用于可能链路耗时较长而对响应时间敏感的业务场景，例如用户视频上传后通知启动转码服务。</li>
<li><strong>单向发送</strong>：单向发送是指只负责发送消息而不等待服务器回应且没有回调函数触发，适用于某些耗时非常短但对可靠性要求并不高的场景，例如日志收集。</li>
</ul>
<h2 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h2><p><strong><code>消息消费者，负责消费消息，一般是后台系统负责异步消费。</code></strong></p>
<p><code>Consumer</code>支持以<code>push</code>推，<code>pull</code>拉两种模式对消息进行消费</p>
<ul>
<li><strong>Pull</strong>：消费者主动从<code>Broker</code>拉取信息，拉模式更适合进行消息的批量发送，<code>Broker</code>可以参考消费者请求的信息来决定缓存多少消息之后批量发送。但是存在消息延迟、消息忙请求等问题</li>
<li><strong>Push</strong>：消息从 Broker 推向 Consumer，消息实时性高,但难以根据消费者的状态控制推送速率。 Push 首先要注册消费监听器，当监听器处触发后才开始消费消息。</li>
</ul>
<p>此外消息着的消费模式也有两种：集群消费）和广播消费：</p>
<ul>
<li><p><strong>集群消费：</strong>默认情况下就是集群消费，该模式下一个消费者集群共同消费一个主题的多个队列，一个队列只会被一个消费者消费，如果某个消费者挂掉，分组内其它消费者会接替挂掉的消费者继续消费。</p>
</li>
<li><p><strong>广播消费：</strong>广播消费消息会发给消费者组中的每一个消费者进行消费。</p>
</li>
</ul>
<h1 id="四、持久化"><a href="#四、持久化" class="headerlink" title="四、持久化"></a>四、持久化</h1><h2 id="刷盘机制"><a href="#刷盘机制" class="headerlink" title="刷盘机制"></a>刷盘机制</h2><p>刷盘机制涉及到单个<code>Broker</code>的持久化</p>
<p><code>RocketMQ</code>可以通过设置 <code>Broker</code> 的参数 <code>FlushDiskType</code> 来调整刷盘策略<strong>异步刷盘</strong>（ASYNC_FLUSH ）或者<strong>同步刷盘</strong>（SYNC_FLUSH)。</p>
<p><code>RocketMQ</code>的存储读写是基于<code>JDK NIO</code>的内存映射机制的，消息存储时首先将消息追加到<strong>内存</strong>中。在根据不同的刷盘策略在不同的时间进行刷盘</p>
<ul>
<li>**同步刷盘:**消息追加到内存后，将同步调用<code>MappedByteBuffer</code>的<code>force()</code>方法，同步等待刷盘结果，进行刷盘结果返回</li>
<li>**异步刷盘:**在消息追加到内存后立刻，不等待刷盘结果立刻返回存储成功结果给消息发送端。<code>RocketMQ</code>使用一个单独的线程按照一个设定的频率执行刷盘操作</li>
</ul>
<p>显然，前者需要等待刷盘结果，<strong>消息可靠性高</strong>，但是<strong>性能上会有较大影响</strong> ，一般地适用于金融等特定业务场景。</p>
<p>后者往往是开启一个线程去按照一定频率异步地执行刷盘操作， <strong>降低了读写延迟</strong> ，提高了 <code>MQ</code> 的性能和吞吐量，但是在 <code>Broker</code> 意外宕机的时候会丢失部分数据，所以一般适用于如发验证码等对于消息保证要求不太高的业务场景。</p>
<h2 id="同步、异步复制"><a href="#同步、异步复制" class="headerlink" title="同步、异步复制"></a>同步、异步复制</h2><p>同步复制和异步复制主要是指的 <code>Borker</code> 主从模式下，主节点返回消息给客户端的时候是否需要同步从节点。</p>
<ul>
<li><strong>同步复制</strong>： 也叫 “同步双写”，也就是说，<strong>只有消息同步双写到主从结点上时才返回写入成功</strong> 。</li>
<li><strong>异步复制</strong>： <strong>消息写入主节点之后就直接返回写入成功</strong> 。</li>
</ul>
<p>但是注意<strong>是 <code>RocketMQ</code> 是不支持自动主从切换的，当主节点挂掉之后，生产者就不能再给这个主节点生产消息了</strong>。<strong>消费者可以自动切换到从节点进行消费</strong>，这时如果采用来异步复制，可能会出现主从消息不一致的现象，会降低可用性。</p>
<h2 id="存储机制"><a href="#存储机制" class="headerlink" title="存储机制"></a>存储机制</h2><p><code>RocketMQ</code>的存储机制主要和<code>CommitLog</code>、<code>ConsumeQueue</code>和<code>IndexFile</code>有关，其中<code>IndexFile</code>提供了一种可以通过key或时间区间来查询消息的方法，这里不做深入了解。</p>
<ul>
<li><p><strong><code>CommitLog:</code>**消息主体以及元数据的存储主体，采用</strong>混合型存储<strong>方式，即</strong>所有的Topic下的消息队列共用同一个<code>CommitLog</code>的日志数据文件<strong>，</strong>提高了数据的写入效率<strong>。单个文件大小默认为1G,消息主要是</strong>顺序写入日志文件**，当第一个文件写满了、默认到下一个。</p>
</li>
<li><p><strong><code>ConsumeQueue:</code>**消息消费队列，前面<code>CommitLog</code>采用了混合型存储方式，数据直接遍历寻找指定Topic队列下的消息花费大，<code>ConsumeQueue</code>相当于一层索引、</strong>提升读取消息的效率<strong>，其更像是我们上诉消息模型中的队列。其大小固定，维护了 <code>ConsumeOffset</code> 即每个消费者组的消费位置，消费者根据消费者拉取消息进行消费的时候只需要根据 <code>ConsumeOffset</code> 获取在<code>Consumeoffset</code>下一个未被消费的</strong>消息索引<strong>，消息索引包含了在 <code>CommitLog</code> 中的</strong>起始物理偏移量** <code>commitLogOffset</code>、<strong>消息大小</strong> <code>msgSize</code> 和<strong>消息 Tag的哈希值</strong><code>tagsCode</code> 的，再定位到<code>CommitLog</code>中就可以读取到指定消息</p>
</li>
</ul>
<p>详情可以参考下图</p>
<p><img src="/images/image-20210525190217950.png" alt="image-20210525190217950"></p>
<p>在图中最左边说明了 红色方块 代表被写入的消息，虚线方块代表等待被写入的。左边的生产者发送消息会指定 <code>Topic</code> 、<code>QueueId</code> 和具体消息内容，而在 <code>Broker</code> 中将消息全部顺序存储到了 CommitLog 。而根据生产者指定的 <code>Topic</code> 和 <code>QueueId</code> 将这条消息本身在 <code>CommitLog</code> 的偏移(offset)，消息本身大小，和tag的hash值存入对应的 <code>ConsumeQueue</code> 索引文件中。而在每个队列中都保存了 <code>ConsumeOffset</code> 即每个消费者组的消费位置，而消费者拉取消息进行消费的时候只需要根据 <code>ConsumeOffset</code> 获取下一个未被消费的消息。</p>
<h1 id="五、一些问题的解决"><a href="#五、一些问题的解决" class="headerlink" title="五、一些问题的解决"></a>五、一些问题的解决</h1><h2 id="顺序消费"><a href="#顺序消费" class="headerlink" title="顺序消费"></a>顺序消费</h2><p>我们知道一个队列里消息是有顺序的，不同消息队列收到的消息则可能是无顺序的</p>
<p>由于负载均衡策略，在秒杀系统时，一个订单的创建、发货、收货可能因为轮询放在了一个Topic下的不同队列中，从而导致无法使用 <code>RocketMQ</code> 带来的队列有序特性来保证消息有序性</p>
<p>我们可以利用 <code>RocketMQ</code> 队列选择机制的<strong>Hash取模法</strong>将一个订单的创建、发货、收货消息发送到一个队列中避免这个问题</p>
<h2 id="重复消费"><a href="#重复消费" class="headerlink" title="重复消费"></a>重复消费</h2><p>重复消费的问题可用通过<strong>幂等</strong>解决，根据应用场景，一般有强校验和弱校验</p>
<p><strong>强校验</strong></p>
<p>事务+查流水表</p>
<p><strong>弱校验</strong></p>
<p>Redis key</p>
<h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><p>RocketMQ主要通过<strong>半消息</strong>、<strong>消息回查</strong>和<strong>二次确认</strong>等操作实现分布式事务</p>
<p>半消息是指事务在提交前，对消费者不可见的消息，内部可以通过改变主题实现：</p>
<p>如果消息是half消息，将备份原消息的主题与消息消费队列，然后 <strong>改变主题</strong> 为<code>RMQ_SYS_TRANS_HALF_TOPIC</code>。由于消费组未订阅该主题，故消费端无法消费half类型的消息，然后RocketMQ会开启一个定时任务，从<code>Topic</code>为<code>RMQ_SYS_TRANS_HALF_TOPIC</code>中拉取消息进行消费，根据生产者组获取一个服务提供者发送<strong>回查事务</strong>状态请求，根据事务状态的<strong>二次确认</strong>来决定是提交或回滚消息。</p>
<p>当然，如果在指定时间内发送方已经将事务执行并将执行情况成功告知，就没有事务回查这一步，<strong>直接二次确认</strong></p>
<p>可以见下图</p>
<p><img src="/images/image-20210525194051219.png" alt="image-20210525194051219"></p>
<p>注意：在 <code>MQ Server</code> 指向系统B的操作已经和系统A不相关了，也就是说在消息队列中的分布式事务是——<strong>本地事务和存储消息到消息队列才是同一个事务</strong>。这样也就产生了事务的<strong>最终一致性</strong>，因为整个过程是异步的，<strong>每个系统只要保证它自己那一部分的事务就行了</strong>。</p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ实战</title>
    <url>/2021/05/24/RocketMQ%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<p>了解RocketMQ的简单实战</p>
<a id="more"></a>

<h1 id="RocketMQ安装"><a href="#RocketMQ安装" class="headerlink" title="RocketMQ安装"></a>RocketMQ安装</h1><h2 id="window环境"><a href="#window环境" class="headerlink" title="window环境"></a>window环境</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><strong>下载</strong></p>
<p><a href="https://www.apache.org/dyn/closer.cgi?path=rocketmq/4.8.0/rocketmq-all-4.8.0-bin-release.zip">下载地址</a></p>
<p><strong>解压到安装目录</strong></p>
<p><img src="/images/image-20210524170858192.png" alt="image-20210524170858192"></p>
<p><strong>配置系统环境变量</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">变量名：ROCKETMQ_HOME</span><br><span class="line">变量值：MQ解压路径\MQ文件夹名</span><br></pre></td></tr></table></figure>
<p><img src="/images/image-20210524171242901.png" alt="image-20210524171242901"></p>
<p>配置完毕后可能需要重启电脑</p>
<p><strong>启动NameServer</strong></p>
<p>在bin目录下打开cmd</p>
<p>执行<code>start mqnamesrv.cmd</code>可在另一个窗口启动<code>NameServer</code></p>
<p><img src="/images/image-20210524185157066.png" alt="image-20210524185157066"></p>
<p><strong>启动Broker</strong></p>
<p>在bin目录下打开cmd</p>
<p>执行<code>start mqbroker.cmd -n 127.0.0.1:9876 autoCreateTopicEnable=true</code></p>
<p>可以可在另一个窗口启动<code>Broker</code>，并连接上之前启动的服务器</p>
<p><img src="/images/image-20210524185236973.png" alt="image-20210524185236973"></p>
<h3 id="可视化插件安装"><a href="#可视化插件安装" class="headerlink" title="可视化插件安装"></a>可视化插件安装</h3><p>可视化插件主要是可视化的监控，可以看到消息消费的具体情况</p>
<p><strong>下载</strong></p>
<p>首先在github上下载相关zip包</p>
<p><a href="https://github.com/apache/rocketmq-externals.git">下载地址</a></p>
<p><strong>解压</strong></p>
<p>同理解压到相关路径</p>
<p><strong>修改配置文件</strong></p>
<p>修改进入<code>\rocketmq-externals-master\rocketmq-console\src\main\resources</code><br>下的<code>application.properties</code>配置文件</p>
<p>这里我修改了其服务器默认端口为<code>8888</code>以及监听的是本机的rocketmq</p>
<p><img src="/images/image-20210524190511648.png" alt="image-20210524190511648"></p>
<p><strong>编译项目</strong></p>
<p>在<code>\rocketmq-externals-master\rocketmq-console</code>下打开cmd</p>
<p>执行<code>mvn clean package -Dmaven.test.skip=true</code>编译插件</p>
<p><strong>启动插件</strong></p>
<p>最后在同级的target目录下，打开cmd</p>
<p>执行<code>java -jar rocketmq-console-ng-2.0.0.jar</code>启动插件</p>
<p>可以在浏览器中访问目的ip+端口查看</p>
<p><img src="/images/image-20210524193036744.png" alt="image-20210524193036744"></p>
<h2 id="linux环境"><a href="#linux环境" class="headerlink" title="linux环境"></a>linux环境</h2><p>同windows，我利用ftp将zip文件复制到了Linux服务器中</p>
<p><code>unzip rocketmq-all-4.8.0-bin-release.zip &amp;&amp; mv rocketmq-all-4.8.0-bin-release /root/rocketmq</code></p>
<p>然后将其解压到<code>root</code>目录下</p>
<h1 id="RocketMQ实战"><a href="#RocketMQ实战" class="headerlink" title="RocketMQ实战"></a>RocketMQ实战</h1>]]></content>
      <categories>
        <category>中间件</category>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集</title>
    <url>/2021/05/31/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    <content><![CDATA[<p>学会并查集的写法，并用其来解决问题</p>
<a id="more"></a>

<h1 id="并查集实现"><a href="#并查集实现" class="headerlink" title="并查集实现"></a>并查集实现</h1><p>并查集的主要功能和作用都体现的其命名中</p>
<p>首先你可以把其理解成<strong>一个集合，其包含许多节点</strong>，这些节点之间可能存在<strong>父子、祖先后辈、或者连通的关系</strong>，我们可以通过<strong>查两个节点的祖先是否相同判断两个节点之间是否有关系</strong>，通过<strong>合并来将有关系的节点分类在一起</strong></p>
<p>更为巧妙的是，并查集一般用<strong>数组</strong>实现了这个集，其关键的查函数也能通过优化，在O(1)的实现查找，从而优化并的过程</p>
<p>下面是其实现原理：</p>
<p>我们用一个数组叫father数组或者前驱数组保存节点的前驱或者是父节点信息，那么查找一个节点的时候，我们可以不断的找其父节点，直到某个父节点的节点是其本身</p>
<p>而合并两个节点时，查找两个节点的祖先是否一致判断是否需要合并，一致说明已经合并，不一致说明未合并，最简单的合并方法就是将一个节点的祖先前驱指向另一个节点的祖先即可</p>
<p>下面是具体实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UFS</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] father;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] size;</span><br><span class="line"></span><br><span class="line">    UFS(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = n;</span><br><span class="line">        father = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        size = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ; i++)&#123;</span><br><span class="line">            father[i] = i;</span><br><span class="line">            size[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 递归写法</span></span><br><span class="line">        <span class="keyword">if</span>(x != father[x])</span><br><span class="line">            father[x] = find(father[x]);</span><br><span class="line">        <span class="keyword">return</span>  father[x];</span><br><span class="line">        <span class="comment">/* 非递归1</span></span><br><span class="line"><span class="comment">        while(x != father[x])&#123;</span></span><br><span class="line"><span class="comment">            father[x] = father[father[x]];</span></span><br><span class="line"><span class="comment">            x = father[x];</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return  x;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">/* 非递归2</span></span><br><span class="line"><span class="comment">        int temp = x;</span></span><br><span class="line"><span class="comment">        while(temp != father[temp])</span></span><br><span class="line"><span class="comment">            temp = father[temp];</span></span><br><span class="line"><span class="comment">        while(x != temp)&#123;</span></span><br><span class="line"><span class="comment">            int l = father[x];</span></span><br><span class="line"><span class="comment">            father[x] = temp;</span></span><br><span class="line"><span class="comment">            x = l;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> f1 = find(a);</span><br><span class="line">        <span class="keyword">int</span> f2 = find(b);</span><br><span class="line">        <span class="keyword">if</span>(f1 == f2)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span>(size[f1] &gt;= size[f2])&#123;</span><br><span class="line">            father[f2] = f1;</span><br><span class="line">            size[f1] += size[f2];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            father[f1] = f2;</span><br><span class="line">            size[f2] += size[f1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上诉做了两个优化，</p>
<ul>
<li>在find的时候将每个节点都指向其祖先，使查找更为高效</li>
<li>在union的时候将节点少的一类并入节点多的一类，减少后面再查找的指向操作</li>
</ul>
<p>其中，find的实现有三种</p>
<ul>
<li>第一种是递归实现，在不爆栈的情况下很简洁</li>
<li>第二种是比较简洁的迭代实现，所有树高不会超过三，参考<code>labuladong</code>的算法书</li>
<li>第三种也是迭代实现，效果和第一种一致,修改指向时比2耗时多，但是修改后查找时快</li>
</ul>
<h1 id="牛刀小试1"><a href="#牛刀小试1" class="headerlink" title="牛刀小试1"></a>牛刀小试1</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><strong>990. 等式方程的可满足性</strong></p>
<p><a href="https://leetcode-cn.com/problems/satisfiability-of-equality-equations/">力扣链接</a></p>
<p>给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 <code>equations[i]</code> 的长度为 <code>4</code>，并采用两种不同的形式之一：<code>&quot;a==b&quot;</code> 或 <code>&quot;a!=b&quot;</code>。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。</p>
<p>只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 <code>true</code>，否则返回 <code>false</code>。 </p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[&quot;a&#x3D;&#x3D;b&quot;,&quot;b!&#x3D;a&quot;]</span><br><span class="line">输出：false</span><br><span class="line">解释：如果我们指定，a &#x3D; 1 且 b &#x3D; 1，那么可以满足第一个方程，但无法满足第二个方程。没有办法分配变量同时满足这两个方程。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[&quot;b&#x3D;&#x3D;a&quot;,&quot;a&#x3D;&#x3D;b&quot;]</span><br><span class="line">输出：true</span><br><span class="line">解释：我们可以指定 a &#x3D; 1 且 b &#x3D; 1 以满足满足这两个方程。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[&quot;a&#x3D;&#x3D;b&quot;,&quot;b&#x3D;&#x3D;c&quot;,&quot;a&#x3D;&#x3D;c&quot;]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= equations.length &lt;= 500</code></li>
<li><code>equations[i].length == 4</code></li>
<li><code>equations[i][0]</code> 和 <code>equations[i][3]</code> 是小写字母</li>
<li><code>equations[i][1]</code> 要么是 <code>&#39;=&#39;</code>，要么是 <code>&#39;!&#39;</code></li>
<li><code>equations[i][2]</code> 是 <code>&#39;=&#39;</code></li>
</ol>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>上题显然要判断方程是否合法，显然两个元素即相等，又不等方程就不合法</p>
<p>我们思路是先构建相等集：把相等视为两个元素有关系，用并查集将其并在一起</p>
<p>最后再查不相等的元素是否相等判断方程是否合法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equationsPossible</span><span class="params">(String[] equations)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        UFS ufs = <span class="keyword">new</span> UFS(<span class="number">26</span>);</span><br><span class="line">        <span class="comment">// 构建相等关系</span></span><br><span class="line">        <span class="keyword">for</span>(String str: equations)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(<span class="number">1</span>) == <span class="string">&#x27;=&#x27;</span>)</span><br><span class="line">                ufs.union(str.charAt(<span class="number">0</span>) - <span class="string">&#x27;a&#x27;</span>,str.charAt(<span class="number">3</span>) - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 排查不等关系</span></span><br><span class="line">        <span class="keyword">for</span>(String str : equations)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(<span class="number">1</span>) == <span class="string">&#x27;!&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(find(str.charAt(<span class="number">0</span>) - <span class="string">&#x27;a&#x27;</span>) == find(str.charAt(<span class="number">3</span>) - <span class="string">&#x27;a&#x27;</span>))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UFS</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] father;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] size;</span><br><span class="line"></span><br><span class="line">    UFS(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = n;</span><br><span class="line">        father = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        size = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ; i++)&#123;</span><br><span class="line">            father[i] = i;</span><br><span class="line">            size[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 递归写法</span></span><br><span class="line">        <span class="keyword">if</span>(x != father[x])</span><br><span class="line">            father[x] = find(father[x]);</span><br><span class="line">        <span class="keyword">return</span>  father[x];</span><br><span class="line">        <span class="comment">/* 非递归1</span></span><br><span class="line"><span class="comment">        while(x != father[x])&#123;</span></span><br><span class="line"><span class="comment">            father[x] = father[father[x]];</span></span><br><span class="line"><span class="comment">            x = father[x];</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return  x;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">/* 非递归2</span></span><br><span class="line"><span class="comment">        int temp = x;</span></span><br><span class="line"><span class="comment">        while(temp != father[temp])</span></span><br><span class="line"><span class="comment">            temp = father[temp];</span></span><br><span class="line"><span class="comment">        while(x != temp)&#123;</span></span><br><span class="line"><span class="comment">            int l = father[x];</span></span><br><span class="line"><span class="comment">            father[x] = temp;</span></span><br><span class="line"><span class="comment">            x = l;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> f1 = find(a);</span><br><span class="line">        <span class="keyword">int</span> f2 = find(b);</span><br><span class="line">        <span class="keyword">if</span>(f1 == f2)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span>(size[f1] &gt;= size[f2])&#123;</span><br><span class="line">            father[f2] = f1;</span><br><span class="line">            size[f1] += size[f2];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            father[f1] = f2;</span><br><span class="line">            size[f2] += size[f1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="牛刀小试2"><a href="#牛刀小试2" class="headerlink" title="牛刀小试2"></a>牛刀小试2</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p><strong>547. 省份数量</strong></p>
<p><a href="https://leetcode-cn.com/problems/number-of-provinces/">力扣链接</a></p>
<p>有 <code>n</code> 个城市，其中一些彼此相连，另一些没有相连。如果城市 <code>a</code> 与城市 <code>b</code> 直接相连，且城市 <code>b</code> 与城市 <code>c</code> 直接相连，那么城市 <code>a</code> 与城市 <code>c</code> 间接相连。</p>
<p><strong>省份</strong> 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p>
<p>给你一个 <code>n x n</code> 的矩阵 <code>isConnected</code> ，其中 <code>isConnected[i][j] = 1</code> 表示第 <code>i</code> 个城市和第 <code>j</code> 个城市直接相连，而 <code>isConnected[i][j] = 0</code> 表示二者不直接相连。</p>
<p>返回矩阵中 <strong>省份</strong> 的数量。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/images/graph1.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：isConnected &#x3D; [[1,1,0],[1,1,0],[0,0,1]]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><img src="/images/graph2.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：isConnected &#x3D; [[1,0,0],[0,1,0],[0,0,1]]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>


<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 200</code></li>
<li><code>n == isConnected.length</code></li>
<li><code>n == isConnected[i].length</code></li>
<li><code>isConnected[i][j]</code> 为 <code>1</code> 或 <code>0</code></li>
<li><code>isConnected[i][i] == 1</code></li>
<li><code>isConnected[i][j] == isConnected[j][i]</code></li>
</ul>
<h2 id="思考-1"><a href="#思考-1" class="headerlink" title="思考"></a>思考</h2><p>该题主要是将有相连的城市合并，视为一个省，最后考察有多少个最终祖先，在图中既是看有多少个连通分量</p>
<p>该题主要是利用好前面给的并查集实现的count，count最开始和节点数相同，之后没合并一次节点count-1，则count就是连通分量个数，即答案</p>
<p>下面是代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] isConnected)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = isConnected.length;</span><br><span class="line">        UFS ufs = <span class="keyword">new</span> UFS(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(isConnected[i][j] == <span class="number">1</span>)</span><br><span class="line">                    ufs.union(i,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ufs.getCount();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UFS</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] father;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] size;</span><br><span class="line"></span><br><span class="line">    UFS(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = n;</span><br><span class="line">        father = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        size = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ; i++)&#123;</span><br><span class="line">            father[i] = i;</span><br><span class="line">            size[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 递归写法</span></span><br><span class="line">        <span class="keyword">if</span>(x != father[x])</span><br><span class="line">            father[x] = find(father[x]);</span><br><span class="line">        <span class="keyword">return</span>  father[x];</span><br><span class="line">        <span class="comment">/* 非递归1</span></span><br><span class="line"><span class="comment">        while(x != father[x])&#123;</span></span><br><span class="line"><span class="comment">            father[x] = father[father[x]];</span></span><br><span class="line"><span class="comment">            x = father[x];</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return  x;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">/* 非递归2</span></span><br><span class="line"><span class="comment">        int temp = x;</span></span><br><span class="line"><span class="comment">        while(temp != father[temp])</span></span><br><span class="line"><span class="comment">            temp = father[temp];</span></span><br><span class="line"><span class="comment">        while(x != temp)&#123;</span></span><br><span class="line"><span class="comment">            int l = father[x];</span></span><br><span class="line"><span class="comment">            father[x] = temp;</span></span><br><span class="line"><span class="comment">            x = l;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> f1 = find(a);</span><br><span class="line">        <span class="keyword">int</span> f2 = find(b);</span><br><span class="line">        <span class="keyword">if</span>(f1 == f2)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span>(size[f1] &gt;= size[f2])&#123;</span><br><span class="line">            father[f2] = f1;</span><br><span class="line">            size[f1] += size[f2];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            father[f1] = f2;</span><br><span class="line">            size[f2] += size[f1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>经典数据结构</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>信息表示和处理</title>
    <url>/2021/06/01/%E4%BF%A1%E6%81%AF%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>了解计算机如何用二进制表示数字和其他形式数据</p>
<a id="more"></a>

<h1 id="信息存储"><a href="#信息存储" class="headerlink" title="信息存储"></a>信息存储</h1><p><strong>1.位、字节、字</strong></p>
<p>大多数计算机使用8位的块、即<strong>字节</strong>作为最小可寻址的<strong>内存单元</strong></p>
<p>每个字节都有一个唯一的数字来标识，称为其<strong>地址</strong>，所有的可能地址集合称为<strong>虚拟地址空间</strong>，每台计算机有一个<strong>字长</strong>，而每个虚拟地址是以一个字来编码的，我们常见的32位或者64位机器，多少位表示的就是其字长大小，故32位机器的虚拟地址空间限制为4GB，而64位虚拟地址内存为16EB</p>
<p><strong>2.对象存储和字节顺序</strong></p>
<p>在计算机中肯定有一些对象不是一个字节的大小，对于<strong>多字节对象，大多被存储为连续的字节序列</strong></p>
<p>假设我们用16进制数表示地址</p>
<p>一个32位的int 变量x，假设其起始字节地址是<code>0X100</code>,按照顺序存储，其剩下的3个字节地址就是<code>0x101</code>、<code>0x102</code>、<code>0x103</code></p>
<p>现在存在一个问题，<code>x = 01 23 45 67(十六进制表示)</code> ，那x的具体的值是怎样存储：</p>
<ul>
<li><p><strong>大端法：最高位有效字节存储在前</strong>，即从<code>0X100</code>、<code>0x101</code>、<code>0x102</code>、<code>0x103</code>分别存储<code>01 23 45 67</code></p>
</li>
<li><p><strong>小端法：最低位有效字节存储在前</strong>，即从<code>0X100</code>、<code>0x101</code>、<code>0x102</code>、<code>0x103</code>分别存储<code>67 45 23 01</code></p>
</li>
</ul>
<p>大多Intel兼容机只采用小端方式</p>
<p><strong>3.对位进行操作</strong></p>
<p>C语言和Java都支持对<strong>基本数据类型</strong>进行<strong>按位计算</strong></p>
<p>常见运算有<code>|,&amp;,~,^</code>(或、与、非、异或)</p>
<p>还有一些移位运算</p>
<ul>
<li>左移：<code>&lt;&lt;</code> ,x向左移动k位，丢弃最高位的k为，并在左端补k个0</li>
<li>右移<ul>
<li><code>&gt;&gt;</code>，算术右移，向右端补k个0</li>
<li><code>&gt;&gt;&gt;</code>,逻辑右移，向右端补k个最高有效位（符号位）的值，<strong>注意：</strong>仅Java有此运算符，而C语言仅有<code>&gt;&gt;</code>运算符，对于无符号数，是逻辑的，对于有符号数，C语言标准没有明确定义是哪种，但实际机器一般是算术右移</li>
</ul>
</li>
</ul>
<h1 id="整数表示"><a href="#整数表示" class="headerlink" title="整数表示"></a>整数表示</h1><p><strong>1.无符号数编码</strong></p>
<p>在C语言中有无符号整数的概念，Java只支持有符号数</p>
<p>定义：假设对于一个w位的无符号整数，用二进制比特位可以表示为<code>[xw-1 , xw-2 , … , x2 , x1 , x0]</code>。那么我们可以用一个函数表示如下：</p>
<p><img src="/images/image-20210601164505380.png" alt="image-20210601164505380"></p>
<p><strong>2.有符号数编码（补码编码）</strong></p>
<p>大多机器采用的编码方式</p>
<p>定义：假设对于一个w位的有符号整数（所有机器基本用补码表示），用二进制比特位可以表示为<code>[xw-1 , xw-2 , … , x2 , x1 , x0]</code>。那么我们可以用一个函数表示如下：</p>
<p><img src="/images/image-20210601165136066.png" alt="image-20210601165136066"></p>
<p>正是如此，我们可以理解Java中byte<code>10000000</code>-128比如正数范围多1的原因</p>
<p><strong>3.反码编码</strong></p>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>深入理解计算机系统</category>
      </categories>
      <tags>
        <tag>计算机信息表示</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka基础</title>
    <url>/2021/07/01/Kafka%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>了解优秀消息中间件Kafka的基本原理和特点</p>
<a id="more"></a>

<h1 id="一、架构"><a href="#一、架构" class="headerlink" title="一、架构"></a>一、架构</h1><p>Kafka是最初由Linkedin公司开发，是一个分布式、支持分区的（partition）、多副本的（replica），基于Zookeeper协调的分布式消息系统</p>
<p>Kafka的架构主要同下图所示：</p>
<p><img src="/images/image-20210704104213427.png" alt="image-20210704104213427"></p>
<p>不同于RocketMQ的NameServer，其利用了Zookeeper来进行消息注册，但是思想有很多相似之处</p>
<p>两者都有Topic的概念，Kafka的一个<strong>Topic</strong>下可以有多个<strong>分区</strong>，在RocketMQ中对应多个消息队列，每个分区一般也只能由一个消费者消费，多个分区布置到不同的Broker即机器上</p>
<p>为保证<strong>高可用、高可靠</strong>，RocketMQ的Broker有<strong>主从同步模式</strong>，而Kafka我更愿意称为<strong>主从切换</strong>，则也分区内容同步到多个Broker上，其一台Broker上的某分区作为<strong>Leader</strong>，其他机器上的该分区作为<strong>Follower</strong>，其中进行了<strong>读写分离</strong>，Leader可读可写，而Follower只能进行读，值得注意一点：<strong>Kafka的Leader挂了会选出新的Leader，而RocketMQ的主从模式不能切换，即主节点挂了就无法再进行写</strong>。</p>
<p>总的来说，两者在架构上的相近之处很多，但是具体的消息存储结构还是有所差异，下面就讲解存储差异</p>
<h1 id="二、存储"><a href="#二、存储" class="headerlink" title="二、存储"></a>二、存储</h1><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>Kafka的存储是按Partition来分的，一个Partition就是一个<strong>文件夹</strong>，每个Partition文件有多个<strong>Segment,**每个Segment包含</strong>.index文件、.log文件、.timeindex文件**三种文件，文件夹命名规则为规则是<topic_name>_<partition_id>，其中：</p>
<ul>
<li>日志文件记录存储消息</li>
<li>索引文件记录部分消息的索引</li>
<li>时间索引文件记录了与时间戳对应的索引，这里将不再细谈</li>
</ul>
<p>而每一条存储的消息，会包含多个字段，其中最重要的有以下几个信息：</p>
<ul>
<li><p><strong>offset</strong>:记录号 </p>
</li>
<li><p><strong>position</strong>：偏移量，在日志文件在定位消息位置的依据</p>
</li>
<li><p>keysize 和 valuesize ： key 和 value 的大小</p>
</li>
<li><p>其他信息</p>
</li>
</ul>
<p>上诉内容我们可以理解为头部信息，最后由payload部分:存储消息的具体内容</p>
<p>partition 全局的第一个 segment从 0 开始，每个Segment有一定大小，后续每个 segment 文件名为上一个 segment文件最后一条消息的 offset 值进行递增，Segment内部的文件，也采用这条的offset命名法</p>
<p><strong>而消息则是按顺序放入最后Segment文件中</strong></p>
<p>了解这些基础后，我们就可以更深一步认识消息的生产和消费过程。</p>
<h2 id="消息生产"><a href="#消息生产" class="headerlink" title="消息生产"></a>消息生产</h2><p>Kafka的消息生产主要有几个关键点</p>
<ul>
<li><p><strong>顺序写入</strong>：收到消息后Kafka会把数据插入到Segment文件末尾，提高读写硬盘的速度</p>
</li>
<li><p><strong>零拷贝：</strong>利用Java的<strong>FileChannel</strong>，进行数据传输，实现零拷贝，减少了上下文切换此次数和消息复制</p>
<p>传统数据传输方式：</p>
<p><img src="/images/image-20210704170414049.png" alt="image-20210704170414049"></p>
<p>基础的零拷贝后数据传输方式：</p>
<p><img src="/images/image-20210704170617192.png" alt="image-20210704170617192"></p>
<p>利用DMA的零拷贝：</p>
<p><img src="/images/image-20210704171206538.png" alt="image-20210704171206538"></p>
<p>Kafka正是利用Java的<strong>FileChannel</strong>，和DMA，只用将磁盘文件的数据复制到页面缓存中，然后将数据从页面缓存直接发送到网络中，减少了两次上下文切换和数据拷贝</p>
</li>
<li><p><strong>批量发送：</strong>kafka采用异步发送的机制，当发送一条消息时，消息并没有发送到broker而是缓存起来，然后直接向业务返回成功，当缓存的消息达到一定数量时再批量发送。此时减少了网络io，从而提高了消息发送的性能，但是如果消息发送者宕机，会导致消息丢失，业务出错，所以理论上kafka利用此机制提高了io性能却降低了可靠性</p>
</li>
</ul>
<h2 id="消息消费"><a href="#消息消费" class="headerlink" title="消息消费"></a>消息消费</h2><p>Kafka消费者进行消息消费时采用的也是<strong>FileChannel</strong>方式，并且采用<strong>Pull模式</strong>，而RocketMQ默认采用<strong>Push+长轮询模式</strong></p>
<p>等到具体读取某条消息时，消费者保留者某个分区的offset，当读取消息时，向Broker的发送带有offset参数，按以下步骤查询：</p>
<ul>
<li>根据offset，二分查找到对应Segment</li>
<li>找到索引文件后，根据 offset 进行定位，找到索引文件中的匹配范围的偏移量position，注意索引文件采用的是<strong>稀疏索引</strong></li>
<li>由于索引文件值保存了部分索引信息，最后需要到对应的 log 文件中，从 position处开始查找 offset 对应的消息，将每条消息的 offset 与目标 offset 进行比较，直到找到消息</li>
</ul>
<p><img src="/images/image-20210704113852478.png" alt="image-20210704113852478"></p>
<h2 id="与RocketMQ细节对比"><a href="#与RocketMQ细节对比" class="headerlink" title="与RocketMQ细节对比"></a>与RocketMQ细节对比</h2><ul>
<li><p>RocketMQ存储机制是在<strong>CommitLog</strong>下<strong>混合型存储</strong>,以提高写入效率，自然而然，也就导致了索引文件<strong>ConsumeQueue</strong>和Kafka不一致，不能做稀疏索引。当topic、partition越来越多的情况下，Kafka的写性能会明显下降，而RocketMQ性能稳定。</p>
</li>
<li><p>此外，Kafka Broker是无状态的：这意味着<strong>消费者必须维护已消费的状态信息</strong>。而RocketMQ则是在ConsumeQueue上维护了 <code>ConsumeOffset</code> 即每个消费者组的消费位置，这里有个好处就是方便由消费者回到之前的offset，比较简单的实现<strong>消息失败重试</strong></p>
</li>
<li><p>当生产者生产消息时，Kafka客户端采用了一个双端队列，引入了<strong>批处理思想</strong>，可以控制批次大小和等待时间完成批处理发送消息，提高IO速度，但是和RocketMq相比，可用性降低</p>
</li>
<li><p>当消费者消费消息时，Kafka采用Pull模式，而RocketMQ即可以采用Pull也可以采用Push模式，默认是Push+长轮询模式</p>
</li>
</ul>
<h1 id="三、功能特性差异"><a href="#三、功能特性差异" class="headerlink" title="三、功能特性差异"></a>三、功能特性差异</h1><p>首先不可否认，Kafka的吞吐量十分优秀，但是消息选型过程中，我们不仅仅要参考其性能，还有从功能性做出考虑</p>
<p>下面是两者一些差异性功能</p>
<h2 id="消息搜索"><a href="#消息搜索" class="headerlink" title="消息搜索"></a>消息搜索</h2><p>RocketMQ 基于indexFile，在producer发消息时指定消息的key，之后可以根据key来搜索这条消息。原理其实就是个基于磁盘实现的hashMap。</p>
<p>Kafka不支持消息搜索。</p>
<h2 id="消息过滤"><a href="#消息过滤" class="headerlink" title="消息过滤"></a>消息过滤</h2><p>RocketMQ支持消息的tags，消费者组订阅可以指定tags订阅，tag过滤的话在broker端和consumer端都有过滤，broker端只能根据hashCode过滤，hashCode有可能冲突，所以还需要在consumer端根据tag的值进行过滤。<br> Kafka不支持消息按tag过滤。</p>
<h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><p>RocketMQ主要通过<strong>半消息</strong>、<strong>消息回查</strong>和<strong>二次确认</strong>等操作实现分布式事务</p>
<p>Kafka不支持消息按分布式事务。</p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring启动和Bean生命周期</title>
    <url>/2021/07/02/Spring%E5%90%AF%E5%8A%A8%E5%92%8CBean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E5%89%AF%E6%9C%AC/</url>
    <content><![CDATA[<p>主要通过理清Spring框架启动和Bean生命周期，明白我们可以在Spring中可以做到什么，或者清楚Spring提供了那些向外的扩展点</p>
<a id="more"></a>

<h1 id="Spring框架启动"><a href="#Spring框架启动" class="headerlink" title="Spring框架启动"></a>Spring框架启动</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>我们主要以下述代码分析Spring 启动流程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Demo2Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然上诉代码只有一行，但是在内部多次调用和实际效果应该如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  			SpringApplication application. = <span class="keyword">new</span> SpringApplication(Demo2Application.class);</span><br><span class="line">        application.run(args);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="一、SpringApplication实例化"><a href="#一、SpringApplication实例化" class="headerlink" title="一、SpringApplication实例化"></a>一、SpringApplication实例化</h2><p>首先理清SpringApplication在实例化时做了啥</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">  </span><br><span class="line">			<span class="comment">// 一系列参数设置</span></span><br><span class="line">  			......</span><br><span class="line">         </span><br><span class="line">       </span><br><span class="line">       <span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">  			</span><br><span class="line">  			<span class="comment">// primarySources为传入的Demo2Application.class</span></span><br><span class="line">       Assert.notNull(primarySources, <span class="string">&quot;PrimarySources must not be null&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">       <span class="keyword">this</span>.primarySources = <span class="keyword">new</span> LinkedHashSet(Arrays.asList(primarySources));</span><br><span class="line">  			</span><br><span class="line">  			<span class="comment">// 判断是否是web应用</span></span><br><span class="line">       <span class="keyword">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">  </span><br><span class="line">  			</span><br><span class="line">       <span class="keyword">this</span>.bootstrapRegistryInitializers = <span class="keyword">this</span>.getBootstrapRegistryInitializersFromSpringFactories();</span><br><span class="line">   <span class="comment">// 关键初始化两个操作，设置Initailizers、和Listeners</span></span><br><span class="line">  <span class="keyword">this</span>.setInitializers(<span class="keyword">this</span>.getSpringFactoriesInstances(ApplicationContextInitializer.class));</span><br><span class="line">       <span class="keyword">this</span>.setListeners(<span class="keyword">this</span>.getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">       <span class="keyword">this</span>.mainApplicationClass = <span class="keyword">this</span>.deduceMainApplicationClass();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这里的<strong>初始化器</strong>和<strong>监听器</strong>的加载主要依靠默认的Spring配置文件<code>spring.factories</code></p>
<p>首先通过利用**<code>loadFactoryNames</code>方法<strong>从路径<code>MEAT-INF/spring.factorie</code>文件中获取启动</strong>初始化器<strong>和</strong>监听器<strong>所需要的配置类类名，并利用</strong>反射**去生成这些配置的实例对象。</p>
<p>至此SpringApplication的实例化完成，接下来就尝试启动服务、项目了</p>
<h2 id="二、SpringApplication-run"><a href="#二、SpringApplication-run" class="headerlink" title="二、SpringApplication#run"></a>二、SpringApplication#run</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">  			<span class="comment">// StopWatch其实是一个监控的东西，可以监控每个步骤都花了多少时间，占比多少</span></span><br><span class="line">        StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">        stopWatch.start();</span><br><span class="line">        DefaultBootstrapContext bootstrapContext = <span class="keyword">this</span>.createBootstrapContext();</span><br><span class="line">        ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.configureHeadlessProperty();</span><br><span class="line">  			<span class="comment">// 同之前的监听器一样，也去路径MEAT-INF/spring.factories下找到所有的ApplicationContextInitializer</span></span><br><span class="line">        SpringApplicationRunListeners listeners = <span class="keyword">this</span>.getRunListeners(args);</span><br><span class="line">  			<span class="comment">// 启动监听，调用每个SpringApplicationRunListener的starting方法</span></span><br><span class="line">        listeners.starting(bootstrapContext, <span class="keyword">this</span>.mainApplicationClass);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(args);</span><br><span class="line">          	<span class="comment">// 准备环境，触发监听事件——调用每个SpringApplicationRunListener的environmentPrepared方法</span></span><br><span class="line">            ConfigurableEnvironment environment = <span class="keyword">this</span>.prepareEnvironment(listeners, bootstrapContext, applicationArguments);</span><br><span class="line">            <span class="keyword">this</span>.configureIgnoreBeanInfo(environment);</span><br><span class="line">            Banner printedBanner = <span class="keyword">this</span>.printBanner(environment);</span><br><span class="line">          	<span class="comment">// 依据是否为web环境创建web容器或者普通的IOC容器</span></span><br><span class="line">            context = <span class="keyword">this</span>.createApplicationContext();</span><br><span class="line">            context.setApplicationStartup(<span class="keyword">this</span>.applicationStartup);</span><br><span class="line">          	<span class="comment">// 准备上下文环境</span></span><br><span class="line">            <span class="keyword">this</span>.prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);	</span><br><span class="line">        		<span class="comment">// 刷新容器，完成组件的扫描，创建，加载等</span></span><br><span class="line">            <span class="keyword">this</span>.refreshContext(context);</span><br><span class="line">          	<span class="comment">// 启动服务</span></span><br><span class="line">            <span class="keyword">this</span>.afterRefresh(context, applicationArguments);</span><br><span class="line">            stopWatch.stop();</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">                (<span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass)).logStarted(<span class="keyword">this</span>.getApplicationLog(), stopWatch);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            listeners.started(context);</span><br><span class="line">            <span class="keyword">this</span>.callRunners(context, applicationArguments);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var10) &#123;</span><br><span class="line">            <span class="keyword">this</span>.handleRunFailure(context, var10, listeners);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(var10);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            listeners.running(context);</span><br><span class="line">            <span class="keyword">return</span> context;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var9) &#123;</span><br><span class="line">            <span class="keyword">this</span>.handleRunFailure(context, var9, (SpringApplicationRunListeners)<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(var9);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>其中服务运行起来重要的操作就在<strong>prepareContext和refreshContext</strong>中</p>
<p>下面将会仔细介绍</p>
<h3 id="prepareContext"><a href="#prepareContext" class="headerlink" title="prepareContext"></a>prepareContext</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepareContext</span><span class="params">(DefaultBootstrapContext bootstrapContext, ConfigurableApplicationContext context, ConfigurableEnvironment environment, SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner)</span> </span>&#123;</span><br><span class="line">  		</span><br><span class="line">  		<span class="comment">// 将环境放入容器中</span></span><br><span class="line">     context.setEnvironment(environment);</span><br><span class="line">     <span class="keyword">this</span>.postProcessApplicationContext(context);</span><br><span class="line">  		<span class="comment">// 前面的初始化器生效了</span></span><br><span class="line">     <span class="keyword">this</span>.applyInitializers(context);</span><br><span class="line">  		<span class="comment">// 触发监听事件——调用每个SpringApplicationRunListeners的contextPrepared方法</span></span><br><span class="line">     listeners.contextPrepared(context);</span><br><span class="line">     bootstrapContext.close(context);</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">         <span class="keyword">this</span>.logStartupInfo(context.getParent() == <span class="keyword">null</span>);</span><br><span class="line">         <span class="keyword">this</span>.logStartupProfileInfo(context);</span><br><span class="line">     &#125;</span><br><span class="line">	</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">     ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();</span><br><span class="line">  		<span class="comment">// 向容器中注入单例的applicationArguments与printedBanner</span></span><br><span class="line">     beanFactory.registerSingleton(<span class="string">&quot;springApplicationArguments&quot;</span>, applicationArguments);</span><br><span class="line">     <span class="keyword">if</span> (printedBanner != <span class="keyword">null</span>) &#123;</span><br><span class="line">         beanFactory.registerSingleton(<span class="string">&quot;springBootBanner&quot;</span>, printedBanner);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> DefaultListableBeanFactory) &#123;</span><br><span class="line">         ((DefaultListableBeanFactory)beanFactory).setAllowBeanDefinitionOverriding(<span class="keyword">this</span>.allowBeanDefinitionOverriding);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">this</span>.lazyInitialization) &#123;</span><br><span class="line">         context.addBeanFactoryPostProcessor(<span class="keyword">new</span> LazyInitializationBeanFactoryPostProcessor());</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     Set&lt;Object&gt; sources = <span class="keyword">this</span>.getAllSources();</span><br><span class="line">     Assert.notEmpty(sources, <span class="string">&quot;Sources must not be empty&quot;</span>);</span><br><span class="line">  		<span class="comment">// Load the sources，即带@SpringBootApplication注解的启动类</span></span><br><span class="line">     <span class="keyword">this</span>.load(context, sources.toArray(<span class="keyword">new</span> Object[<span class="number">0</span>]));</span><br><span class="line">    <span class="comment">// 触发监听事件——调用每个SpringApplicationRunListeners的contextLoaded方法</span></span><br><span class="line">     listeners.contextLoaded(context);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>该方法准备了容器的上下文，但是注意关于<code>Spring Bean</code>的操作还没有进行，而这重中之重，都在下一步的<code>refreshContext</code>方法中</p>
<h3 id="refreshContext"><a href="#refreshContext" class="headerlink" title="refreshContext"></a>refreshContext</h3><p>该方法最终会调用<code>AbstractApplicationContext</code>的<strong>refresh方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">  			<span class="comment">// 加锁，保证系统初始化工作不会被其他操作影响到。</span></span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">            StartupStep contextRefresh = <span class="keyword">this</span>.applicationStartup.start(<span class="string">&quot;spring.context.refresh&quot;</span>);</span><br><span class="line">          	</span><br><span class="line">            <span class="comment">// 记录下启动时间，设置好标志位等准备工作</span></span><br><span class="line">            <span class="keyword">this</span>.prepareRefresh();</span><br><span class="line">          	<span class="comment">// 获取BeanFactory，并进行XML文件读取</span></span><br><span class="line">            ConfigurableListableBeanFactory beanFactory = <span class="keyword">this</span>.obtainFreshBeanFactory();</span><br><span class="line">          	<span class="comment">// 配置BeanFactory属性，进行功能填充</span></span><br><span class="line">            <span class="keyword">this</span>.prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              	<span class="comment">// 允许在context子类中对bean factory进行后处理</span></span><br><span class="line">                <span class="keyword">this</span>.postProcessBeanFactory(beanFactory);</span><br><span class="line">                StartupStep beanPostProcess = <span class="keyword">this</span>.applicationStartup.start(<span class="string">&quot;spring.context.beans.post-process&quot;</span>);</span><br><span class="line">                <span class="comment">// 激活各种beanFactory处理器,修改BeanDefintion</span></span><br><span class="line">                <span class="keyword">this</span>.invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">              	<span class="comment">// 注册拦截Bean创建的Bean处理器，这里只是注册，真正的调用实在getBean时候 </span></span><br><span class="line">                <span class="keyword">this</span>.registerBeanPostProcessors(beanFactory);</span><br><span class="line">                beanPostProcess.end();</span><br><span class="line">              	<span class="comment">// 国际化处理</span></span><br><span class="line">                <span class="keyword">this</span>.initMessageSource();</span><br><span class="line">                <span class="keyword">this</span>.initApplicationEventMulticaster();</span><br><span class="line">              	<span class="comment">// 留给子类来初始化其它的Bean ，是个空方法</span></span><br><span class="line">                <span class="keyword">this</span>.onRefresh();</span><br><span class="line">              	<span class="comment">// 在所有注册的bean中查找Listener bean，注册到消息广播器中  </span></span><br><span class="line">                <span class="keyword">this</span>.registerListeners();</span><br><span class="line">              	<span class="comment">// 初始化剩下的单实例</span></span><br><span class="line">                <span class="keyword">this</span>.finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">                <span class="keyword">this</span>.finishRefresh();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BeansException var10) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isWarnEnabled()) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.logger.warn(<span class="string">&quot;Exception encountered during context initialization - cancelling refresh attempt: &quot;</span> + var10);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.destroyBeans();</span><br><span class="line">                <span class="keyword">this</span>.cancelRefresh(var10);</span><br><span class="line">                <span class="keyword">throw</span> var10;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.resetCommonCaches();</span><br><span class="line">                contextRefresh.end();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>refresh将每一步都当成一个函数封装起来了，每一步做了啥还的具体看这个函数操作，下面按顺序挑选一些重点函数作用出来讲解</p>
<p><strong>获取BeanFactory</strong></p>
<p>这个地方我们上下文对象为<code>AnnotationConfigServletWebServerApplicationContext</code>，其实是调用的<code>GenericWebApplicationContext的refreshFactory</code>方法，而<code>GenericWebApplicationContext</code>会默认生成一个<code>beanFactory</code>，即<code>DefaultListableBeanFactory</code>。如果上下文对象是<code>ClassPathXmlApplicationContext</code>，会对xml文件进行读取</p>
<p>无论是哪种方式，可以记住，在这个步骤里面，主要实现了对<strong>BeanDefinition</strong>的装载：</p>
<p><code>Spring</code>当中的<code>BeanDefinition</code>就是<code>java</code>当中的<code>Class</code>，<code>Class</code>可以用来描述一个类的属性和方法等等其他信息。<code>BeanDefintion</code>可以描述<code>springbean</code>当中的s<code>cope、lazy，bean</code>的注入模型、以及属性和方法等等其他信息，而这些信息是<code>Class</code>无法抽象出来的.之后，会利用<code>BeanDefinition</code>的信息构建<code>Bean</code></p>
<p><strong>配置BeanFactory</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">  			<span class="comment">// 设置BeanFactory的classLoader</span></span><br><span class="line">        beanFactory.setBeanClassLoader(<span class="keyword">this</span>.getClassLoader());</span><br><span class="line">        <span class="keyword">if</span> (!shouldIgnoreSpel) &#123;</span><br><span class="line">            beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class="line">        &#125;</span><br><span class="line">				</span><br><span class="line">        beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> ResourceEditorRegistrar(<span class="keyword">this</span>, <span class="keyword">this</span>.getEnvironment()));</span><br><span class="line">  </span><br><span class="line">  			<span class="comment">// 使用context回调配置Bean工厂，当bean实现了以上的*Aware接口，通过setter方法会得到对应的属性参数</span></span><br><span class="line">        beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationContextAwareProcessor(<span class="keyword">this</span>));</span><br><span class="line">        beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line">        beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line">        beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class="line">        beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class="line">        beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class="line">        beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class="line">        beanFactory.ignoreDependencyInterface(ApplicationStartupAware.class);</span><br><span class="line">        beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">        beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="keyword">this</span>);</span><br><span class="line">        beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class="keyword">this</span>);</span><br><span class="line">        beanFactory.registerResolvableDependency(ApplicationContext.class, <span class="keyword">this</span>);</span><br><span class="line">  			<span class="comment">// 在bean初始化完成后判断是不是监听器，是的话将它注册到应用的事件多播器上。</span></span><br><span class="line">        beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(<span class="keyword">this</span>));</span><br><span class="line">  </span><br><span class="line">  			<span class="comment">// 注册默认环境bean</span></span><br><span class="line">  			......</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这一步中主要配置了工厂上下文的类加载器和<strong>后处理器</strong></p>
<p>这里重点得知道<strong>BeanPostProcessor</strong>：</p>
<p><code>BeanPostProcessor</code>接口有两个方法：<br>1.postProcessBeforeInitialization：在Bean初始化前执行<br>2.postProcessAfterInitialization：在Bean初始化后执行</p>
<p><strong>postProcessBeanFactory</strong></p>
<p>spring中并没有具体去实现<code>postProcessBeanFactory</code>方法，是提供给想要实现<code>BeanPostProcessor</code>的三方框架使用的。谁要使用谁就去实现。作用是在<code>BeanFactory</code>准备工作完成后做一些定制化的处理，一般结合<code>BeanPostProcessor</code>接口的实现类一起使用，注入一些重要资源（类似Application的属性和ServletContext的属性）。最后需要设置忽略这类<code>BeanPostProcessor</code>子接口的自动装配。</p>
<p><strong>invokeBeanFactoryPostProcessors</strong></p>
<p>本方法会实例化和调用所有 <strong>BeanFactoryPostProcessor</strong>（包括其子类 <code>BeanDefinitionRegistryPostProcessor</code>）</p>
<p><code>BeanFactoryPostProcessor</code>调用的时机是所有的bean已经全部收集并转换成了对应的<code>BeanDefinition</code>，这个时候调用的<code>BeanFactoryPostProcessor</code>，可以对<code>BeanDefine</code>做修改。</p>
<p>那么问题来了，<code>BeanFactoryPostProcessors</code>是在什么时候注册的呢？</p>
<p>通过refresh前的环境准备<code>customizeContext</code> 方法可以添加自定义的<code>BeanFactoryPostProcessor</code></p>
<p><strong>registerBeanPostProcessors</strong></p>
<p>本方法会注册所有的 <code>BeanPostProcessor</code>，将所有实现了<code>BeanPostProcessor</code>接口的类加载到<code>BeanFactory</code>中。</p>
<p><code>BeanPostProcessor </code>接口是 Spring 初始化 bean 时对外暴露的扩展点，Spring IoC 容器允许 <code>BeanPostProcessor </code>在容器初始化 bean 的前后，添加自己的逻辑处理。在<code>registerBeanPostProcessors</code>方法只是注册到 <code>BeanFactory </code>中，具体调用是在 bean 初始化的时候。</p>
<p><strong>finishBeanFactoryInitialization</strong></p>
<p>该方法会实例化所有剩余的非懒加载单例 bean。除了一些内部的 bean、实现了 BeanFactoryPostProcessor 接口的 bean、实现了 BeanPostProcessor 接口的 bean，其他的非懒加载单例 bean 都会在这个方法中被实例化，并且 BeanPostProcessor 的触发也是在这个方法中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (beanFactory.containsBean(<span class="string">&quot;conversionService&quot;</span>) &amp;&amp; beanFactory.isTypeMatch(<span class="string">&quot;conversionService&quot;</span>, ConversionService.class)) &#123;</span><br><span class="line">        beanFactory.setConversionService((ConversionService)beanFactory.getBean(<span class="string">&quot;conversionService&quot;</span>, ConversionService.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">        beanFactory.addEmbeddedValueResolver((strVal) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.getEnvironment().resolvePlaceholders(strVal);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">    String[] var3 = weaverAwareNames;</span><br><span class="line">    <span class="keyword">int</span> var4 = weaverAwareNames.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> var5 = <span class="number">0</span>; var5 &lt; var4; ++var5) &#123;</span><br><span class="line">        String weaverAwareName = var3[var5];</span><br><span class="line">        <span class="keyword">this</span>.getBean(weaverAwareName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    beanFactory.setTempClassLoader((ClassLoader)<span class="keyword">null</span>);</span><br><span class="line">    beanFactory.freezeConfiguration();</span><br><span class="line">    beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的调用链比较复杂，下面为大致理清其流程，具体讲解主要在Bean生命周期那一块</p>
<ul>
<li>首先<code>finishBeanFactoryInitialization</code>,判断一些是否需要特殊处理类后，调用<code>preInstantiateSingletons</code>方法</li>
<li>在<code>preInstantiateSingletons</code>方法判断跳过抽象、原型、懒加载的bean，最后要实例化的调用<code>getBean</code>方法</li>
<li><code>getBean</code>方法调用<code>doGetBean</code>,其中根据依赖关系控制了Bean的加载顺序</li>
<li>最后调用了<code>createBean</code>方法完成实例化</li>
</ul>
<p>至此Spring的启动流程基本完成，回顾一下，Spring容器启动流程中除了实例化了一下非懒加载的单例Bean外，也为其他Bean实例化做了一下前期准备，比如<code>BeanDifinition</code>的装载、调用了<code>BeanFactoryPostProcessor</code>修改定义好了的<code>BeanDifinition</code>,注册好了相关的<code>BeanPostProcessor</code>,等到对应Bean调用getBean方法时，就会发挥相应的作用</p>
<p>那么，知道了这些前期准备，具体中调用getBean方法时，到底经历了怎样的Bean创建流程，将在Bean生命周期中讲解</p>
<h1 id="Bean生命周期"><a href="#Bean生命周期" class="headerlink" title="Bean生命周期"></a>Bean生命周期</h1><p>Spring 中Bean 的生命周期实际和其作用域范围息息相关。</p>
<p>一般我们说的生命周期是指单例作用域下的Bean，其如果不是懒加载，在容器刷新的时候就完成了初始化。</p>
<p>前面讲解Spring框架启动时，我们清楚，单例Bean最终在<code>refresh-&gt;finishBeanFactoryInitialization-&gt;preInstantiateSingletons-&gt;getBean</code>方法中完成初始化，这里我们就研究Bean初始化的整个流程</p>
<h2 id="Bean初始化源码分析"><a href="#Bean初始化源码分析" class="headerlink" title="Bean初始化源码分析"></a>Bean初始化源码分析</h2><p>首先由getBean方法到doGetBean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(String name, <span class="meta">@Nullable</span> Class&lt;T&gt; requiredType, <span class="meta">@Nullable</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    String beanName = <span class="keyword">this</span>.transformedBeanName(name);</span><br><span class="line">  	<span class="comment">// 尝试从缓存中获取Bean，是解决循环依赖的关键</span></span><br><span class="line">    Object sharedInstance = <span class="keyword">this</span>.getSingleton(beanName);</span><br><span class="line">    Object beanInstance;</span><br><span class="line">  	<span class="comment">// 缓存中存在Bean</span></span><br><span class="line">    <span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">                <span class="keyword">this</span>.logger.trace(<span class="string">&quot;Returning eagerly cached instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; that is not fully initialized yet - a consequence of a circular reference&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.logger.trace(<span class="string">&quot;Returning cached instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        beanInstance = <span class="keyword">this</span>.getObjectForBeanInstance(sharedInstance, name, beanName, (RootBeanDefinition)<span class="keyword">null</span>);</span><br><span class="line">    &#125; </span><br><span class="line">  <span class="comment">// 缓存中不存在Bean</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    		<span class="comment">// 无法处理原型模式的bean的循环依赖</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        BeanFactory parentBeanFactory = <span class="keyword">this</span>.getParentBeanFactory();</span><br><span class="line">    		<span class="comment">// 查看父类中是否有相关的bean的定义信息，有就递归到父类中处理</span></span><br><span class="line">        <span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.containsBeanDefinition(beanName)) &#123;</span><br><span class="line">           ......</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">            <span class="keyword">this</span>.markBeanAsCreated(beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StartupStep beanCreation = <span class="keyword">this</span>.applicationStartup.start(<span class="string">&quot;spring.beans.instantiate&quot;</span>).tag(<span class="string">&quot;beanName&quot;</span>, name);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (requiredType != <span class="keyword">null</span>) &#123;</span><br><span class="line">                beanCreation.tag(<span class="string">&quot;beanType&quot;</span>, requiredType::toString);</span><br><span class="line">            &#125;</span><br><span class="line"> 	</span><br><span class="line">				<span class="comment">//将父类的定义的BeanDefinition与子类的BeanDefinition进行合并覆盖</span></span><br><span class="line">            RootBeanDefinition mbd = <span class="keyword">this</span>.getMergedLocalBeanDefinition(beanName);</span><br><span class="line">            <span class="keyword">this</span>.checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line">            String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">            String[] var12;</span><br><span class="line">          	<span class="comment">// 判断Bean的dependOn依赖问题，先创建所dependsOn依赖的bean</span></span><br><span class="line">            <span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                var12 = dependsOn;</span><br><span class="line">                <span class="keyword">int</span> var13 = dependsOn.length;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> var14 = <span class="number">0</span>; var14 &lt; var13; ++var14) &#123;</span><br><span class="line">                    String dep = var12[var14];</span><br><span class="line">                  	<span class="comment">// 存在无法解决的dependOn循环依赖</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">this</span>.isDependent(beanName, dep)) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">&quot;Circular depends-on relationship between &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; and &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">this</span>.registerDependentBean(dep, beanName);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">this</span>.getBean(dep);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (NoSuchBeanDefinitionException var31) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">&quot;&#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; depends on missing bean &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>, var31);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">				<span class="comment">// 创建单例Bean</span></span><br><span class="line">            <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">                sharedInstance = <span class="keyword">this</span>.getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                      	<span class="comment">// 创建Bean的方法</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">this</span>.createBean(beanName, mbd, args);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (BeansException var5) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.destroySingleton(beanName);</span><br><span class="line">                        <span class="keyword">throw</span> var5;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                beanInstance = <span class="keyword">this</span>.getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">            &#125; </span><br><span class="line">          <span class="comment">// 创建原型Bean</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">                var12 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                Object prototypeInstance;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.beforePrototypeCreation(beanName);</span><br><span class="line">                    prototypeInstance = <span class="keyword">this</span>.createBean(beanName, mbd, args);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.afterPrototypeCreation(beanName);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                beanInstance = <span class="keyword">this</span>.getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">            &#125; </span><br><span class="line">          <span class="comment">// 其他作用域Bean创建</span></span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">                ......</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BeansException var32) &#123;</span><br><span class="line">            beanCreation.tag(<span class="string">&quot;exception&quot;</span>, var32.getClass().toString());</span><br><span class="line">            beanCreation.tag(<span class="string">&quot;message&quot;</span>, String.valueOf(var32.getMessage()));</span><br><span class="line">            <span class="keyword">this</span>.cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">            <span class="keyword">throw</span> var32;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            beanCreation.end();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.adaptBeanInstance(name, beanInstance, requiredType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getBean的大致流程如上，其中有以下关键点：</p>
<h3 id="Key1-getSingleton与循环依赖"><a href="#Key1-getSingleton与循环依赖" class="headerlink" title="Key1:getSingleton与循环依赖"></a>Key1:getSingleton与循环依赖</h3><p>当调用getBean时，优先会选择从缓存中拿取Bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap(<span class="number">256</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap(<span class="number">16</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> ConcurrentHashMap(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// 先从singletonObjects中取bean</span></span><br><span class="line">      Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">      <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">        	<span class="comment">// 再尝试从earlySingletonObjects中取bean</span></span><br><span class="line">          singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">          <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">            	</span><br><span class="line">             <span class="comment">// 都没有加锁，类似双重检查机制，会再次判断</span></span><br><span class="line">              <span class="keyword">synchronized</span>(<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">                  singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">                  <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">                      singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">                      <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        	<span class="comment">// 依旧没有从singletonFactories中取</span></span><br><span class="line">                          ObjectFactory&lt;?&gt; singletonFactory = (ObjectFactory)<span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">                          <span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            	<span class="comment">// 如果有了通过getObject创建加入earlySingletonObjects中</span></span><br><span class="line">                              singletonObject = singletonFactory.getObject();</span><br><span class="line">                              <span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                              <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> singletonObject;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现这里有三重缓存：</p>
<ul>
<li>singletonObjects：一级缓存，存放初始化完好的Bean</li>
<li>earlySingletonObjects：二级缓存，存放实例化，但是还没有完成属性注入初始化的Bean</li>
<li>singletonFactories：三级缓存，提前暴露的一个单例工厂，二级缓存中存储的就是从这个工厂中获取到的对象（getObject方法）</li>
</ul>
<p>首先一级缓存很好理解，既然时单例模式，肯定需要将创建好的Bean缓存起来</p>
<p>那么二级缓存和三级缓存存在的意义是什么？</p>
<p>答案是解决<strong>循环依赖</strong>和<strong>AOP</strong></p>
<p>首先循环依赖问题，如果A setter依赖B，B依赖A，在多一级缓存的情况下，B可以从缓存中拿到A早期的引用，完成实例化、属性注入、初始化再注入A就可以解决循环依赖</p>
<p>但是循环依赖只需要多一级缓存就能解决，还是没有必要使用三级缓存</p>
<p>想了解这个问题，得知道Bean当从三级缓存放入二级缓存时发生了什么？</p>
<p>getObject方法最后相当于调用了<code>getEarlyBeanReference</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getEarlyBeanReference</span><span class="params">(String beanName, RootBeanDefinition mbd, Object bean)</span> </span>&#123;</span><br><span class="line">       Object exposedObject = bean;</span><br><span class="line">       SmartInstantiationAwareBeanPostProcessor bp;</span><br><span class="line">       <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; <span class="keyword">this</span>.hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">           <span class="keyword">for</span>(Iterator var5 = <span class="keyword">this</span>.getBeanPostProcessorCache().smartInstantiationAware.iterator(); var5.hasNext(); exposedObject = bp.getEarlyBeanReference(exposedObject, beanName)) &#123;</span><br><span class="line">               bp = (SmartInstantiationAwareBeanPostProcessor)var5.next();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> exposedObject;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>可见其调用了后置处理器的<code>getEarlyBeanReference</code>，而真正实现了这个方法的后置处理器只有一个，就是通过<code>@EnableAspectJAutoProxy</code>注解导入的<code>AnnotationAwareAspectJAutoProxyCreator</code>，即其与AOP相关</p>
<p>实际上，如果Bean实现AOP后，<strong>放入二级缓存中的是已经代理后的引用</strong></p>
<p>那如果只有二级缓存，就会要求二级缓存中的对象引用已经实现代理</p>
<p>所以多了三级工厂缓存的目的在于延迟对实例化阶段生成的对象的代理，只有真正发生循环依赖的时候，才去提前生成代理对象，否则只会创建一个工厂并将其放入到三级缓存中，但是不会去通过这个工厂去真正创建对象</p>
<p>这恰好和Spring AOP和Bean的设计原则一致</p>
<p>Spring结合<code>AOP</code>跟Bean的生命周期本身就是通过<code>AnnotationAwareAspectJAutoProxyCreator</code>这个后置处理器来完成的，在这个后置处理的<code>postProcessAfterInitialization</code>方法中对初始化后的Bean完成<code>AOP</code>代理。如果出现了循环依赖，那没有办法，只有给Bean先创建代理，但是没有出现循环依赖的情况下，设计之初就是让Bean在生命周期的最后一步完成代理而不是在实例化后就立马完成代理。</p>
<h3 id="key2：createBean"><a href="#key2：createBean" class="headerlink" title="key2：createBean"></a>key2：createBean</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span> <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.logger.trace(<span class="string">&quot;Creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RootBeanDefinition mbdToUse = mbd;</span><br><span class="line">    <span class="comment">// 确定并加载bean的class</span></span><br><span class="line">    Class&lt;?&gt; resolvedClass = <span class="keyword">this</span>.resolveBeanClass(mbd, beanName, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span> (resolvedClass != <span class="keyword">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mbdToUse = <span class="keyword">new</span> RootBeanDefinition(mbd);</span><br><span class="line">        mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 验证以及准备需要覆盖的方法</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mbdToUse.prepareMethodOverrides();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (BeanDefinitionValidationException var9) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(mbdToUse.getResourceDescription(), beanName, <span class="string">&quot;Validation of method overrides failed&quot;</span>, var9);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object beanInstance;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// BPP的初始化前处理，如果返回了AOP或者自定义Bean，再进行后置处理直接使用这个bean</span></span><br><span class="line">        beanInstance = <span class="keyword">this</span>.resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">        <span class="keyword">if</span> (beanInstance != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> beanInstance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var10) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbdToUse.getResourceDescription(), beanName, <span class="string">&quot;BeanPostProcessor before instantiation of bean failed&quot;</span>, var10);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 否则自己创建bean</span></span><br><span class="line">        beanInstance = <span class="keyword">this</span>.doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.logger.trace(<span class="string">&quot;Finished creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> beanInstance;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ImplicitlyAppearedSingletonException | BeanCreationException var7) &#123;</span><br><span class="line">        <span class="keyword">throw</span> var7;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var8) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbdToUse.getResourceDescription(), beanName, <span class="string">&quot;Unexpected exception during bean creation&quot;</span>, var8);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring真正创建Bean的地方，是在doCreateBean方法中</p>
<p><strong>doCreateBean</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span> <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">      BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">          instanceWrapper = (BeanWrapper)<span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// 根据bean对应的策略创建新的实例创建bean实例</span></span><br><span class="line">      <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">          instanceWrapper = <span class="keyword">this</span>.createBeanInstance(beanName, mbd, args);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">      Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">      <span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">          mbd.resolvedTargetType = beanType;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">synchronized</span>(mbd.postProcessingLock) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">// 应用MergedBeanDefinitionPostProcessor 后处理器，合并bean的定义信息</span></span><br><span class="line">			<span class="comment">// Autowire等注解信息就是在这一步完成预解析，并且将注解需要的信息放入缓存</span></span><br><span class="line">                  <span class="keyword">this</span>.applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (Throwable var17) &#123;</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">&quot;Post-processing of merged bean definition failed&quot;</span>, var17);</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// 初始化之前放入早期工厂，即上文的三级缓存</span></span><br><span class="line">      <span class="keyword">boolean</span> earlySingletonExposure = mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp; <span class="keyword">this</span>.isSingletonCurrentlyInCreation(beanName);</span><br><span class="line">      <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">              <span class="keyword">this</span>.logger.trace(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">this</span>.addSingletonFactory(beanName, () -&gt; &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">this</span>.getEarlyBeanReference(beanName, mbd, bean);</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Object exposedObject = bean;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 对bean属性进行填充，注入bean中的属性，会递归初始化依赖的bean</span></span><br><span class="line">          <span class="keyword">this</span>.populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">          </span><br><span class="line">	<span class="comment">// 调用初始化方法，比如init-method、注入Aware对象、应用后处理器</span></span><br><span class="line">          exposedObject = <span class="keyword">this</span>.initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable var18) &#123;</span><br><span class="line">          <span class="keyword">if</span> (var18 <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException)var18).getBeanName())) &#123;</span><br><span class="line">              <span class="keyword">throw</span> (BeanCreationException)var18;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">&quot;Initialization of bean failed&quot;</span>, var18);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">          <span class="comment">// 从提前曝光的bean缓存中查询bean，目的是验证是否有循环依赖存在</span></span><br><span class="line">	<span class="comment">// 如果存在循环依赖，也就是说该bean已经被其他bean递归加载过，放入了提早曝光的bean缓存中，即上文二级缓存</span></span><br><span class="line">          Object earlySingletonReference = <span class="keyword">this</span>.getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">          <span class="comment">// 这里是从二级缓存中读值，显然不空说明有循环依赖</span></span><br><span class="line">          <span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">// 如果exposedObject没有在 initializeBean 初始化方法中改变，也就是没有被增强</span></span><br><span class="line">              <span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">                  exposedObject = earlySingletonReference;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// 检测依赖</span></span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; <span class="keyword">this</span>.hasDependentBean(beanName)) &#123;</span><br><span class="line">                  String[] dependentBeans = <span class="keyword">this</span>.getDependentBeans(beanName);</span><br><span class="line">                  Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet(dependentBeans.length);</span><br><span class="line">                  String[] var12 = dependentBeans;</span><br><span class="line">                  <span class="keyword">int</span> var13 = dependentBeans.length;</span><br><span class="line"></span><br><span class="line">                  <span class="keyword">for</span>(<span class="keyword">int</span> var14 = <span class="number">0</span>; var14 &lt; var13; ++var14) &#123;</span><br><span class="line">                      String dependentBean = var12[var14];</span><br><span class="line">                      <span class="keyword">if</span> (!<span class="keyword">this</span>.removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">                          actualDependentBeans.add(dependentBean);</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  <span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">                      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName, <span class="string">&quot;Bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; has been injected into other beans [&quot;</span> + StringUtils.collectionToCommaDelimitedString(actualDependentBeans) + <span class="string">&quot;] in its raw version as part of a circular reference, but has eventually been wrapped. This means that said other beans do not use the final version of the bean. This is often the result of over-eager type matching - consider using &#x27;getBeanNamesOfType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;</span>);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">          <span class="keyword">return</span> exposedObject;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (BeanDefinitionValidationException var16) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">&quot;Invalid destruction signature&quot;</span>, var16);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql的隔离级别、锁与事务</title>
    <url>/2021/07/06/Mysql%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E3%80%81%E9%94%81%E4%B8%8E%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<p>本文将主要通过介绍Mysql中锁、事务隔离级别和事务之间的联系来加深对Mysql这三个部分知识点的了解</p>
<a id="more"></a>

<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="事务及特性"><a href="#事务及特性" class="headerlink" title="事务及特性"></a>事务及特性</h2><p>首先中Mysql下谈论事务，是指的是InnoDB引擎，而不是MyISAM</p>
<p>实际上由于MyISAM不支持事务、锁的粒度最低表锁，所以仅仅在不需要事务、绝大多数查询是读查询时有可用之机，因此Mysql已将默认引擎设为InnoDB，下文的学习也是基于此</p>
<p>事务是指访问并可能更新系统中各种数据项的的由一组操作构成的可靠、独立的程序执行单元(unit)，通过这个程序执行单元可以使得我们对数据的操作能够保证数据在<strong>语义上的一致性</strong></p>
<p>我们常说的事务有四大特性：</p>
<ul>
<li>原子性：事务的操作要么都完成，要么都不执行</li>
<li>隔离性：隔离性也就是并发控制，一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰</li>
<li>持久性：事务一旦提交，对数据项对改变是永久的</li>
<li>一致性：事务必须是使数据库从一个一致性状态变到另一个一致性状态，通过事务的原子性、隔离性、持久性</li>
</ul>
<h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p>我认为隔离级别是针对隔离性提出的细化要求，不同的隔离级别的隔离性强度不同，有下面四个隔离级别</p>
<ul>
<li>未提交读：事务未提交的修改对其他事务也可见。</li>
<li>提交读（RC）：事务中只能看到已提交的修改。</li>
<li>可重复读（RR）：在自己的事务中，多次读取数据的结果是一致的，不管其他事务是否有提交</li>
<li>串行化：要求事务序列化执行</li>
</ul>
<p>在并发事务下，可能会出现以下问题：</p>
<ul>
<li>脏读：读到事务未提交读数据</li>
<li>不可重复读：事务内部多次读取到数据不一致，主要指数据本身内容改变</li>
<li>幻读：事务内部多次读取到数据不一致，主要指数据项数目可能发生了增减</li>
</ul>
<p>上面四个隔离级别中，一般来说，未提交读显然会导致上诉三个问题，很少使用</p>
<p>提交读解决了脏读问题，但是可能由于某行数据被别的事务修提交后，前后读取不一致，还是有后面两个问题</p>
<p>可重复读保证多次读取读数据项一致，实际上可用通过加行锁实现，但是如果别的事务向该表添加了数据行，可能会导致幻读</p>
<p>最后一个隔离级别可用解决这三个问题，但是事务串行化执行，事务并发性就会很低，所以一般数据库会在隔离级别和并发性之间做个取舍，一般默认隔离级别为RC或者RR，Mysql事务的隔离级别默认为RR，并且其RR级别的隔离级别，就解决了幻读</p>
<p>下面将了解Mysql中各个隔离级别的实现</p>
<h1 id="串行化隔离级别实现"><a href="#串行化隔离级别实现" class="headerlink" title="串行化隔离级别实现"></a>串行化隔离级别实现</h1><p>串行化隔离级别实际上是<strong>基于锁的并发控制（Lock-Based Concurrent Control）</strong>，LBCC就利用到了我们常说的共享锁和排他锁</p>
<ul>
<li>共享锁又称为读锁，简称S锁，顾名思义，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。</li>
<li>排他锁又称为写锁，简称X锁，顾名思义，排他锁就是不能与其他所并存，如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据就行读取和修改。</li>
</ul>
<p>串行化隔离级别要求读的时候不能写，但允许多个事务同时读，写的时候不能读写，只允许一个事务对该数据进行修改。</p>
<p>这样的加锁访问，其实并不算是真正的并发，或者说它只能实现并发的读，因为它最终实现的是读写串行化，这样就大大降低了数据库的读写性能。</p>
<p>数据库中常见的加锁语句有以下语句</p>
<ul>
<li>select * from table where ? lock in share mode; （加S锁）</li>
<li>select * from table where ? for update; （加X锁，下同）</li>
<li>insert, update, delete操作</li>
</ul>
<h1 id="RR与RC隔离级别实现"><a href="#RR与RC隔离级别实现" class="headerlink" title="RR与RC隔离级别实现"></a>RR与RC隔离级别实现</h1><p>当我们对隔离级别降低到RR或者RC级别，就可以不再靠LBCC的方式，多数数据库提供了另一套模式——多版本并发控制MVCC</p>
<p>多版本并发控制可以做到读不加锁、读写不冲突。</p>
<p>在MVCC中读操作可以分成两种：</p>
<ul>
<li><p>快照读：读事务历史可见的记录，不对记录加锁；MVCC说的读不加锁，读写不冲突是指该读</p>
</li>
<li><p>当前读：读最新的数据记录，需要对记录加锁，防止其他事务修改，如：select lock in share mode(共享锁), select for update ; update, insert ,delete</p>
</li>
</ul>
<p>下面讲解Mysql中MVCC的实现</p>
<h2 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h2><p>MVCC实现快照读，关键在于两点，多版本和并发控制</p>
<p><strong>多版本</strong>：</p>
<p>InnoDB中通过<strong>undo log</strong>实现了数据的多版本，当进行数据修改时会记录undo log，undo log用于数据的撤回操作，它记录了修改的反向操作，比如，插入对应删除，修改对应修改为原来的数据，通过undo log可以实现事务回滚，并且可以根据undo log回溯到某个特定的版本的数据，实现MVCC。</p>
<p>Mysql每一行会添加一个隐藏列<strong>DB_ROLL_PTR：</strong>其会指向上一个版本数据在undo log 里的位置指针</p>
<p><strong>并发控制：</strong></p>
<p>并发控制涉及到Mysql的另一个隐藏列<strong>DB_TRX_ID:</strong> 其会记录操作该数据事务的事务ID；</p>
<p>当事务SQL语句执行的时候会得到一个Read view，其包含了当前未提交事务集合ID，记set；记录set中事务ID最小值 low；记录当前系统中事务ID最大值high，还有自己的版本号i</p>
<p>当事务读取数据时，我们可以得到数据行的DB_TRX_ID我们记cur</p>
<p>显然</p>
<ul>
<li><p>如果cur &lt; k ,说明该修改改数据的事务肯定在Read view 之前就提交过，那可读</p>
</li>
<li><p>如果cur &gt; high 说明是该数据是在Read view 之后创建的事务修改的，那不可读，需要通过DB_ROLL_PTR转到undo log更新事务号为更小的直到可读或者为空</p>
</li>
<li><p>cur在之间就看在不在set中，在且不等于i说明是Read view 创建前未提交的事务修改的，不能读，处理同上；不在说明也是在Read view 之前就提交过，那可读</p>
</li>
</ul>
<p>我们发现通过这个Read view 我们可以读到正确的数据而不需要加锁</p>
<p>当我们在<strong>RR隔离级别下</strong>：我们一个事务只保持第一次查询时得到的Read view，保证事务内多次读都是一个版本，即快照读，<strong>解决了幻读和不可重复读问题</strong>!</p>
<p>当我们在<strong>RC隔离级别下</strong>：事务每次每一次查询都会获得一个新的Read view副本。这样就可能造成同一个事务里前后读取<strong>数据可能不一致</strong>的问题!</p>
<p>这里还有最后一个问题，我们清楚RR隔离级别下，利用快照读可以解决幻读问题，那如果这时的查询语句不是普通的select语句，而是当前读语句，需要对记录加锁怎么办？这时加的是什么锁？</p>
<h2 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h2><p>如果需要当前读，并且防止其他事务修改，InnoDB这个时候会启动一些锁算法：</p>
<ul>
<li><p>记录锁</p>
<p>记录锁是锁住记录的，这里要说明的是这里锁住的是索引记录，而不是我们真正的数据记录。</p>
<ul>
<li>如果锁的是非主键索引，会在自己的索引上面加锁之后然后再去主键上面加锁锁住.</li>
<li>如果没有表上没有索引(包括没有主键)，则会使用隐藏的主键索引进行加锁。</li>
<li>如果要锁的列没有索引，则会进行全表记录加锁</li>
</ul>
</li>
<li><p>间隙锁</p>
<p>间隙锁顾名思义锁间隙，不锁记录。锁间隙的意思就是锁定某一个范围，间隙锁又叫gap锁，其不会阻塞其他的gap锁，但是会阻塞插入间隙锁</p>
</li>
<li><p>next-key锁</p>
<p>本质是记录锁加上gap锁。RR隔离级别下，Innodb对于行的扫描锁定都是使用此算法，但是如果查询扫描中有唯一索引会退化成只使用记录锁。</p>
</li>
<li><p>插入意向锁</p>
<p>可以看出插入意向锁是在插入的时候产生的,在多个事务同时写入不同数据至同一索引间隙的时候，并不需要等待其他事务完成，不会发生锁等待。假设有一个记录索引包含键值4和7，不同的事务分别插入5和6，每个事务都会产生一个加在4-7之间的插入意向锁，获取在插入行上的排它锁，但是不会被互相锁住，因为数据行并不冲突。<strong>但是如果这个索引间隙有间隙锁了，插入意向锁会被阻塞。</strong></p>
</li>
</ul>
<p>可以看见，在<strong>RR模式下默认采用next-key锁，达到锁住数据防止不可重复读、又锁范围防止幻读的效果</strong></p>
<p>也正是RR隔离级别下快照读和当前读都能防止幻读，我们才说，Mysql的RR解决了幻读，这也是Mysql的隔离级别</p>
<p>而在RC隔离级别下，没有间隙锁，自然也就没有next-key锁，其没有解决不可重复读问题，自然也就没有必要处理幻读问题，进一步提高并发性能</p>
<p>最后注意一点，记录锁要锁的列没有索引，则会进行全表记录加锁，这会很影响性能，所以上锁需谨慎</p>
<h1 id="Mysql事务"><a href="#Mysql事务" class="headerlink" title="Mysql事务"></a>Mysql事务</h1><p>最后了如果我们要操作事务，在InnoDB引擎下，和事务指令以及AUTOCOMMIT有关</p>
<p><strong>事务指令</strong></p>
<ul>
<li><strong>BEGIN</strong> 开始一个事务</li>
<li><strong>ROLLBACK</strong> 事务回滚</li>
<li><strong>COMMIT</strong> 事务确认</li>
</ul>
<p>从用户执行start transaction命令到用户执行commit命令之间的一系列操作为一个完整的事务周期。若不执行commit命令，系统则默认事务回滚。</p>
<p> <strong>AUTOCOMMIT</strong></p>
<ul>
<li><strong>SET AUTOCOMMIT=0</strong> 禁止自动提交，必须要等到commit才能提交</li>
<li><strong>SET AUTOCOMMIT=1</strong> 开启自动提交默认</li>
</ul>
<p>在其值为1的条件下，除了事务指令标识的区域，每一条SQL语句都相当于一个独立的事务，用户每进行一次操作都会即时提交或者即时回滚</p>
<p>前面我们知道每个事务都会有回滚日志即undo log，在长事务情况下，就有很多的回滚日志，占用资源。所以回滚日志会在不需要的时候才删除。也就是说，系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除，<strong>即当系统里没有比这个回滚日志更早的 Read view 的时候。</strong>  所以最好不要用长事务，长事务意味着系统里面会存在很老的Read view，它可能用到的回滚记录都必须保留，浪费资源</p>
<p>有些客户端连接框架会默认连接成功后先执行一个 set autocommit=0 的命令。这就导致接下来的查询都在事务中，如果是长连接，就导致了意外的长事务。所以一般建议使用 set autocommit=1, 通过事务指令的方式来显式启动事务。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql查询性能优化</title>
    <url>/2021/07/07/Mysql%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>了解mysql一些常见对查询优化的技巧</p>
<a id="more"></a>

<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><h2 id="查询过程"><a href="#查询过程" class="headerlink" title="查询过程"></a>查询过程</h2><p>首先打算对查询进行优化得了解查询过程</p>
<p><img src="/images/image-20210707222919747.png" alt="image-20210707222919747"></p>
<p>其中Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p>
<p>存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。最常用的存储引擎是 InnoDB。</p>
<p>当我们开始执行一条查询语句时，客户端连接服务端后，首先会查看是否命中缓存，然后会通过分析系分析完语法后丢个优化器，在优化器中进行逻辑和CPU、内存等物理代价的比较后，最终选择一种方式去给执行器执行查询。</p>
<h2 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h2><p>了解Mysql 在InnoDB引擎下的索引结构</p>
<p>Innodb中使用了B+树，索引类型分为主键索引和非主键索引。主键索引的叶子节点存的是整行数据，所以在Innodb里，主键索引也被称为聚簇索引。非主键索引的叶子节点内容是主键的值。在Innodb里，非主键索引也被称为二级索引</p>
<p>在索引这里，要学会利用<strong>explain</strong>来分析索引是否被使用，如下图：</p>
<p><img src="/images/image-20210707223008941.png" alt="image-20210707223008941"></p>
<p>其中select_type指的是select语句的类型,table表示查询用到的表，possible_keys表示可能使用的索引，key表示实际使用的索……</p>
<p>而对我们观察索引是否被使用最重要的属性是<strong>type：对表访问方式，表示MySQL在表中找到所需行的方式</strong>，常见有：</p>
<ul>
<li>ALL：Full Table Scan， MySQL将遍历全表以找到匹配的行</li>
<li>index: Full Index Scan，index与ALL区别为index类型只遍历索引树</li>
<li>range:只检索给定范围的行，使用一个索引来选择行</li>
<li>ref: 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</li>
<li>eq_ref: 类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件</li>
<li>const、system: 当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量，system是const类型的特例，当查询的表只有一行的情况下，使用system</li>
<li>NULL: MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。</li>
</ul>
<p><strong>阿里一般建议至少为range，要求是ref（对普通索引使用检索），最好是const</strong></p>
<p>值得注意，当使用explain查询时，其不会使用缓存、部分信息是估算的、只能使用在select查询语句</p>
<h1 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h1><p>这里讨论的优化注意和SQL查询语句优化</p>
<p>当我们用explain得到查询语句的信息后，可以用来分析具体的问题进行优化</p>
<p>第一个优化大类和索引相关</p>
<h2 id="索引相关优化"><a href="#索引相关优化" class="headerlink" title="索引相关优化"></a>索引相关优化</h2><ul>
<li><p>尽量使用索引，并且正确使用到索引</p>
<p>第一点：不使用索引就全表扫描，基本就是效率最差的查询，此外使用索引还有一点，前面提到在RR隔离级别下的当前读，不使用索引就会全表加锁，还会造成并发性能损失</p>
<p>第二点：正确使用索引就得清楚Mysql索引的最左前缀匹配原则，避免实际上没有用到索引</p>
</li>
<li><p>尽量使用覆盖索引</p>
<p>实际就是查询时最好就只需要查询自己所需要的值，如果需要的值都在联合索引中最好，也就是覆盖索引，减少了回表</p>
</li>
<li><p>使用索引避免File-sort，B+树索引自身是有序的, 如果一条SQL语句要求按照某个字段排序，并且恰好在进行数据检索时可以利用到以这个字段为首的单列或者多列索引，则数据从Innodb中获取到时，本身就是有序的，也就不需要额外的排序操作，这也叫index排序</p>
<p>这一点主要是要利用好Mysql的索引的存储原则，索引本身就是有序的</p>
</li>
<li><p>使用离散程度高的列作为索引，建立联合索引时注意最左匹配，尽量把离散程度高的列放在前面</p>
</li>
<li><p>索引大小有限制</p>
<p>由于索引是B+树组织，要求叶子节点上一个page至少要包含两条记录（否则就退化链表了），再加上二级索引包含主键索引，所以对索引大小要求有限制，由这延伸出了这一点。因此索引列的长度应考虑尽可能短，以提高读写效率。基于此规则可以引申出：</p>
<ul>
<li>整型数值类型优于字符类型，例如手机号码 日期字段，date类型，timestamp类型优于字符类型 </li>
<li>必要时采用前缀索引</li>
</ul>
</li>
<li><p>避免隐式退化</p>
<p>where 条件时，变量的类型应当与列的类型匹配。如果不匹配，数据库需要额外将变量类型转换，称为隐式转化，导致可能利用不到索引。这特别在使用Mybatis等ORM框架等时候出现</p>
</li>
<li><p>避免建立冗余索引和重复索引</p>
<p>主要是联合索引一般可以包含多个索引，如index(a,b,c)包含index(a,b)包含index(a)</p>
</li>
</ul>
<h2 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h2><ul>
<li><p>如果知道查询返回到数目，尽量看能不能使用limit来避免多余的查询</p>
<p>显然limit可以让我们查询到足够结果后返回，避免多余的查询</p>
</li>
<li><p>使用join尽量小表驱动大表</p>
<p>MySQL 表关联的算法是 Nest Loop Join，是通过驱动表的结果集作为循环基础数据，然后一条一条地通过该结果集中的数据作为过滤条件到下一个表中查询数据 ，然后合并结果。</p>
<p>因此驱动表选择，“<strong>在sql优化中，永远是以小表驱动大表</strong>”，用explain第一列的就是驱动表</p>
</li>
<li><p>尽可能把所有列定义为NOT NULL</p>
<p>因为数据库处理null值可能需要额外的空间，进行比较和计算时要对NULL值做特别的处理</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
</search>
