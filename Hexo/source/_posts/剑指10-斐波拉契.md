---
title: 剑指10 斐波拉契
typora-root-url: ../
date: 2021-01-04 21:07:32
tags:
- 动态规划
- 记忆化搜索
categories:
- [剑指Offer]
- [算法,动态规划]
---

**剑指 Offer 10- I. 斐波那契数列**

**剑指 Offer 10- II. 青蛙跳台阶问题**

[力扣链接](https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/)

[力扣链接](https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/)

<!--more-->

# 第一题题目描述

写一个函数，输入 `n` ，求斐波那契（Fibonacci）数列的第 `n` 项。斐波那契数列的定义如下：

```
F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
```

斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。

答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

**示例 1：**

```
输入：n = 2
输出：1
```

**示例 2：**

```
输入：n = 5
输出：5
```

 

**提示：**

- `0 <= n <= 100`

# 思路一：动态规划

都列出了表达式，典型的动态规划问题，列出的表达式就是**状态转移方程**，解决了最大难点。

此外由于第n个值只是与前两个值有关，不必建立一维数组，直接利用三个数进行**空间优化**，这是动态规划问题能写出来后该考虑的问题。

基于此结构，明显从前往后遍历，写出代码如下,时间复杂度O（n），空间复杂度O(1)：

```java
class Solution {
    public int fib(int n) {
        if(n < 2)
        return n;
        int a = 0;
        int b = 1;
        int sum = 0;
        for(int i = 2; i <= n; i++){
        sum = (a + b)% 1000000007;
        a = b;
        b = sum;
        }
        return sum;
    }
}
```



# 思路二：记忆化搜索

这道题直接递归可能会炸（我没有试过），因为每次递归都会有很大部分数据重复计算，如果将计算出来的结果用数组保持，就可以减少不必要的计算，这就是记忆化搜索。时空复杂度O（n）

记忆化搜索是时间换空间，动态规划也是时间换空间，实际上，我认为记忆化搜索就是动态规划**不用考虑遍历方式**的形式，这也是在其空间复杂度没有思路一高、时间可能存在多余开销、有递归栈风险我还要讲解他的原因。

使用记忆化搜索不用思考遍历顺序，简化思考，特别在遍历方式复杂的动态规划问题中（特别是**区间动归问题**）可以节约时间，并且形成一种动态规划模板。

```java
class Solution {
    int[] dp;
    public int fib(int n) {
        if(n < 2)
        return n;
        dp = new int [n + 1];
        dp[1] = 1;
        return recursion(n);
    }
    public int recursion(int n){
        if(n < 2)
        return dp[n];
        if(dp[n-1] !=0)
        dp[n] = (dp[n-1] + dp[n-2]) % 1000000007;
        else
        dp[n] = (recursion(n-1) + dp[n-2]) %1000000007;
        return dp[n];
    }
}
```

# 总结：

这是一道简单的动态规划题，但是好的说明了动态规划和记忆化搜索的联系，具有指导意义

对应另外一道类似题的差距，只是在于dp[0] = 1而已