---
title: 进程与线程
typora-root-url: ../
date: 2020-12-27 09:50:18
tags:
 - 进程
 - 线程
categories:
  - [操作系统,现代操作系统]
  - [Java并发]
---

本文主要描述操作系统层面的进程和线程区别，再介绍进程的通信、同步，最后讲解一些常见的调度算法

<!--more-->

[TOC]



# 1.概念

## 进程

进程是执行的程序，程序是静态的，进程是动态的。进程是资源调度的基本单位，便于资源的管理和维护，多个进程共享物理内存、磁盘、打印机等资源。

操作系统的进程模型：一个进程是一个正在执行程序的实例，概念上每个进程都有自己的虚拟CPU，实际是真正的CPU在不同进程间快速切换（多道程序设计），体现出一段时间多个进程在运行，而每个时间点仅有一个程序是活跃的。

进程的实现靠操作系统维护的一张进程表，每个进程占用一个进程表项（也称进程控制块），表项包含了进程状态的重要信息，如程序计数器、堆栈指针、内存分配状况、文件状态，以及进程切换时必须保存的信息。当一个运行的进程收到中断时，硬件将程序计数器、程序状态字等信息压入堆栈，并跳转到内存底部固定区域的中断服务程序入口地址；之后大概用汇编语言保存寄存器值（通常保存在进程表项中），设置新的堆栈，这部分是通用的；然后一般用C语言处理特定中断剩类型下工作，使某些进程就绪；最后用调度程序选择新的进程运行。

## 线程

进程模型是基于资源分组处理与执行的，传统操作系统中进程有一个地址空间和一个控制线程，将资源和执行结合，后来将这个两个概念分离，有了线程概念，线程是进程的执行，是独立调度的基本单位，一个进程可以执行多个线程，多个线程之间共享同一个地址空间和其他资源。

线程的实现有两种方式：

- 在用户空间实现：类似于操作系统维护进程表，在用户空间中维护一张线程表，而内核对其一无所知
  - 优点：
    - 不用陷入内核，切换快，调用效率高
    - 适用性高，可以在不支持线程的操作系统是实现
    - 可以自己设计线程调度算法
    - 扩展性高
  - 缺点：
    - 由于内核对其不可见，很难实现一个线程进行系统调用阻塞时，不影响其他线程执行，可以采用包装器查看调用是否安全，再决定是否调用，但会损失性能，或者需要一些新的非阻塞的系统调用
    - 在一个单独的进程内部，没有时钟中断，所以不能用轮转调度的方式调度线程。如果一个线程开始运行，那么在该进程中的其他线程就不能运行，除非第一个线程自动放弃*CPU*。

- 在内核实现：在内核中维护线程表，创建和撤销线程都是系统调用，所有能阻塞线程的调用都以系统调用的形式实现，开销大，但当阻塞时，可由内核选择运行一个进程中另一个线程或另一个线程中的线程

  缺点:系统调用导致开销大

  

Java主流的线程是采用于操作系统原生线程模型来实现，大多是内核线程模型。

引入线程，线程必定有比进程优越的地方，这是优点，也是区别，主要在于以下几点：

- 并行实体共享同一片地址可用空间和所有可用数据的能力，Java线程共享进程的堆和方法区，也有自己独立的栈、程序计数器。
- 线程切换时只需保存和设置少量寄存器内容，开销很小，创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。所以进程也叫轻量级进程。
- 多线程时，特别是存在大量计算和I/O处理，可以加快应用程序执行速度，类似于进程多道程序设计模型
- 多CPU系统中，多线程有益，真正的并行的实现存在可能
- 线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。

# 2.状态转换

**进程间状态转换**

![image-20201227181835618](/images/image-20201227181835618.png)

阻塞态和就绪态的区别主要在于阻塞态缺少资源，就绪态缺少时间片

**线程间状态转换**

![image-20201227182116299](/images/image-20201227182116299.png)

# 3.进程间通信（IPC）

进程间通信其实有三个问题，一是一个进程把信息传递给另一个，即真正的通信问题；而是保证进程的关键活动不会交叉，即互斥问题；三是保证进程正确的执行顺序问题，即同步。

首先介绍两个概念

**竞争条件：**多个进程访问共享资源，最终结果对进程运行顺序敏感

**临界区：**对共享资源访问的代码片段

## 互斥

保证一个进程在使用共享资源而其他进程不能进行相同的操作，即互斥。

互斥的实现主要有：

- 单处理器屏蔽中断。对用户进程不可取，并且多核时也受影响
- 锁变量：用一共享变量作为锁变量锁住临界区，进入时需测试。无法解决同时进入问题
- 严格轮换法：在锁变量的基础上加入，连续测试，即自旋的思想。浪费CPU时间，仅在等待时间短时使用，并且会受到非临界区阻塞的问题，无法保证同步
- 当一个进程进入临界区时，先检查是否允许进入，若不允许，该进程原地等待：比如Peterson解法，或者是基于硬件支持的TSL指令（测试并加锁，通过锁住总线实现）实现



## 进程间同步

**同步是更为复杂的互斥**，上诉互斥的最后一个解法可以实现同步，但是具有忙等待的特点，浪费CPU时间，甚至可能出现优先级反转问题

进程间同步的实现，主要是在于进入临界区被阻塞时，不是忙等待，而是挂起，等待唤醒，主要有：

- **信号量**：信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。

  - **down** : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；
  - **up** ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。

  down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断，如果使用多个CPU，则每个信号量应该由一个锁变量保护，通过使用TSL或XCHG指令保证同一时刻只有一个CPU对信号量进行操作

  当信号量初值设置为1，如果每个进程进入临界区前都执行一个down操作，退出时执行一个up操作，就可以实现互斥，这称为**二元信号量**。

  

- **互斥量:**如果信号量的取值只表示两个状态，0（解锁） 或者其他值（加锁），那么就成为了 **互斥量（Mutex）** ，其在获取锁失败时，会放弃CPU，等待下次测试。

  

- **管程：**一个管程是一个由过程、变量以及数据结构等组成的一个集合。

  一个时刻只能有一个进程使用管程，通过二元信号量或者互斥量实现。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。所以管程引入了 **条件变量** 以及相关的操作：**wait()** 和 **signal()** 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。Java的synchronized、ReentrantLock就支持管程。

  管理可以使互斥量、信号量设计控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。

## 进程间通信

进程同步与进程通信很容易混淆，它们的区别在于：

- 进程同步：控制多个进程按一定顺序执行；
- 进程通信：进程间传输信息。

进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。

进程间通信主要有以下几种方式：

- **管道（pipe）**：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
- **命名管道（FIFO）**：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信，其命名对应于一个磁盘索引节点，有了这个文件名，任何进程有相应的权限都可以对它进行访问。。
- **消息队列（MessageQueue）**：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
- **共享存储（SharedMemory）**：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。
- **信号量（Semaphore）**：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
- **套接字（Socket）**：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。
- **信号 ( sinal )** ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。

# 4.进程调度

当多个进程或线程竞争CPU时，就要用到调度程序，执行调度算法，选择下一个运行的程序。

首先，关于调度时机，一般出现在新建进程、一个进程退出、一个进程阻塞或者是I/O中断发生时，要进行调度选择。

其次关于调度目标，一般需要讲究公平，给相似的进程相似的CPU份额；也要保住平衡，保持系统的所有部分都忙碌；同时还要保证规则策略强制执行。具体到一些应用场景，还要具体的要求，比如批处理环境要求CPU利用率、周转时间、吞吐量，交互式系统要求最小响应时间快速响应请求，以及均衡性满足用户的期望。

最后，就得讨论具体的调度算法，我们针对不同应用场景有不同的调度方式。

## 批处理系统调度

**先来先服务：**first-come first-served,维护一就绪进程的单一队列，先到先服务

**最短作业优先：**shortest job first，如果进程运行时间可以预知，就选择估计运行时间最短的顺序进行调度。但长作业可能出现饥饿问题

上诉两种算法都是**非抢占式调度**，选择一个算法进行到阻塞或者释放CPU

**最短剩余时间优先：**最短作业优先的抢占式版本，**抢占式调度**需要有时间中断，会有运行时段最大值，时段结束也会被挂起。该版本每次都选择剩余运行时间最短的进程运行。

## 交互式系统调度

**轮转调度：**维护一个可运行进程列表，每个进程被分配一个时间片，时间片用完后移到队尾。进程切换需要花费一定时间，所以时间片太小，CPU效率低，算法效率低；时间片太长响应时间就会变长

**优先级调度：**对于I/0密集型，优先级高，可以先分配CPU，以便启动下一个I/O请求，如此可以区分不同进程优先级分为不同类，不同类之间进程采用优先级调度，同类内部轮转调度。一般运行完时间片后可以降低当前线程优先级

**多级反馈队列：**按照优先级调度，一般优先级低的是CPU密集型进程，给他们设置较长的时间片比频繁短时间片更高效。多级队列对不同优先级给不同时间片，则高优先级少，低优先级时间片多。一个进程用完时间片后，分配到下一类。

**彩票调度：**向进程提供各种系统资源（如CPU时间）的彩票，一旦需要做出一项调度决策时，随机抽出一张彩票，拥有这张彩票的进程获得调度。可以实现大致按正确比例划分CPU的使用

## 线程的调度

线程的调度和线程的实现有很大关系

对于用户级线程，内核不知，进程可以在内核分配时间片内用自己的调度算法选择线程调度，一般是轮转调度或者优先级调度，就是缺乏时钟中断运行过长的线程，可以通过线程间通信解决。

对于内核级线程，内核选择一特定的线程运行一定时间片，此时注意考虑同进程线程切换比不同进程切换代价小即可

