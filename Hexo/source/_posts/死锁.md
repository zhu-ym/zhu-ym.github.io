---
title: 死锁
typora-root-url: ../
date: 2021-01-03 15:36:39
tags:
 - 死锁
categories:
 - [操作系统,现代操作系统]
---

在操作系统中，请求独占性的I/O设备会死锁；在Java并发中，对同步的块进行访问也可能发生死锁；学习数据库时，清除数据库中也有死锁操作。本文了解如何出现死锁，学习防止如何避免死锁

<!--more-->

# 死锁条件

**资源：**需要排他使用的对象

**可抢占资源：**可以从拥有它的进程抢用而无副作用

**不可抢占资源：**如计算不失败，无法将其从占用它的进程处抢占过来

而死锁和不可抢占资源有关，以下讨论资源基本指不可抢占资源

**资源死锁必要条件：**

- 互斥条件：资源要么可用，要么已分配给进程
- 占用和等待条件：已经得到某个资源的进程可以请求新的资源
- 不可抢占条件：即资源是不可抢占资源，除非占用它的进程释放
- 环路等待条件：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源

# 死锁处理

死锁处理主要有以下几种方法

## 鸵鸟算法

把头埋在沙子里，假装根本没发生问题。

在死锁预防代价高、当发生死锁时不会对用户造成多大影响、或发生死锁的概率很低可以忽略它

## 死锁检测和恢复

**死锁检测**

- **每种类型一个资源：**类似与数据库事务死锁的事务等待图，操作系统维护一**资源分配图**，如下图：

  ![image-20210103160725790](/images/image-20210103160725790.png)

  方框表示资源，圆圈表示进程。资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源，当出现环路就认为出现了死锁。

  那检测死锁也是检测改图是否有环，利用深度优先搜索算法（还有其他算法）可以实现检测。

- **每种类型多个资源：**通过基于**矩阵**的运算解决，维护以下向量和矩阵

  - E 向量：资源总量
  - A 向量：资源剩余量
  - C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量
  - R 矩阵：每个进程请求的资源数量，每一行表示一个进程请求的资源数量

  寻找没有被标记的进程只要`R矩阵第i行<=A`,则认为其可以**申请到资源**，标记它，并将C矩阵第i行加到A上，即也认为其可**释放资源**，循环执行上诉操作直到找不到满足条件的可标记进程，之后未标记进程都是死锁进程

**死锁恢复：**

当检测到死锁后，需要恢复使系统重新工作，以下是一些死锁恢复手段：

- **抢占恢复：**临时将某个资源从当前所有者转移给另一个进程，许多情况需要人工干预。比较困难，很大程度在于资源是否容易回收
- **回滚恢复：**回滚到上一个检查点，丢弃检查点之后的工作
- **杀死进程：**选择杀死环中或者环外持有环中所需资源的进程杀掉，可能会产生副作用。

## 死锁避免

如果事先预知一些信息，可以通过算法避免死锁

## 死锁预防

实际上死锁避免本质基本不可能，因为它要获知未来的请求，但可以通过破坏死锁条件在进程运行前来预防死锁

1.**破坏互斥条件：**

一切使用假脱机技术，允许若干个进程同时产生输出。

2.**破坏占用并等待条件：**

禁止进程等待资源，规定所有进程在开始执行前请求所需要的全部资源。但是如此可以资源利用率低，并且此时可以使用银行家算法进行死锁避免

3.**破坏不可抢占条件：**

抢占资源

4.**破坏环路等待条件：**

资源统一编号