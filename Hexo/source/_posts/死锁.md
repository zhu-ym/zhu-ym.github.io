---
title: 死锁
typora-root-url: ../
date: 2021-01-03 15:36:39
tags:
 - 死锁
categories:
 - [操作系统,现代操作系统]
---

在操作系统中，请求独占性的I/O设备会死锁；在Java并发中，对同步的块进行访问也可能发生死锁；学习数据库时，清除数据库中也有死锁操作。本文了解如何出现死锁，学习防止如何避免死锁

<!--more-->

# 死锁条件

**资源：**需要排他使用的对象

**可抢占资源：**可以从拥有它的进程抢用而无副作用

**不可抢占资源：**如计算不失败，无法将其从占用它的进程处抢占过来

而死锁和不可抢占资源有关，以下讨论资源基本指不可抢占资源

**资源死锁必要条件：**

- 互斥条件：资源要么可用，要么已分配给进程
- 占用和等待条件：已经得到某个资源的进程可以请求新的资源
- 不可抢占条件：即资源是不可抢占资源，除非占用它的进程释放
- 环路等待条件：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源

# 死锁处理

死锁处理主要有以下几种方法

## 鸵鸟算法

把头埋在沙子里，假装根本没发生问题。

在死锁预防代价高、当发生死锁时不会对用户造成多大影响、或发生死锁的概率很低可以忽略它

## 死锁检测和恢复

**死锁检测**

- **每种类型一个资源：**类似与数据库事务死锁的事务等待图，操作系统维护一**资源分配图**，如下图：

  ![image-20210103160725790](/images/image-20210103160725790.png)

  方框表示资源，圆圈表示进程。资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源，当出现环路就认为出现了死锁。

  那检测死锁也是检测改图是否有环，利用深度优先搜索算法（还有其他算法）可以实现检测。

- **每种类型多个资源：**通过基于**矩阵**的运算解决，维护以下向量和矩阵

  ![image-20210103183557925](/images/image-20210103183557925.png)
  
  - E 向量：资源总量
  - A 向量：资源剩余量
- C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量
  - R 矩阵：每个进程请求的资源数量，每一行表示一个进程请求的资源数量
  
  寻找没有被标记的进程只要`R矩阵第i行<=A`,则认为其可以**申请到资源**，标记它，并将C矩阵第i行加到A上，即也认为其可**释放资源**，循环执行上诉操作直到找不到满足条件的可标记进程，之后未标记进程都是死锁进程

**死锁恢复：**

当检测到死锁后，需要恢复使系统重新工作，以下是一些死锁恢复手段：

- **抢占恢复：**临时将某个资源从当前所有者转移给另一个进程，许多情况需要人工干预。比较困难，很大程度在于资源是否容易回收
- **回滚恢复：**回滚到上一个检查点，丢弃检查点之后的工作
- **杀死进程：**选择杀死环中或者环外持有环中所需资源的进程杀掉，可能会产生副作用。

## 死锁避免

如果事先预知最大资源请求信息，可以通过算法调度资源避免死锁

**安全状态**

![image-20210103183812176](/images/image-20210103183812176.png)

上图a是初始状态，从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时**安全的**。

而如下图就就是**不安全的**，最后AC两个进程都无法获得想要的资源

![image-20210103183835470](/images/image-20210103183835470.png)

**单个资源的银行家算法**

对一个请求进行检查，检查这一请求是否能到达安全状态，若可以，则满足该请求，反之延迟该请求。而**检测安全状态**的过程就和死锁检测的过程很像，看资源能否满足某个进程并释放，最后是否能全部释放。

**多个资源的银行家算法**

维护多个资源死锁检测类似的数组和向量，检测安全状态时基本类似

![image-20210103184636849](/images/image-20210103184636849.png)

检查一个状态是否安全的算法如下：

- 查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。
- 假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。
- 重复以上两步，直到所有进程都标记为终止，则状态时安全的。

## 死锁预防

很多时候，无法做到死锁避免，因为很多信息并不知道，这是只能预防死锁，这是实际操作系统避免死锁的操作，银行家算法实际很少使用，因为很少进程一开始就知道所需资源最大值、并且进程数量也会变化、资源也可能突然不可用

实际预防死锁采用破坏操作系统的方式

1.**破坏互斥条件：**

一切使用假脱机技术，允许若干个进程同时产生输出。

2.**破坏占用并等待条件：**

禁止进程等待资源，规定所有进程在开始执行前请求所需要的全部资源。但是如此可以资源利用率低，并且此时可以使用银行家算法进行死锁避免

3.**破坏不可抢占条件：**

抢占资源，将资源虚拟化

4.**破坏环路等待条件：**

对资源按序编号，进程提出的请求必须按资源顺序给出



这部分的内容和数据库死锁部分的内容很有联系，可以互为对照

