---
title: Mysql
typora-root-url: ../
date: 2021-03-16 10:10:34
tags:
- Mysql
categories:
- [数据库]
---

了解MySQL

<!--more-->

# MySQL概念

数据库（Database）是按照数据结构来组织、存储和管理数据的仓库。

每个数据库都有一个或多个不同的 API 用于创建，访问，管理，搜索和复制所保存的数据。

我们也可以将数据存储在文件中，但是在文件中读写数据速度相对较慢。

所以，现在我们使用关系型数据库管理系统（RDBMS）来存储和管理大数据量。所谓的关系型数据库，是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。

RDBMS 即关系数据库管理系统(Relational Database Management System)的特点：

- 1.数据以表格的形式出现
- 2.每行为各种记录名称
- 3.每列为记录名称所对应的数据域
- 4.许多的行和列组成一张表单
- 5.若干的表单组成database

MySQL 是最流行的关系型数据库管理系统，在 WEB 应用方面 MySQL 是最好的 RDBMS(Relational Database Management System：关系数据库管理系统)应用软件之一。

# 安装MySQL

- **下载安装包**

    [下载链接](https://dev.mysql.com/downloads/windows/installer/8.0.html)，点击链接后，选择 第二个（为安装版），点击下载，可以选择不注册下载

- **具体安装教程**

  该部分是在网上找的，我把自己安装参考的博客转载过来

  [参考博客](https://www.cnblogs.com/2020javamianshibaodian/p/mysql8020anzhuangjiaocheng.html)

- **客户端选择**

  正常来说安装完mysql可以使用客户端，这里我使用官方的Mysql  WorkBench，按照上诉过程安装既有

  据说最好用的客户端是 Navicat，但不免费

# 基础使用

基于Mysql  WorkBench使用一些常见命令



## 表相关

- 创建一个数据库和表

  ```mysql
  create database tablelearn;
  use tablelearn;
  CREATE TABLE hero (
    id int(11) AUTO_INCREMENT,
    name varchar(30) ,
    hp float ,
    damage int(11) ,
    PRIMARY KEY (id)
  )  DEFAULT CHARSET=utf8;
  ```

  

- 修改表

  ```mysql
  ALTER TABLE <表名> [修改选项]
  修改选项：
{ ADD COLUMN <列名> <类型>
  | CHANGE COLUMN <旧列名> <新列名> <新列类型>
  | ALTER COLUMN <列名> { SET DEFAULT <默认值> | DROP DEFAULT }
  | MODIFY COLUMN <列名> <类型>
  | DROP COLUMN <列名>
  | RENAME TO <新表名> }
  ```
  
  

## 增删查改

- 插入数据

  ```mysql
  insert into hero values (null, '盖伦', 616, 100)
  ```

- 修改数据

  ```mysql
  update hero set name = "典韦" where id = 2
  ```

- 查询数据

  ```mysql
  select * from hero limit 0,2
  ```

- 删除数据

  ```mysql
  delete from hero where id = 1
  ```

  

# Mysql和IDEA的连接

该连接的效果仅仅是使IDEA充当Mysql  WorkBench可视化的功能，真正要在代码中使用还得用JDBC

- 点`view->tool windows->database`

  之后点击database的+号，添加mysql源

  ![image-20210317164459805](/images/image-20210317164459805.png)

- 填入个人信息，即下载主要是下载时设置的密码，其他可以保持默认

  ![image-20210318095103092](/images/image-20210318095103092.png)

  如果用的是mysql 8 以上版本需要注意时区问题，要在Url加上`?serverTimezone=GMT%2B8`

  最后选择`test Connection`即可

  第一次注意在左下角点击下载驱动

- 连接成功

  此时可以尝试在IDEA中编辑数据库、表

# MySQL索引

Mysql服务器逻辑架构如下

![image-20210317201823243](/images/image-20210317201823243.png)

- 其中最上服务器层主要负责连接管理与安全性，MySQL客户端与服务端的通信连接管理以及用户名密码、对数据库及表的权限校验，都是在这一层完成的
- 第二层包括MySQL核心服务功能，像查询解析、分析、优化、缓存、所有的内置函数以及所有跨存储引擎的功能（存储过程、触发器、视图等）都在这一层
- 第三层就是存储引擎层，存储引擎负责数据的存储和提取，服务器通过一套标准的API可以和不同的存储引擎进行通信，这些API屏蔽了不同存储引擎之间的差异

而mysql中的索引是在最底层的存储引擎层实现的，不同存储引擎可能使用不同的存储结构存储索引。



## B+Tree索引

InnoDB是mysql的默认事务型引擎，主要采用**B+Tree**的结构存储索引

B+Tree主要是由B树演变而来，相较于B-Tree，主要有以下区别：

- B树每个节点都存储数据，所有节点组成这棵树，B+树只有叶子节点存储数据，所有非叶节点只起到索引作用。

- B+所有的叶子结点使用链表相连
- 关键字和子树范围不一致

首先最大的区别B+树只有叶子节点存储数据，其一个关键字代表一个子树的最值，并指向该子树，所以造成了第三点区别

其次正是由于B+树只有叶子节点存储数据，所以其所有的叶子结点使用链表相连才有意义，这给B+数带来了很大的优点：

- 所有的叶子结点使用链表相连，**便于区间查找和遍历**
- B+树叶子节点顺序存储，B树则需要进行每一层的递归遍历，相邻的元素可能在内存中不相邻，所以**缓存命中性**没有B+树好。

数据库索引是存储在磁盘上的，考虑磁盘IO的影响，无论是B+树还是B树，都能**减少IO次数**，特别数据量大时，就不能把整个索引全部加载到内存了，只能逐一加载每一个磁盘页（对应索引树的节点），对于树来说，IO次数就是树的高度，而m的大小取决于磁盘页的大小。
由于采用了B+Tree结构，mysql非常适用于**全键值、键值范围或键前缀查找**

值得注意，其中mysql键前缀查找只适用于**最左前缀的查找**，所以对索引列的顺序要求很高，不可能跳过第一列索引去查找其他列索引，第一列索引也是最左前缀查找，比如以名字为索引的索引中，很难查找以名字的最后一个字为结尾的人

## 哈希索引

哈希索引基于hash表实现，只有在精确匹配索引所有列的查询才有效，即**全键值查找**

采用Hash索引时，对于每行数据，存储引擎都会根据所有索引列值计算一个哈希码，哈希索引将所有的哈希码存储在索引中，同时哈希表中保存指向每个数据行的指针

在mysql中只有Memory引擎显示支持哈希索引，并且支持非唯一值哈希索引（即可以存在hash冲突）

由于hash表的特性其在**全键值查找**中有很快的速度，但是不能支持**范围查询**或者**部分索引列查询**

InnoDB引擎有一个特殊的功能加做**自适应哈希索引**，当某些索引值被频繁使用时，会在内存中基于B+Tree的索引上再创建一个哈希索引，这个是自动的、内部的行为。



## 索引的适应范围

总的来说，索引的目的是为了快速定位到表的指定位置，但是除此之外，索引还有以下几个优点：

- 大大减少服务器需要扫描的数据量
- 使服务器避免排序和临时表
- 可以将随机I/O变成顺序I/O

但是注意索引页带来了额外的开销，只有其快速定位的好处大于这些开销时，索引才是有效的，因此索引主要用于中到大型表。对于小表，简单的全表扫描更高效，对于特大的表维护索引的开销代价更大，需要类似于分区技术等技术直接区分出查询需要的一组数据



## 高性能索引策略

索引三个等级：

1.索引将相关记录放在一起

2.索引数据顺序和查找排列顺序一致

3.索引列包含查询需要的全部列



- **独立的列**

  索引列不要作为表达式的一部分，也不能是函数的参数，应该使索引列单独放在比较符号的一侧

  ```sql
  where id + 1 > 5   error
  where id > 4       right
  ```

- **前缀索引和索引选择性**

  **索引选择性**是指不重复的索引值和数据表的记录总数的比值

  **前缀索引**在于选择足够长的前缀保持较高的选择性，同时又不能太长（和完整列的选择性比较即可）可以节约索引空间，从而提高索引效率

  创建前列索引

  ```java
  alter table xx add key (city(7)) // 7是前缀长度
  ```

- **多列索引和单列索引比较**

  多个单例索引最多只能保持第一个等级，这时需要考虑创建多列索引，特别是会对这**多个单列索引进行相交、联合操作时**

- **选择合适的索引列顺序**

  不考虑排序和分组时，考虑**选择性高**的索引放前面通常较好

  同时也要注意where子句中的排序、分组和范围条件等其他因素

- **覆盖索引**

  指一个索引包含（覆盖）所有需要查询的字段的值，这时就不需要回表，能极大的提高性能，减少数据访问量。此外我们知道InnoDB的二级索引中保存了行的主键值，如果二级主键能够覆盖查询，可以避免对主键的二次查询，

- **聚簇索引**

  聚簇索引不是一种单独的索引类型，也是一种数据存储方式，**聚簇表示数据行和相邻的键值紧凑地存储在一起**

  InnoDB通过主键聚集数据

  优点：

  - 相关数据保存在一起减少磁盘I/O
  - 数据访问比非聚簇索引中查找块
  - 使用覆盖索引扫描的查询可以直接使用页节点主键值

  缺点：

  - 数据如果全在内存中优势不大
  - 插入速度严重依赖插入顺序：主键最快
  - 更新代价高，每个被更新行会被移动到新的位置
  - 插入、更新行可能会导致页分裂占用更多的磁盘空间
  - 可能导致全表扫描变慢
  - 二级索引可能更大（引用行主键列），访问也需要两次，先找到主键值再去聚簇查询

- 利用索引扫描来做排序

  mysql可以考索引顺序扫描和顺序全表排序操作生成有序的结果，和覆盖索引类似。如果索引列顺序和排序列顺序一致，就可以使用索引来对结果做排序优化性能

- **索引选择基本原则**

  索引的使用尽量选择`查询频率比较高的字段`作为`最左字段`，优先考虑`联合索引`, 尽量查询可以去做到`覆盖索引`，索引字段需要`比较小的字段` ，没事不要把`范围查询`放在联合索引，`变得快的字段`不建议建立索引

# Mysql查询优化

查询的生命周期大致可以分为：从客户端到服务器，服务器上解析生成执行计划，执行（检索数据、调用存储引擎、数据处理），最后返回结果给客户端

查询优化，首先得了解一点在上诉周期的时间消耗

## 数据访问优化

- **不用请求不需要的数据**

  - 如果没有必要取出全部列，或者也没有必要请求全部行，那就不用请求

  - 如果总是要查询相同的数据，得考虑缓存

- **减少额外的扫描记录**

  如果查询需要扫描大量数据但是只是需要少数行，可以尝试：

  - 使用索引覆盖扫描，减少回表
  - 改变库表结构，建立汇总表

## 查询重构优化

- **一个复杂查询是否能够分解为几个简单查询**

- **切分查询**

  和上诉的区别在于切分的小查询是减少了查询数据量，但是功能一致，降低对服务器的影响

- **分解关联查询**

## 特定类型查询优化

- **count查询优化**

  count可以用来统计某个列值数量（不统计NULL）也可以用来统计行数

  当mysql认为括号里面的表达式值不可能为空时，实际就是统计行数，所以而使用**`count(*)`**，而忽略所以列直接统计所有的行数，所以真的要统计行数时，不用在里面指定某个列

- **关联查询优化**

  - 确保On或者Using子句中的列上有索引，确保关联顺序后面的表上有索引

  - 确保分组或者排序中的表达式只涉及到一个表中的列，才有可能用索引了优化这个过程

- **优化limit分页**

  分页操作经常用到limit加偏移量的方法实现，同时加上合适的order by 语句

  但是偏移量大大时，最好是使用索引覆盖扫描，再根据需求做一次关联操作再返回需要的列