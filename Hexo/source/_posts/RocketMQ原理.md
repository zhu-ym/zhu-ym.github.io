---
title: RocketMQ原理
typora-root-url: ../
date: 2021-05-25 14:43:15
tags:
- 消息队列
categories:
- [中间件]
---

了解RocketMQ的一些设计原理

<!--more-->

# 一、概述

`RocketMQ` 是一个 **队列模型** 的消息中间件，具有**高性能、高可靠、高实时、分布式** 的特点。

# 二、消息模型

RocketMQ采用的消息模型是**发布订阅模型**，也叫**主题模型**，其中：

消息的生产者称为 **发布者(Publisher)** ，消息的消费者称为 **订阅者(Subscriber)** ，存放消息的容器称为 **主题(Topic)** 。

发布者将消息发送到指定主题中，订阅者需要 **提前订阅主题** 才能接受特定主题的消息。

对于RocketMQ，其主题模型的实现，如下图所示：

![image-20210525145954822](/images/image-20210525145954822.png)

- 首先其一个**Topic配置了多个队列，并且每个队列队列维护了每个消费者组的消费位置**。前者提高了并发能力，后者就是让多个消费群组记录自己的消费位置，不会重复消费
- 然后一个**生产者组生产相同的消息，生产者组有可以有多个生产者**
- 最后一个**消费者组可以有多个消费者，共同消费一个 `topic` 的多个队列，一个队列只会被一个消费者消费**

总的来说该RocketMQ如此实现的主题模型明显**适合于分布式横向扩展部署架构**，不仅生产者组消费者组可以集群部署、一个Topic也适合集群部署

# 三、架构组成

`RocketMQ` 技术架构中有四大角色 `NameServer` 、`Broker` 、`Producer` 、`Consumer` 。

![image-20210525152218692](/images/image-20210525152218692.png)

## NameServer

**`主要负责对于源数据的管理，包括了对于Topic和Broker路由信息的管理。`**

具体来说，如上图所示

每个 `Broker `在启动的时候会到 `NameServer `注册，`Producer` 在发送消息前会根据 `Topic `到 `NameServer` 获取到 `Broker `的路由信息，`Consumer` 也会定时获取 `Topic` 的路由信息，然后再和对应的`Broker`进行通信。

`NameServer`压力不会太大，平时主要开销是在维持心跳和提供Topic-Broker的关系数据，其降低了`Broker`修改时对生产者和消费者的影响

 最后`NameServer` 可以做集群部署，其是去**中心化**的，意味着在 `RocketMQ` 中 **单个Broker和所有NameServer保持长连接**

## Broker

**`消息中转角色，负责存储消息，转发消息。`**

`Broker`是具体提供业务的服务器，单个`Broker`节点与所有的`NameServer`节点保持长连接及心跳，并会定时将`Topic`信息注册到`NameServer`,当生产者、消费者从`NameServer`得到`Broker `的路由信息后，生产者生产消息到 `Broker` ，消费者从 `Broker` 拉取消息并消费

前面说到`RocketMQ`的主题模型明显**适合于分布式横向扩展部署架构**，主要在于**一个 `Topic` 的多个队列可以分布在多个 `Broker`上，一个 `Broker` 可以配置多个 `Topic` ，它们是多对多的关系**。

## Producer

**`消息生产者，负责产生消息，一般由业务系统负责产生消息`**

`Producer`由用户进行分布式部署，消息由`Producer`通过多种**负载均衡模式**发送到`Broker`集群，发送低延时，支持快速失败。

其中主要有三种方式发送消息：同步、异步和单向

- **同步发送**：同步发送指消息发送方发出数据后会在收到接收方发回响应之后才发下一个数据包。一般用于重要通知消息，例如重要通知邮件、营销短信。
- **异步发送**：异步发送指发送方发出数据后，不等接收方发回响应，接着发送下个数据包，一般用于可能链路耗时较长而对响应时间敏感的业务场景，例如用户视频上传后通知启动转码服务。
- **单向发送**：单向发送是指只负责发送消息而不等待服务器回应且没有回调函数触发，适用于某些耗时非常短但对可靠性要求并不高的场景，例如日志收集。

## Consumer

**`消息消费者，负责消费消息，一般是后台系统负责异步消费。`**

`Consumer`支持以`push`推，`pull`拉两种模式对消息进行消费

- **Pull**：消费者主动从`Broker`拉取信息，拉模式更适合进行消息的批量发送，`Broker`可以参考消费者请求的信息来决定缓存多少消息之后批量发送。但是存在消息延迟、消息忙请求等问题
- **Push**：消息从 Broker 推向 Consumer，消息实时性高,但难以根据消费者的状态控制推送速率。 Push 首先要注册消费监听器，当监听器处触发后才开始消费消息。

此外消息着的消费模式也有两种：集群消费）和广播消费：

- **集群消费：**默认情况下就是集群消费，该模式下一个消费者集群共同消费一个主题的多个队列，一个队列只会被一个消费者消费，如果某个消费者挂掉，分组内其它消费者会接替挂掉的消费者继续消费。

- **广播消费：**广播消费消息会发给消费者组中的每一个消费者进行消费。

# 四、持久化

## 刷盘机制

刷盘机制涉及到单个`Broker`的持久化

`RocketMQ`可以通过设置 `Broker` 的参数 `FlushDiskType` 来调整刷盘策略**异步刷盘**（ASYNC_FLUSH ）或者**同步刷盘**（SYNC_FLUSH)。

`RocketMQ`的存储读写是基于`JDK NIO`的内存映射机制的，消息存储时首先将消息追加到**内存**中。在根据不同的刷盘策略在不同的时间进行刷盘

- **同步刷盘:**消息追加到内存后，将同步调用`MappedByteBuffer`的`force()`方法，同步等待刷盘结果，进行刷盘结果返回
- **异步刷盘:**在消息追加到内存后立刻，不等待刷盘结果立刻返回存储成功结果给消息发送端。`RocketMQ`使用一个单独的线程按照一个设定的频率执行刷盘操作

显然，前者需要等待刷盘结果，**消息可靠性高**，但是**性能上会有较大影响** ，一般地适用于金融等特定业务场景。

后者往往是开启一个线程去按照一定频率异步地执行刷盘操作， **降低了读写延迟** ，提高了 `MQ` 的性能和吞吐量，但是在 `Broker` 意外宕机的时候会丢失部分数据，所以一般适用于如发验证码等对于消息保证要求不太高的业务场景。

## 同步、异步复制

同步复制和异步复制主要是指的 `Borker` 主从模式下，主节点返回消息给客户端的时候是否需要同步从节点。

- **同步复制**： 也叫 “同步双写”，也就是说，**只有消息同步双写到主从结点上时才返回写入成功** 。
- **异步复制**： **消息写入主节点之后就直接返回写入成功** 。

但是注意**是 `RocketMQ` 是不支持自动主从切换的，当主节点挂掉之后，生产者就不能再给这个主节点生产消息了**。**消费者可以自动切换到从节点进行消费**，这时如果采用来异步复制，可能会出现主从消息不一致的现象，会降低可用性。

## 存储机制

`RocketMQ`的存储机制主要和`CommitLog`、`ConsumeQueue`和`IndexFile`有关，其中`IndexFile`提供了一种可以通过key或时间区间来查询消息的方法，这里不做深入了解。

- **`CommitLog:`**消息主体以及元数据的存储主体，采用**混合型存储**方式，即**所有的Topic下的消息队列共用同一个`CommitLog`的日志数据文件**，**提高了数据的写入效率**。单个文件大小默认为1G,消息主要是**顺序写入日志文件**，当第一个文件写满了、默认到下一个。

- **`ConsumeQueue:`**消息消费队列，前面`CommitLog`采用了混合型存储方式，数据直接遍历寻找指定Topic队列下的消息花费大，`ConsumeQueue`相当于一层索引、**提升读取消息的效率**，其更像是我们上诉消息模型中的队列。其大小固定，维护了 `ConsumeOffset` 即每个消费者组的消费位置，消费者根据消费者拉取消息进行消费的时候只需要根据 `ConsumeOffset` 获取在`Consumeoffset`下一个未被消费的**消息索引**，消息索引包含了在 `CommitLog` 中的**起始物理偏移量** `commitLogOffset`、**消息大小** `msgSize` 和**消息 Tag的哈希值**`tagsCode` 的，再定位到`CommitLog`中就可以读取到指定消息

详情可以参考下图

![image-20210525190217950](/images/image-20210525190217950.png)

在图中最左边说明了 红色方块 代表被写入的消息，虚线方块代表等待被写入的。左边的生产者发送消息会指定 `Topic` 、`QueueId` 和具体消息内容，而在 `Broker` 中将消息全部顺序存储到了 CommitLog 。而根据生产者指定的 `Topic` 和 `QueueId` 将这条消息本身在 `CommitLog` 的偏移(offset)，消息本身大小，和tag的hash值存入对应的 `ConsumeQueue` 索引文件中。而在每个队列中都保存了 `ConsumeOffset` 即每个消费者组的消费位置，而消费者拉取消息进行消费的时候只需要根据 `ConsumeOffset` 获取下一个未被消费的消息。

# 五、一些问题的解决

## 顺序消费

我们知道一个队列里消息是有顺序的，不同消息队列收到的消息则可能是无顺序的

由于负载均衡策略，在秒杀系统时，一个订单的创建、发货、收货可能因为轮询放在了一个Topic下的不同队列中，从而导致无法使用 `RocketMQ` 带来的队列有序特性来保证消息有序性

我们可以利用 `RocketMQ` 队列选择机制的**Hash取模法**将一个订单的创建、发货、收货消息发送到一个队列中避免这个问题

## 重复消费

重复消费的问题可用通过**幂等**解决，根据应用场景，一般有强校验和弱校验

**强校验**

事务+查流水表

**弱校验**

Redis key

## 分布式事务

RocketMQ主要通过**半消息**、**消息回查**和**二次确认**等操作实现分布式事务

半消息是指事务在提交前，对消费者不可见的消息，内部可以通过改变主题实现：

如果消息是half消息，将备份原消息的主题与消息消费队列，然后 **改变主题** 为`RMQ_SYS_TRANS_HALF_TOPIC`。由于消费组未订阅该主题，故消费端无法消费half类型的消息，然后RocketMQ会开启一个定时任务，从`Topic`为`RMQ_SYS_TRANS_HALF_TOPIC`中拉取消息进行消费，根据生产者组获取一个服务提供者发送**回查事务**状态请求，根据事务状态的**二次确认**来决定是提交或回滚消息。

当然，如果在指定时间内发送方已经将事务执行并将执行情况成功告知，就没有事务回查这一步，**直接二次确认**

可以见下图

![image-20210525194051219](/images/image-20210525194051219.png)

注意：在 `MQ Server` 指向系统B的操作已经和系统A不相关了，也就是说在消息队列中的分布式事务是——**本地事务和存储消息到消息队列才是同一个事务**。这样也就产生了事务的**最终一致性**，因为整个过程是异步的，**每个系统只要保证它自己那一部分的事务就行了**。