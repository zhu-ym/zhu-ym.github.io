---
title: 网络IO
typora-root-url: ../
date: 2021-04-24 15:39:35
tags:
- IO
categories:
- [网络通信,网络IO]
---

对网络IO的知识进行简单了解

<!--more-->

# 一、基本概念

## 1.同步、异步；阻塞、非阻塞

对于**IO上面的理解**

同步异步描述的是**用户线程**同**内核**的两个方面的交互状态

- **同步**指用户线程发起IO请求后，需要**等待或者轮询内核IO操作完成**后，才能继续执行
- **异步**是指用户线程向内核发起IO请求后，依旧可以继续执行，而**内核的IO操作完成后，会通知用户线程或者执行用户线程注册的回调函数**

阻塞和非阻塞描述的是**用户线程**调用IO操作的方式

- **阻塞**指**IO操作彻底完成后**才返回用户空间

- **非阻塞**指IO操作被调用时立即返回一个**状态值**，不需要IO操作彻底完成



在更高层面上理解的话，**同步、异步是两个对象之间的关系，而阻塞、非阻塞是一个对象的状态**。

比如对于通信，同步和异步是指：发送方和接收方是否协调步调一致；对于线程，是指两个线程的运行是否相关，会被阻塞

而阻塞和同步、异步的关系，**阻塞可以是实现同步的一种手段**。例如两个东西需要同步，一旦出现不同步情况，我就阻塞快的一方，使双方达到同步



一篇转载文章理解

[转载至灵剑](https://www.zhihu.com/question/19732473/answer/117012135)

一个网络包从应用程序A发到另一台电脑上的应用程序B，需要经历：

1. 从A的业务代码到A的软件框架
2. 从A的软件框架到计算机的操作系统内核
3. 从A所在计算机的内核到网卡
4. 从网卡经过网线发到交换机等设备，层层转发，到达B所在计算机的网卡
5. 从B所在计算机的网卡到B所在计算机的内核
6. 从B所在计算机的内核到B的程序的用户空间
7. 从B的软件框架到B的业务代码

这个层级关系就像是过程调用一样，前一级调用后一级的功能，后一级返回一个结果给前一级（比如：成功，或者失败）。只有在单独一级的调用上，可以说同步还是异步的问题。所谓同步，是指调用协议中结果在调用完成时返回，这样调用的过程中参与双方都处于一个状态同步的过程。而异步，是指调用方发出请求就立即返回，请求甚至可能还没到达接收方，比如说放到了某个缓冲区中，等待对方取走或者第三方转交；而结果，则通过接收方主动推送，或调用方轮询来得到。

从这个定义中，我们看，首先1和7，这取决于软件框架的设计，如果软件框架可以beginXXX，然后立即返回，这就是一种异步调用，再比如javascript当中的异步HTTP调用，传入参数时提供一个回调函数，回调函数在完成时调用，再比如协程模型，调用接口后马上切换到其他协程继续执行，在完成时由框架切换回到协程中，这都是典型的异步接口设计。

**而2和6，其实都需要调用方自己把数据在内核和用户空间里搬来搬去，其实都是同步接口，除非是IOCP这样的专门的异步传输接口，所以这一级其实是同步的，阻塞与非阻塞的区别其实是影响调用接口的结果（在特定条件下是否提前返回结果），而不是调用方式。**

3和5，内核一般通过缓冲区，使用DMI来传输数据，所以这一步又是异步的。

4，以太网是个同步时序逻辑，随信号传输时钟，必须两边设备同时就绪了才能开始传输数据，这又是同步的。

总结来说，讨论究竟是异步还是同步，一定要严格说明说的是哪一部分。其他答主说非阻塞是同步而不是异步，这毫无疑问是正确的，然而说某个框架是异步IO的框架，这也是正确的，因为说的其实是框架提供给业务代码的接口是异步的，不管是回调还是协程，比如说我们可以说某个库是异步的HTTPClient，并没有什么问题，因为说的是给业务代码的接口。由于通常异步的框架都需要在2中使用非阻塞的接口，的确会有很多人把非阻塞和异步混为一谈。



## 2.一个网络通信过程

**一个服务端处理请求的过程**

![image-20210424170224633](/images/image-20210424170224633.png)



# 二、常见IO模型

## 同步阻塞IO

通过阻塞实现同步，用户在内核进行IO操作时阻塞

![image-20210507153854260](/images/image-20210507153854260.png)

用户线程通过系统调用read发起IO读操作，由用户空间转到内核空间。内核等到数据包到达后，然后将接收的数据拷贝到用户空间，完成read操作。

由于用户需要等待read将socket中的数据读取到buffer后，才继续处理接收的数据。整个IO请求的过程中，用户线程是被阻塞的，这导致用户在发起IO请求时，不能做任何事情，对CPU的资源利用率不够。

## 同步非阻塞IO

此时用户线程在发起IO请求后立即返回，为了实现同步，用户线程执行轮询操作直到IO操作完成

![image-20210507154448923](/images/image-20210507154448923.png)

这里socket是非阻塞的方式，因此用户线程发起IO请求时立即返回。但并未读取到任何数据，用户线程需要不断地发起IO请求，直到数据到达后，才真正读取到数据，继续执行。

可见该方法避免了用户线程阻塞，但是不断的轮询会消耗大量的CPU资源，一般很少使用。如果在线程轮询消耗远小于线程阻塞、唤醒、切换的消耗，可以考虑使用，类似于Java synchronized用自旋锁优化的过程

## IO多路复用



### **select**

select是内核提供的多路分离函数，可以使用其实现IO端口的复用

下面是Linux中的select设计

关键有两个结构体

```c
fd_set
timeval
```

其中**fd_set**可以认为是一个位图，每一位标志相应大小文件描述符（每一个文件描述符同一个socket对应），fd_set主要有三种类型：readfds、writefds、errorfds，对应可读、可写、异常等情况

**timeval**主要记录时间

调用select函数时，参数如下

```c
int select(int maxfdp,fd_set *readfds,fd_set *writefds,fd_set *errorfds,struct timeval *timeout);
```

其中maxdp是所有文件描述符的范围，为fd_set中所有文件描述符的最大值加1

中间三个fds分别代表监控读、写、错误异常文件，可以传null值表示不关心

最后的timeout是select的超时时间：

- 为NULL：将select置于阻塞状态，一定等到监视文件描述符集合中某个文件描述符发生变化为止
- 为0，就变成一个纯粹的非阻塞函数，不管文件描述符是否有变化，都立刻返回继续执行，文件无变化返回0，有变化返回一个正值
- 正值，是等待的超时时间，即 select在timeout时间内阻塞，超时时间之内有事件到来就返回了，否则在超时后不管怎样一定返回，返回值同上述。

最后就可以对select的工作流程进行概述：

select会循环遍历它所监测的fd_set内的所有文件描述符对应的驱动程序的poll函数。驱动程序提供的poll函数首先会将调用select的用户进程插入到该设备驱动对应资源的等待队列(如读/写等待队列)，然后返回一个bitmask告诉select当前资源哪些可用。当select循环遍历完所有fd_set内指定的文件描述符对应的poll函数后，如果没有一个资源可用(即没有一个文件可供操作)，则select让该进程睡眠，一直等到有资源可用为止，进程被唤醒(或者timeout)继续往下执行。

## Reactor模式

![image-20210507170500479](/images/image-20210507170500479.png)