---
title: 剑指14-剪绳子
typora-root-url: ../
date: 2021-02-20 14:25:53
tags:
- 动态规划
categories:
- [剑指Offer]
- [算法,趣味题]
- [算法,动态规划]
---

**剑指 Offer 14.剪绳子**

[剑指 Offer 14- I. 剪绳子](https://leetcode-cn.com/problems/jian-sheng-zi-lcof/)

[剑指 Offer 14- II. 剪绳子 II](https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/)

<!--more-->

# 题目描述

给你一根长度为 `n` 的绳子，请把绳子剪成整数长度的 `m` 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 `k[0],k[1]...k[m - 1]` 。请问 `k[0]*k[1]*...*k[m - 1]` 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。

答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

 

**示例 1：**

```
输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1
```

**示例 2:**

```
输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36
```

 

**提示：**

- `2 <= n <= 58`，对于剪绳子，答案也不要求取模

- `2 <= n <= 1000`，对于剪绳子 II

即两题的区别在于可能会越界

# 思路一：动态规划

读题意知道绳子必须要剪，我们可以简化问题，假设一段绳子剪两段，一段固定，题目就转化求固定段*另一段乘积的最大值，而求另一段乘积的最大值就是重叠子问题，提醒我们该题可以用动态规划来解决。

假设dp[i]表示长度为i的绳子的最大乘积，又注意到当绳子较小时dp[i]未必有长度为i的绳子大，所以可以得出下面的状态转移方程

`dp[i] = max(dp[i],max(dp[j]*(i - j),j*(i - j))),j：1~i-1、`

代码如下

```java
class Solution {
    public int cuttingRope(int n) {
        int[] dp = new int[n + 1];
        dp[1] = 1;
        for(int i = 2 ; i <= n ; i++){
            for(int len = 1; i - len >= 1; len++){
                dp[i] = Math.max(dp[i],Math.max(len * dp[i-len],len * (i-len)));          
        }}   
    return dp[n];
}
}
```

但是注意**该题将n的范围扩大后**，得到的dp[i]会非常大，int、long都可能出现大数越界，无法保存信息，如果还需要使用动态规划，就需要使用`BigInteger`开销倍增

而且该方法的时间复杂度是O(n²)

# 思路二：数学规律

由下面公式有

![image-20210220151351235](/images/image-20210220151351235.png)

当划分段数一定时，绳子以相等的长度等分为多段，得到的乘积最大

下面研究段数即和划分长度的关系

![image-20210220151645677](/images/image-20210220151645677.png)

求该函数的极值点，得极值点为e，但是绳子只能取整数，最终的绳子划分为3的整数段最大，再考虑到划分后绳子余1，余2的情况，余1，3*1<2\*2；余2,2\*3最大,为了统一处理可以用数组记录这些值，该问题已经转化为求3的幂的问题

求幂问题使用快速幂，时间复杂度O(logn)

```java
class Solution {
    public int cuttingRope(int n) {
        int dp2[] = {3,4,6};
        if(n < 4)
        return n - 1;
        int a = n / 3;
        int b = n % 3;
        return (int)(pow(a-1)*dp2[b] % 1000000007);
    }
    public long pow(int a){
        if(a == 0)
        return 1;
        if(a == 1)
        return 3;
        long result = pow(a / 2);
        if((a&1) == 1)
        return (result * result * 3) % 1000000007;
        return (result * result) % 1000000007;
    }
}
```

上诉代码是递归实现，在下面的题目中遇到单纯的快速幂问题再做细解。

# 总结

该题不知道说是好还是不好，毕竟数学规律的题真出现在试题中未必能够想出来，就当巩固了动态规划和快速幂知识吧